##### Neuromancer : 151 주차 
##### 일시        : 2016.07.16 (151주차 스터디 진행)
##### 모임명      : neuromancer.kr
##### 장소        : 토즈 서현점
##### 장소지원    : 공개 소프트웨어 개발자 커뮤니티 지원 프로그램
##### 참여인원    : 2명
============

## 151주차 진도

* ᇂ151차 시작 위치
  - start_kernel        1  ~/init/main.c
  - proc_root_init    937  ~/init/main.c
  - proc_sys_init     609  ~/fs/proc/root.c
  - sysctl_init      2488  return sysctl_init();
  - register_sysctl_table  1696  ~/kernel/sysctl.c
  - register_sysctl_paths  2330  return register_sysctl_paths(null_path, table);
  - __register_sysctl_paths  2309  return __register_sysctl_paths(&sysctl_table_root.default_set,
  - register_leaf_sysctl_tables  2272  if (register_leaf_sysctl_tables(new_path, pos, &subheader,
  - __register_sysctl_table  2121  header = __register_sysctl_table(set, path, files);
  - insert_header    1885  if (insert_header(dir, header))

#### 151 주차 함수 호출 구조

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_lead_sysctl_table()

* call: register_leaf_sysctl_table()
 - __register_sysctl_table()

* call: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()

* call: insert_keader()
 - insert_links()
 - insert_entry()

* return: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()
 - drop_sysctl_table()

* call: drop_sysctl_table()

## start_kernel()

* call: start_kernel()
 - proc_root_init()

```main.c
asmlinkage void __init start_kernel(void)
{
	char * command_line;
	extern const struct kernel_param __start___param[], __stop___param[];
	// ATAG,DTB 정보로 사용

...

    proc_caches_init();
	// sighand_struct, signal_struct, files_struct, fs_struct, mm_struct, vm_area_struct, nsproxy
	// 를 사용하기 위한 kmem_cache 할당자 및 percpu list 초기화 수행

...

	vfs_caches_init(totalram_pages);
	// virtual file system을 위한 names, dentry, inode, filp, mount cache 생성 후
	// file system 을 위한 초기화 수행 및 mount 수행, block, char dev 사용을 위한 초기화 수행

	signals_init();
	// signal을 사용하기 위한 kmem_cache 를 생성

	/* rootfs populating might need page-writeback */
	page_writeback_init();
	// page writeback을 위한 global_dirty_limit, ratelimit_pages 값을 초기화 수행

#ifdef CONFIG_PROC_FS // CONFIG_PROC_FS=y
	proc_root_init();
```

## proc_root_init()

* calll: start_kernel()
 - proc_root_init()

* call: call_root_init()

```root.c
// ARM10C 20160604
void __init proc_root_init(void)
{
	int err;

	proc_init_inodecache();

	// proc_init_inodecache 에서 한일:
	// struct proc_inode 크기 만큼의 메모리를 할당항는 kmem_cache 할당자를 생성함
	// proc_inode_cachep: kmem_cache#n#28 (struct proc_inode)

	// register_filesystem(&proc_fs_type): 0
	err = register_filesystem(&proc_fs_type);
	// err: 0

	// register_filesystem에서 한일:
	// (&bd_type)->next: &proc_fs_type
	//
	// file system 연결 결과
	// file_systems: sysfs_fs_type -> rootfs_fs_type -> shmem_fs_type -> bd_type -> proc_fs_type

	// err: 0
	if (err)
		return;

	proc_self_init();

	// proc_self_init 에서 한일:
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 2 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 1번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 1         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 1)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 1 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 2
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 1) 의 memory 공간을 반환함
	//
	// self_inum: 0xF0000001

	// proc_symlink("mounts", NULL, "self/mounts"): kmem_cache#29-oX (struct proc_dir_entry)
	proc_symlink("mounts", NULL, "self/mounts");

	// proc_symlink 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "mounts"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 6
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0120777
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: kmem_cache#30-oX: "self/mounts"
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 2번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 2         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 2)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 2 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 3
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 2) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000002
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_link_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)

	// proc_net_init(): 0
	proc_net_init();

	// proc_net_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "net"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0120777
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: kmem_cache#30-oX: "self/net"
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 3번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 3         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 3)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 3 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 4
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 3) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000003
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_link_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)
	//
	// list head 인 &pernet_list 에 &(&proc_net_ns_ops)->list 을 tail로 추가함

#ifdef CONFIG_SYSVIPC // CONFIG_SYSVIPC=y
	// proc_mkdir("sysvipc", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("sysvipc", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "sysvipc"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 7
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
#endif
	// proc_mkdir("fs", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("fs", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "fs"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 2
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_mkdir("driver", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("driver", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "driver"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 6
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_mkdir("fs/nfsd", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("fs/nfsd", NULL); /* somewhere for the nfsd filesystem to be mounted */

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "fs/nfsd"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 7
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE) // CONFIG_SUN_OPENPROMFS=n, CONFIG_SUN_OPENPROMFS_MODULE=n
	/* just give it a mountpoint */
	proc_mkdir("openprom", NULL);
#endif
	proc_tty_init();

	// proc_tty_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/ldisc"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 9
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/driver"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 10
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 00500
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/ldiscs"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 10
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0100444
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &tty_ldiscs_proc_fops
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: NULL
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 4번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 4         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 4)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 4 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 5
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 4) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000004
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_file_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/drivers"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 11
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0100444
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &proc_tty_drivers_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: NULL
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 5번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 5         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 5)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 5 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 6
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 5) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000005
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_file_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)

#ifdef CONFIG_PROC_DEVICETREE // CONFIG_PROC_DEVICETREE=y
	proc_device_tree_init();

	// proc_device_tree_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "device-tree"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 11
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// unflatten_device_tree 에서 만든 tree의 root node 의 값을 사용하여proc device tree를 만드는 작업을 수행
#endif
	proc_mkdir("bus", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "bus"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	proc_sys_init();
```

## proc_sys_init()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()

* call: proc_sys_init()

```proc_sysctl.c
// ARM10C 20160611
int __init proc_sys_init(void)
{
	struct proc_dir_entry *proc_sys_root;

	// proc_mkdir("sys", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_sys_root = proc_mkdir("sys", NULL);
	// proc_sys_root: kmem_cache#29-oX (struct proc_dir_entry)

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "sys"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_sys_root->proc_iops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops
	proc_sys_root->proc_iops = &proc_sys_dir_operations;
	// proc_sys_root->proc_iops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_sys_dir_operations

	// proc_sys_root->proc_fops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops
	proc_sys_root->proc_fops = &proc_sys_dir_file_operations;
	// proc_sys_root->proc_fops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &proc_sys_dir_file_operations

	// proc_sys_root->nlink: (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	proc_sys_root->nlink = 0;
	// proc_sys_root->nlink: (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 0

	return sysctl_init();
}
```

## sysctl_init()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()

```sysctl.c
// ARM10C 20160611
int __init sysctl_init(void)
{
	struct ctl_table_header *hdr;

	hdr = register_sysctl_table(sysctl_base_table);
```

## register_sysctl_table()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()

```proc_sysctl.c
// ARM10C 20160611
// sysctl_base_table
struct ctl_table_header *register_sysctl_table(struct ctl_table *table)
{
	static const struct ctl_path null_path[] = { {} };

	// table: sysctl_base_table
	return register_sysctl_paths(null_path, table);
}
EXPORT_SYMBOL(register_sysctl_table);
```

## register_sysctl_paths()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()

```proc_sysctl.c
// ARM10C 20160611
// null_path, table: sysctl_base_table
struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,
						struct ctl_table *table)
{
	// path: null_path, table: sysctl_base_table
	return __register_sysctl_paths(&sysctl_table_root.default_set,
					path, table);
}
EXPORT_SYMBOL(register_sysctl_paths);
```

## __register_sysctl_paths()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()

```proc_sysctl.c
// ARM10C 20160611
// &sysctl_table_root.default_set, path: null_path, table: sysctl_base_table
struct ctl_table_header *__register_sysctl_paths(
	struct ctl_table_set *set,
	const struct ctl_path *path, struct ctl_table *table)
{
	// table: sysctl_base_table
	struct ctl_table *ctl_table_arg = table;
	// ctl_table_arg: sysctl_base_table

	// table: sysctl_base_table
	int nr_subheaders = count_subheaders(table);
```

## count_subheaders()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()

* call: count_subheaders()

```proc_sysctl.c
// ARM10C 20160611
// table: sysctl_base_table
static int count_subheaders(struct ctl_table *table)
{
	int has_files = 0;
	// has_files: 0

	int nr_subheaders = 0;
	// nr_subheaders: 0

	struct ctl_table *entry;

	/* special case: no directory and empty directory */
	// table: sysctl_base_table, table->procname: sysctl_base_table[0].procname: "kernel"
	if (!table || !table->procname)
		return 1;

// 2016/06/11 종료

	// table: sysctl_base_table, entry: sysctl_base_table, entry->procname: sysctl_base_table[0].procname: "kernel"
	for (entry = table; entry->procname; entry++) {

		// entry->child: sysctl_base_table[0].child: kern_table
		if (entry->child)
			// nr_subheaders: 0, entry->child: sysctl_base_table[0].child: kern_table
			nr_subheaders += count_subheaders(entry->child);
		else
			has_files = 1;
	}
	return nr_subheaders + has_files;
}
```

## count_subheaders()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()

* call: count_subheaders()
 - count_subheaders()
 - self_call (재귀적 함수)이다.

* [f1]
 - entry->child : sysctl_base_table[0].child: kern_table
 - count_subheaders(kern_table) : 2
 - nr_subheaders : 2
 
* [f2]
 - entry->child : sysctl_base_table[1].child: vm_table
 - count_subheaders(kern_table) : 0
 - nr_subheaders : 2

* [f3]
 - entry->child : sysctl_base_table[2].child: fs_table
 - count_subheaders(kern_table) : 0
 - nr_subheaders : 2

* [f4]
 - entry->child : sysctl_base_table[2].child: debug_table
 - count_subheaders(kern_table) : 0
 - nr_subheaders : 2

* [f5]
 - entry->child : sysctl_base_table[2].child: device_table
 - count_subheaders(kern_table) : 0
 - nr_subheaders : 2

* return: __register_sysctl_paths()

## __register_sysctl_paths()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()

* call: count_subheaders()
 - count_subheaders()
 - self_call (재귀적 함수)이다.

* return: __register_sysctl_paths()
 - count_subheaders()

```proc_sysctl.c
// ARM10C 20160611
// &sysctl_table_root.default_set, path: null_path, table: sysctl_base_table
struct ctl_table_header *__register_sysctl_paths(
	struct ctl_table_set *set,
	const struct ctl_path *path, struct ctl_table *table)
{
	// table: sysctl_base_table
	struct ctl_table *ctl_table_arg = table;
	// ctl_table_arg: sysctl_base_table

	// table: sysctl_base_table, count_subheaders(sysctl_base_table): 2
	int nr_subheaders = count_subheaders(table);
	// nr_subheaders: 2

	struct ctl_table_header *header = NULL, **subheaders, **subheader;
	// header: NULL

	const struct ctl_path *component;
	char *new_path, *pos;

	// PATH_MAX: 4096, GFP_KERNEL: 0xD0,
	// kmalloc(4096, GFP_KERNEL: 0xD0): kmem_cache#23-oX
	pos = new_path = kmalloc(PATH_MAX, GFP_KERNEL);
	// pos: kmem_cache#23-oX, new_path: kmem_cache#23-oX

	// new_path: kmem_cache#23-oX
	if (!new_path)
		return NULL;

	// pos[0]: (kmem_cache#23-oX)[0]
	pos[0] = '\0';
	// pos[0]: (kmem_cache#23-oX)[0]: '\0'

	// path: null_path, component: null_path, component->procname: null_path->procname: NULL
	for (component = path; component->procname; component++) {
		pos = append_path(new_path, pos, component->procname);
		if (!pos)
			goto out;
	}

	// table->procname: sysctl_base_table[0].procname: "kernel",
	// table->child: sysctl_base_table[0].child: kern_table,
	// table[1]->procname: sysctl_base_table[1].procname: "vm",
	while (table->procname && table->child && !table[1].procname) {
		pos = append_path(new_path, pos, table->procname);
		if (!pos)
			goto out;
		table = table->child;
	}

	// nr_subheaders: 2
	if (nr_subheaders == 1) {
		header = __register_sysctl_table(set, new_path, table);
		if (header)
			header->ctl_table_arg = ctl_table_arg;
	} else {
		// header: NULL, sizeof(struct ctl_table_header): 32 bytes
		// sizeof(*header): 32, sizeof(*subheaders): 4, nr_subheaders: 2, GFP_KERNEL: 0xD0,
		// kzalloc(256, GFP_KERNEL: 0xD0): kmem_cache#27-oX
		header = kzalloc(sizeof(*header) +
				 sizeof(*subheaders)*nr_subheaders, GFP_KERNEL);
		// header: kmem_cache#27-oX

		// header: kmem_cache#27-oX
		if (!header)
			goto out;

		// header: kmem_cache#27-oX
		subheaders = (struct ctl_table_header **) (header + 1);
		// subheaders: &(kmem_cache#27-oX)[1] (struct ctl_table_header)

		// subheaders: &(kmem_cache#27-oX)[1] (struct ctl_table_header)
		subheader = subheaders;
		// subheader: &(kmem_cache#27-oX)[1] (struct ctl_table_header)

		// header->ctl_table_arg: (kmem_cache#27-oX)->ctl_table_arg, ctl_table_arg: sysctl_base_table
		header->ctl_table_arg = ctl_table_arg;
		// header->ctl_table_arg: (kmem_cache#27-oX)->ctl_table_arg: sysctl_base_table

		// new_path: kmem_cache#23-oX, pos: kmem_cache#23-oX, subheader: &(kmem_cache#27-oX)[1] (struct ctl_table_header)
		// set: &sysctl_table_root.default_set, table: sysctl_base_table
		if (register_leaf_sysctl_tables(new_path, pos, &subheader,
						set, table))
```

## register_leaf_sysctl_tables()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kzalloc(): header: 256
 - register_lead_sysctl_table()

* call: register_leaf_sysctl_table()


## register_leaf_sysctl_tables()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()

* call: count_subheaders()
 - count_subheaders()
 - self_call (재귀적 함수)이다.

* return: __register_sysctl_paths()
 - count_subheaders()

## register_leaf_sysctl_tables()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()

* call: count_subheaders()
 - count_subheaders()
 - self_call (재귀적 함수)이다.

* return: __register_sysctl_paths()
 - count_subheaders()

## register_leaf_sysctl_tables()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()

* call: count_subheaders()
 - count_subheaders()
 - self_call (재귀적 함수)이다.

* return: __register_sysctl_paths()
 - count_subheaders()


## log

```
b16256d..dcd7815  master     -> origin/master
Merge made by the 'recursive' strategy.
drivers/char/random.c                 |   1 +
fs/proc/proc_sysctl.c                 | 210 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
include/linux/gfp.h                   |   1 +
include/linux/rbtree.h                |   1 +
include/linux/slab.h                  |   8 +++++
include/linux/sysctl.h                |   9 ++++++
include/linux/types.h                 |   1 +
include/uapi/asm-generic/errno-base.h |   1 +
include/uapi/asm-generic/errno.h      |   2 ++
include/uapi/linux/limits.h           |   1 +
kernel/kmod.c                         |   1 +
kernel/sysctl.c                       | 128 +++++++++++++++++++++++++++++++++++++++++---------------------------------------
12 files changed, 300 insertions(+), 64 deletions(-)
```

```
dcd7815..39125d4  master     -> origin/master
Merge made by the 'recursive' strategy.
arch/arm/boot/compressed/string.c     |   2 +
fs/proc/proc_sysctl.c                 | 444 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
include/linux/err.h                   |  14 +++++
include/linux/gfp.h                   |   1 +
include/linux/rbtree.h                |   4 ++
include/linux/slab.h                  |   2 +
include/linux/spinlock.h              |   4 ++
include/linux/spinlock_types.h        |  12 ++++
include/linux/stat.h                  |   3 +
include/linux/sysctl.h                |   7 +++
include/uapi/asm-generic/errno-base.h |   2 +
include/uapi/linux/stat.h             |   1 +
lib/rbtree.c                          |   3 +
lib/string.c                          |   2 +
14 files changed, 501 insertions(+)
```

```
39125d4..e06275f  master     -> origin/master
Merge made by the 'recursive' strategy.
fs/proc/proc_sysctl.c  | 274 ++++++++++++++++++++++++++++++++++++++++++-------
include/linux/rbtree.h |   7 ++
include/linux/sysctl.h |   3 +
lib/rbtree.c           |   8 ++
lib/string.c           |   2 +
```
	 
