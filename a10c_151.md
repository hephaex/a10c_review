##### Neuromancer : 151 주차 
##### 일시        : 2016.07.16 (151주차 스터디 진행)
##### 모임명      : neuromancer.kr
##### 장소        : 토즈 서현점
##### 장소지원    : 공개 소프트웨어 개발자 커뮤니티 지원 프로그램
##### 참여인원    : 2명
============

## 151주차 진도

* ᇂ151차 시작 위치
  - start_kernel        1  ~/init/main.c
  - proc_root_init    937  ~/init/main.c
  - proc_sys_init     609  ~/fs/proc/root.c
  - sysctl_init      2488  return sysctl_init();
  - register_sysctl_table  1696  ~/kernel/sysctl.c
  - register_sysctl_paths  2330  return register_sysctl_paths(null_path, table);
  - __register_sysctl_paths  2309  return __register_sysctl_paths(&sysctl_table_root.default_set,
  - register_leaf_sysctl_tables  2272  if (register_leaf_sysctl_tables(new_path, pos, &subheader,
  - __register_sysctl_table  2121  header = __register_sysctl_table(set, path, files);
  - insert_header    1885  if (insert_header(dir, header))

#### 151 주차 함수 호출 구조

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_leaf_sysctl_table()

* call: register_leaf_sysctl_table()
 - __register_sysctl_table()

* call: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()

* call: insert_keader()
 - insert_links()
 - insert_entry()

* return: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()
 - drop_sysctl_table()

* call: drop_sysctl_table()

## start_kernel()

* call: start_kernel()
 - proc_root_init()

```main.c
asmlinkage void __init start_kernel(void)
{
	char * command_line;
	extern const struct kernel_param __start___param[], __stop___param[];
	// ATAG,DTB 정보로 사용

...

    proc_caches_init();
	// sighand_struct, signal_struct, files_struct, fs_struct, mm_struct, vm_area_struct, nsproxy
	// 를 사용하기 위한 kmem_cache 할당자 및 percpu list 초기화 수행

...

	vfs_caches_init(totalram_pages);
	// virtual file system을 위한 names, dentry, inode, filp, mount cache 생성 후
	// file system 을 위한 초기화 수행 및 mount 수행, block, char dev 사용을 위한 초기화 수행

	signals_init();
	// signal을 사용하기 위한 kmem_cache 를 생성

	/* rootfs populating might need page-writeback */
	page_writeback_init();
	// page writeback을 위한 global_dirty_limit, ratelimit_pages 값을 초기화 수행

#ifdef CONFIG_PROC_FS // CONFIG_PROC_FS=y
	proc_root_init();
```

## proc_root_init()

* calll: start_kernel()
 - proc_root_init()

* call: call_root_init()

```root.c
// ARM10C 20160604
void __init proc_root_init(void)
{
	int err;

	proc_init_inodecache();

	// proc_init_inodecache 에서 한일:
	// struct proc_inode 크기 만큼의 메모리를 할당항는 kmem_cache 할당자를 생성함
	// proc_inode_cachep: kmem_cache#n#28 (struct proc_inode)

	// register_filesystem(&proc_fs_type): 0
	err = register_filesystem(&proc_fs_type);
	// err: 0

	// register_filesystem에서 한일:
	// (&bd_type)->next: &proc_fs_type
	//
	// file system 연결 결과
	// file_systems: sysfs_fs_type -> rootfs_fs_type -> shmem_fs_type -> bd_type -> proc_fs_type

	// err: 0
	if (err)
		return;

	proc_self_init();

	// proc_self_init 에서 한일:
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 2 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 1번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 1         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 1)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 1 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 2
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 1) 의 memory 공간을 반환함
	//
	// self_inum: 0xF0000001

	// proc_symlink("mounts", NULL, "self/mounts"): kmem_cache#29-oX (struct proc_dir_entry)
	proc_symlink("mounts", NULL, "self/mounts");

	// proc_symlink 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "mounts"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 6
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0120777
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: kmem_cache#30-oX: "self/mounts"
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 2번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 2         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 2)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 2 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 3
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 2) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000002
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_link_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)

	// proc_net_init(): 0
	proc_net_init();

	// proc_net_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "net"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0120777
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: kmem_cache#30-oX: "self/net"
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 3번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 3         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 3)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 3 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 4
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 3) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000003
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_link_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)
	//
	// list head 인 &pernet_list 에 &(&proc_net_ns_ops)->list 을 tail로 추가함

#ifdef CONFIG_SYSVIPC // CONFIG_SYSVIPC=y
	// proc_mkdir("sysvipc", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("sysvipc", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "sysvipc"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 7
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
#endif
	// proc_mkdir("fs", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("fs", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "fs"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 2
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_mkdir("driver", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("driver", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "driver"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 6
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_mkdir("fs/nfsd", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("fs/nfsd", NULL); /* somewhere for the nfsd filesystem to be mounted */

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "fs/nfsd"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 7
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE) // CONFIG_SUN_OPENPROMFS=n, CONFIG_SUN_OPENPROMFS_MODULE=n
	/* just give it a mountpoint */
	proc_mkdir("openprom", NULL);
#endif
	proc_tty_init();

	// proc_tty_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/ldisc"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 9
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/driver"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 10
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 00500
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/ldiscs"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 10
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0100444
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &tty_ldiscs_proc_fops
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: NULL
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 4번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 4         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 4)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 4 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 5
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 4) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000004
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_file_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/drivers"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 11
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0100444
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &proc_tty_drivers_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: NULL
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 5번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 5         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 5)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 5 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 6
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 5) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000005
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_file_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)

#ifdef CONFIG_PROC_DEVICETREE // CONFIG_PROC_DEVICETREE=y
	proc_device_tree_init();

	// proc_device_tree_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "device-tree"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 11
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// unflatten_device_tree 에서 만든 tree의 root node 의 값을 사용하여proc device tree를 만드는 작업을 수행
#endif
	proc_mkdir("bus", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "bus"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	proc_sys_init();
```

## proc_sys_init()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()

* call: proc_sys_init()

```proc_sysctl.c
// ARM10C 20160611
int __init proc_sys_init(void)
{
	struct proc_dir_entry *proc_sys_root;

	// proc_mkdir("sys", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_sys_root = proc_mkdir("sys", NULL);
	// proc_sys_root: kmem_cache#29-oX (struct proc_dir_entry)

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "sys"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_sys_root->proc_iops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops
	proc_sys_root->proc_iops = &proc_sys_dir_operations;
	// proc_sys_root->proc_iops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_sys_dir_operations

	// proc_sys_root->proc_fops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops
	proc_sys_root->proc_fops = &proc_sys_dir_file_operations;
	// proc_sys_root->proc_fops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &proc_sys_dir_file_operations

	// proc_sys_root->nlink: (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	proc_sys_root->nlink = 0;
	// proc_sys_root->nlink: (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 0

	return sysctl_init();
}
```

## sysctl_init()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()

```sysctl.c
// ARM10C 20160611
int __init sysctl_init(void)
{
	struct ctl_table_header *hdr;

	hdr = register_sysctl_table(sysctl_base_table);
```

## register_sysctl_table()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()

```proc_sysctl.c
// ARM10C 20160611
// sysctl_base_table
struct ctl_table_header *register_sysctl_table(struct ctl_table *table)
{
	static const struct ctl_path null_path[] = { {} };

	// table: sysctl_base_table
	return register_sysctl_paths(null_path, table);
}
EXPORT_SYMBOL(register_sysctl_table);
```

## register_sysctl_paths()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()

```proc_sysctl.c
// ARM10C 20160611
// null_path, table: sysctl_base_table
struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,
						struct ctl_table *table)
{
	// path: null_path, table: sysctl_base_table
	return __register_sysctl_paths(&sysctl_table_root.default_set,
					path, table);
}
EXPORT_SYMBOL(register_sysctl_paths);
```

## __register_sysctl_paths()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()

```proc_sysctl.c
// ARM10C 20160611
// &sysctl_table_root.default_set, path: null_path, table: sysctl_base_table
struct ctl_table_header *__register_sysctl_paths(
	struct ctl_table_set *set,
	const struct ctl_path *path, struct ctl_table *table)
{
	// table: sysctl_base_table
	struct ctl_table *ctl_table_arg = table;
	// ctl_table_arg: sysctl_base_table

	// table: sysctl_base_table
	int nr_subheaders = count_subheaders(table);
```

## count_subheaders()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_leaf_sysctl_table()

* call: register_leaf_sysctl_table()
 - __register_sysctl_tables()

```
// ARM10C 20160625
// [rc1] set: &sysctl_table_root.default_set, path: kmem_cache#23-oX, files: kmem_cache#24-oX
struct ctl_table_header *__register_sysctl_table(
	struct ctl_table_set *set,
	const char *path, struct ctl_table *table)
{
	// set->dir.header.root: (&sysctl_table_root.default_set)->dir.header.root: &sysctl_table_root
	struct ctl_table_root *root = set->dir.header.root;
	// root: &sysctl_table_root

	struct ctl_table_header *header;
	const char *name, *nextname;
	struct ctl_dir *dir;
	struct ctl_table *entry;
	struct ctl_node *node;
	int nr_entries = 0;
	// nr_entries: 0

	// table: kmem_cache#24-oX, entry: kmem_cache#24-oX, entry->procname: (kmem_cache#24-oX)->procname: "sched_child_runs_first"
	for (entry = table; entry->procname; entry++)
		// nr_entries: 0
		nr_entries++;
		// nr_entries: 1

		// kern_table 의 child 없는 index 만큼 loop 수행

	// 위 loop 의 수행결과:
	// nr_entries: 46

	// sizeof(struct ctl_table_header): 32 bytes, sizeof(struct ctl_node): 16 bytes, nr_entries: 46, GFP_KERNEL: 0xD0
	// kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
	header = kzalloc(sizeof(struct ctl_table_header) +
			 sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);
	// header: kmem_cache#25-oX

	// header: kmem_cache#25-oX
	if (!header)
		return NULL;

	// header: kmem_cache#25-oX
	node = (struct ctl_node *)(header + 1);
	// node: &(kmem_cache#25-oX)[1] (struct ctl_node)

// 2016/06/25 종료
// 2016/07/02 시작

	// header: kmem_cache#25-oX, root: &sysctl_table_root, set: &sysctl_table_root.default_set,
	// node: &(kmem_cache#25-oX)[1] (struct ctl_node), table: kmem_cache#24-oX
	init_header(header, root, set, node, table);

	// init_header 에서 한일:
	// (kmem_cache#25-oX)->ctl_table: kmem_cache#24-oX
	// (kmem_cache#25-oX)->ctl_table_arg: kmem_cache#24-oX
	// (kmem_cache#25-oX)->used: 0
	// (kmem_cache#25-oX)->count: 1
	// (kmem_cache#25-oX)->nreg: 1
	// (kmem_cache#25-oX)->unregistering: NULL
	// (kmem_cache#25-oX)->root: &sysctl_table_root
	// (kmem_cache#25-oX)->set: &sysctl_table_root.default_set
	// (kmem_cache#25-oX)->parent: NULL
	// (kmem_cache#25-oX)->node: &(kmem_cache#25-oX)[1] (struct ctl_node)
	// (&(kmem_cache#25-oX)[1...46] (struct ctl_node))->header: kmem_cache#25-oX

	// path: kmem_cache#23-oX, table: kmem_cache#24-oX
	// sysctl_check_table(kmem_cache#23-oX, kmem_cache#24-oX): 0
	if (sysctl_check_table(path, table))
		goto fail;

	// sysctl_check_table 에서 한일:
	// table: kmem_cache#24-oX (kern_table) 의 child 없는 맴버 46개 만큼 loop를 수행하면서 
	// kern_table 의 맴버값을 체크함

	spin_lock(&sysctl_lock);

	// spin_lock에서 한일:
	// &sysctl_lock을 이용한 spin lock 수행

	// &set->dir: &(&sysctl_table_root.default_set)->dir
	dir = &set->dir;
	// dir: &(&sysctl_table_root.default_set)->dir

	/* Reference moved down the diretory tree get_subdir */
	// dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
	dir->header.nreg++;
	// dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2

	spin_unlock(&sysctl_lock);

	// spin_unlock에서 한일:
	// &sysctl_lock을 이용한 spin unlock 수행

	/* Find the directory for the ctl_table */
	// [f1] path: kmem_cache#23-oX: "kernel/", name: kmem_cache#23-oX: "kernel/"
	for (name = path; name; name = nextname) {
		int namelen;

		// [f2] name: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값+1: NULL

		// [f1] name: kmem_cache#23-oX: "kernel/"
		// [f1] strchr(kmem_cache#23-oX, '/'): kmem_cache#23-oX 의 '/' 위치의 주소값
		nextname = strchr(name, '/');
		// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값

		// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값
		if (nextname) {
			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값,
			// [f1] name: kmem_cache#23-oX: "kernel/"
			namelen = nextname - name;
			// [f1] namelen: 6

			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값
			nextname++;
			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값+1
		} else {
			namelen = strlen(name);
		}

		// [f1] namelen: 6
		if (namelen == 0)
			continue;

		// [f1] dir: &(&sysctl_table_root.default_set)->dir, name: kmem_cache#23-oX: "kernel/", namelen: 6
		// [f1] get_subdir(&(&sysctl_table_root.default_set)->dir, "kernel/", 6): kmem_cache#29-oX
		dir = get_subdir(dir, name, namelen);
		// [f1] dir: kmem_cache#29-oX

		// [f1] get_subdir 에서 한일:
		// struct ctl_dir: 36, struct ctl_node: 16, struct ctl_table: 34 * 2, char: 7
		// 만큼의 메모리 kmem_cache#29-oX 를 할당 받음
		//
		// (kmem_cache#29-oX + 120): "kernel"
		// ((kmem_cache#29-oX + 52)[0] (struct ctl_table)).procname: (kmem_cache#29-oX + 120): "kernel"
		// ((kmem_cache#29-oX + 52)[0] (struct ctl_table)).mode: 0040555
		// (&(kmem_cache#29-oX)->header)->ctl_table: (kmem_cache#29-oX + 52) (struct ctl_table)
		// (&(kmem_cache#29-oX)->header)->ctl_table_arg: (kmem_cache#29-oX + 52) (struct ctl_table)
		// (&(kmem_cache#29-oX)->header)->used: 0
		// (&(kmem_cache#29-oX)->header)->count: 1
		// (&(kmem_cache#29-oX)->header)->nreg: 1
		// (&(kmem_cache#29-oX)->header)->unregistering: NULL
		// (&(kmem_cache#29-oX)->header)->root: (&sysctl_table_root.default_set)->dir.header.root
		// (&(kmem_cache#29-oX)->header)->set: &sysctl_table_root.default_set
		// (&(kmem_cache#29-oX)->header)->parent: NULL
		// (&(kmem_cache#29-oX)->header)->node: (kmem_cache#29-oX + 36) (struct ctl_node)
		// ((kmem_cache#29-oX + 36) (struct ctl_node))->header: &(kmem_cache#29-oX)->header
		//
		// (&(&sysctl_table_root.default_set)->dir)->header.nreg: 3
		// (&(kmem_cache#29-oX)->header)->parent: &(&sysctl_table_root.default_set)->dir
		//
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node).__rb_parent_color: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_left: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_right: NULL
		// (&(&sysctl_table_root.default_set)->dir)->root.rb_node: &((kmem_cache#29-oX + 36) (struct ctl_node)).node
		//
		// RB Tree &((kmem_cache#29-oX + 36) (struct ctl_node)).node 을 black node 로 추가
		/*
		//                          proc-b
		//                         (kernel)
		*/
		// (&(&(&sysctl_table_root.default_set)->dir)->header)->nreg: 2
		// (&(kmem_cache#29-oX)->header)->nreg: 1

		// [f1] dir: kmem_cache#29-oX, IS_ERR(kmem_cache#29-oX): 0
		if (IS_ERR(dir))
			goto fail;

// 2016/07/02 종료
// 2016/07/09 시작

	}

	spin_lock(&sysctl_lock);

	// spin_unlock에서 한일:
	// &sysctl_lock을 이용한 spin unlock 수행

	// dir: kmem_cache#29-oX, header: kmem_cache#25-oX
	if (insert_header(dir, header))
		goto fail_put_dir_locked;
```

## insert_header()

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_leaf_sysctl_table()

* call: register_leaf_sysctl_table()
 - __register_sysctl_table()

* call: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()

* call: insert_keader()
 - insert_links()
 - insert_entry()

```
// ARM10C 20160709
// [2nd] dir: kmem_cache#29-oX, header: kmem_cache#25-oX
static int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)
{
	struct ctl_table *entry;
	int err;

	// [1st] dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
	// [2nd] dir->header.nreg: (kmem_cache#29-oX)->header.nreg: 1
	dir->header.nreg++;
	// [1st] dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 3
	// [2nd] dir->header.nreg: (kmem_cache#29-oX)->header.nreg: 2

	// [1st] header->parent: (&(kmem_cache#29-oX)->header)->parent: NULL,
	// [1st] dir: &(&sysctl_table_root.default_set)->dir
	// [2nd] header->parent: (kmem_cache#25-oX)->parent: NULL, dir: kmem_cache#29-oX
	header->parent = dir;
	// [1st] header->parent: (&(kmem_cache#29-oX)->header)->parent: &(&sysctl_table_root.default_set)->dir
	// [2nd] header->parent: (kmem_cache#25-oX)->parent: kmem_cache#29-oX

	// [1st] header: &(kmem_cache#29-oX)->header, insert_links(&(kmem_cache#29-oX)->header): 0
	// [2nd] header: kmem_cache#25-oX, insert_links(kmem_cache#25-oX): 0
	err = insert_links(header);
	// [1st] err: 0
	// [2nd] err: 0

	// [1st] err: 0
	// [2nd] err: 0
	if (err)
		goto fail_links;

	// [2nd] NOTE:
	// struct ctl_table 의 46 개 크기만큼 할당 받은 메모리 kmem_cache#24-oX 에
	// kern_table의 child 멤버 값이 NULL 인 index 의 table 값을 복사한 값

	// [1st][f1] header->ctl_table: (&(kmem_cache#29-oX)->header)->ctl_table: (kmem_cache#29-oX + 52) (struct ctl_table),
	// [1st][f1] entry: (kmem_cache#29-oX + 52) (struct ctl_table), ((kmem_cache#29-oX + 52) (struct ctl_table))->procname: "kernel"
	//
	// [2nd][f1] header->ctl_table: (kmem_cache#25-oX)->ctl_table: kmem_cache#24-oX
	// [2nd][f1] entry: kmem_cache#24-oX (struct ctl_table), (kmem_cache#24-oX (struct ctl_table))->procname: "sched_child_runs_first"
	for (entry = header->ctl_table; entry->procname; entry++) {
		// [1st][f2] entry: ((kmem_cache#29-oX + 52) (struct ctl_table))[1]
		// [1st][f2] entry->procname: (((kmem_cache#29-oX + 52) (struct ctl_table))[1]).procname: NULL

		// [2nd][f2] entry: (kmem_cache#24-oX (struct ctl_table))[1]
		// [2nd][f2] entry->procname: ((kmem_cache#24-oX (struct ctl_table))[1]).procname: "sched_min_granularity_ns"

		// [1st][f1] header: &(kmem_cache#29-oX)->header, entry: (kmem_cache#29-oX + 52) (struct ctl_table)
		// [1st][f1] insert_entry(&(kmem_cache#29-oX)->header, (kmem_cache#29-oX + 52) (struct ctl_table)): 0
		// [2nd][f1] header: kmem_cache#25-oX, entry: kmem_cache#24-oX (struct ctl_table)
		// [2nd][f1] insert_entry(kmem_cache#25-oX, kmem_cache#24-oX (struct ctl_table)): 0
		// [2nd][f2] header: kmem_cache#25-oX, entry: (kmem_cache#24-oX (struct ctl_table))[1]
		// [2nd][f2] insert_entry(kmem_cache#25-oX, kmem_cache#24-oX (struct ctl_table)): 0
		err = insert_entry(header, entry);
		// [1st][f1] err: 0
		// [2nd][f1] err: 0
		// [2nd][f2] err: 0

		// [1st][f1] insert_entry 에서 한일:
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node).__rb_parent_color: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_left: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_right: NULL
		// (&(&sysctl_table_root.default_set)->dir)->root.rb_node: &((kmem_cache#29-oX + 36) (struct ctl_node)).node
		//
		// &((kmem_cache#29-oX + 36) (struct ctl_node)).node 을 black node 로 추가
		// (proc의 kernel directory)
		/*
		//                          proc-b
		//                         (kernel)
		*/

		// [2nd][f1] insert_entry 에서 한일:
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node)).node).__rb_parent_color: NULL
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node)).node)->rb_left: NULL
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node)).node)->rb_right: NULL
		// &(kmem_cache#29-oX)->root.rb_node: &(&(kmem_cache#25-oX)[1] (struct ctl_node)).node
		//
		// &(&(kmem_cache#25-oX)[1] (struct ctl_node)).node 을 black node 로 추가
		// (kern_table 의 1 번째 index의 값)
		/*
		//                       kern_table-b
		//                 (sched_child_runs_first)
		*/

		// [2nd][f2] insert_entry 에서 한일:
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node) + 1).node).__rb_parent_color: &(&(kmem_cache#25-oX)[1] (struct ctl_node)).node
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node) + 1).node)->rb_left: NULL
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node) + 1).node)->rb_right: NULL
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node)).node)->rb_right: &(&(kmem_cache#25-oX)[1] (struct ctl_node) + 1).node
		//
		// &(&(kmem_cache#25-oX)[1] (struct ctl_node) + 1).node 을 node 로 추가 후 rbtree 로 구성
		// (kern_table 의 2 번째 index의 값)
		/*
		//                       kern_table-b
		//                 (sched_child_runs_first)
		//                                      \
		//                                        kern_table-r
		//                                  (sched_min_granularity_ns)
		//
		*/

		// [1st][f1] err: 0
		// [2nd][f1] err: 0
		// [2nd][f2] err: 0
		if (err)
			goto fail;

		// [2nd][f2] 위의 loop를 kern_table 의 index 수만큼 수행 (46개)
	}

	// [2nd] 위의 loop 수행 결과
	// TODO: kern_table 의 rbtree 그림을 그려야함

// 2016/07/09 종료

	return 0;
	// [1st] return 0
	// [2nd] return 0
fail:
	erase_header(header);
	put_links(header);
fail_links:
	header->parent = NULL;
	drop_sysctl_table(&dir->header);
	return err;
}
```

## __register_sysctl_table()

## insert_header()

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_leaf_sysctl_table()

* call: register_leaf_sysctl_table()
 - __register_sysctl_table()

* call: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()

* call: insert_keader()
 - insert_links()
 - insert_entry()

* return: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()
 - drop_sysctl_table()

```
// ARM10C 20160625
// [rc1] set: &sysctl_table_root.default_set, path: kmem_cache#23-oX, files: kmem_cache#24-oX
struct ctl_table_header *__register_sysctl_table(
	struct ctl_table_set *set,
	const char *path, struct ctl_table *table)
{
	// set->dir.header.root: (&sysctl_table_root.default_set)->dir.header.root: &sysctl_table_root
	struct ctl_table_root *root = set->dir.header.root;
	// root: &sysctl_table_root

	struct ctl_table_header *header;
	const char *name, *nextname;
	struct ctl_dir *dir;
	struct ctl_table *entry;
	struct ctl_node *node;
	int nr_entries = 0;
	// nr_entries: 0

	// table: kmem_cache#24-oX, entry: kmem_cache#24-oX, entry->procname: (kmem_cache#24-oX)->procname: "sched_child_runs_first"
	for (entry = table; entry->procname; entry++)
		// nr_entries: 0
		nr_entries++;
		// nr_entries: 1

		// kern_table 의 child 없는 index 만큼 loop 수행

	// 위 loop 의 수행결과:
	// nr_entries: 46

	// sizeof(struct ctl_table_header): 32 bytes, sizeof(struct ctl_node): 16 bytes, nr_entries: 46, GFP_KERNEL: 0xD0
	// kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
	header = kzalloc(sizeof(struct ctl_table_header) +
			 sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);
	// header: kmem_cache#25-oX

	// header: kmem_cache#25-oX
	if (!header)
		return NULL;

	// header: kmem_cache#25-oX
	node = (struct ctl_node *)(header + 1);
	// node: &(kmem_cache#25-oX)[1] (struct ctl_node)

// 2016/06/25 종료
// 2016/07/02 시작

	// header: kmem_cache#25-oX, root: &sysctl_table_root, set: &sysctl_table_root.default_set,
	// node: &(kmem_cache#25-oX)[1] (struct ctl_node), table: kmem_cache#24-oX
	init_header(header, root, set, node, table);

	// init_header 에서 한일:
	// (kmem_cache#25-oX)->ctl_table: kmem_cache#24-oX
	// (kmem_cache#25-oX)->ctl_table_arg: kmem_cache#24-oX
	// (kmem_cache#25-oX)->used: 0
	// (kmem_cache#25-oX)->count: 1
	// (kmem_cache#25-oX)->nreg: 1
	// (kmem_cache#25-oX)->unregistering: NULL
	// (kmem_cache#25-oX)->root: &sysctl_table_root
	// (kmem_cache#25-oX)->set: &sysctl_table_root.default_set
	// (kmem_cache#25-oX)->parent: NULL
	// (kmem_cache#25-oX)->node: &(kmem_cache#25-oX)[1] (struct ctl_node)
	// (&(kmem_cache#25-oX)[1...46] (struct ctl_node))->header: kmem_cache#25-oX

	// path: kmem_cache#23-oX, table: kmem_cache#24-oX
	// sysctl_check_table(kmem_cache#23-oX, kmem_cache#24-oX): 0
	if (sysctl_check_table(path, table))
		goto fail;

	// sysctl_check_table 에서 한일:
	// table: kmem_cache#24-oX (kern_table) 의 child 없는 맴버 46개 만큼 loop를 수행하면서 
	// kern_table 의 맴버값을 체크함

	spin_lock(&sysctl_lock);

	// spin_lock에서 한일:
	// &sysctl_lock을 이용한 spin lock 수행

	// &set->dir: &(&sysctl_table_root.default_set)->dir
	dir = &set->dir;
	// dir: &(&sysctl_table_root.default_set)->dir

	/* Reference moved down the diretory tree get_subdir */
	// dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
	dir->header.nreg++;
	// dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2

	spin_unlock(&sysctl_lock);

	// spin_unlock에서 한일:
	// &sysctl_lock을 이용한 spin unlock 수행

	/* Find the directory for the ctl_table */
	// [f1] path: kmem_cache#23-oX: "kernel/", name: kmem_cache#23-oX: "kernel/"
	for (name = path; name; name = nextname) {
		int namelen;

		// [f2] name: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값+1: NULL

		// [f1] name: kmem_cache#23-oX: "kernel/"
		// [f1] strchr(kmem_cache#23-oX, '/'): kmem_cache#23-oX 의 '/' 위치의 주소값
		nextname = strchr(name, '/');
		// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값

		// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값
		if (nextname) {
			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값,
			// [f1] name: kmem_cache#23-oX: "kernel/"
			namelen = nextname - name;
			// [f1] namelen: 6

			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값
			nextname++;
			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값+1
		} else {
			namelen = strlen(name);
		}

		// [f1] namelen: 6
		if (namelen == 0)
			continue;

		// [f1] dir: &(&sysctl_table_root.default_set)->dir, name: kmem_cache#23-oX: "kernel/", namelen: 6
		// [f1] get_subdir(&(&sysctl_table_root.default_set)->dir, "kernel/", 6): kmem_cache#29-oX
		dir = get_subdir(dir, name, namelen);
		// [f1] dir: kmem_cache#29-oX

		// [f1] get_subdir 에서 한일:
		// struct ctl_dir: 36, struct ctl_node: 16, struct ctl_table: 34 * 2, char: 7
		// 만큼의 메모리 kmem_cache#29-oX 를 할당 받음
		//
		// (kmem_cache#29-oX + 120): "kernel"
		// ((kmem_cache#29-oX + 52)[0] (struct ctl_table)).procname: (kmem_cache#29-oX + 120): "kernel"
		// ((kmem_cache#29-oX + 52)[0] (struct ctl_table)).mode: 0040555
		// (&(kmem_cache#29-oX)->header)->ctl_table: (kmem_cache#29-oX + 52) (struct ctl_table)
		// (&(kmem_cache#29-oX)->header)->ctl_table_arg: (kmem_cache#29-oX + 52) (struct ctl_table)
		// (&(kmem_cache#29-oX)->header)->used: 0
		// (&(kmem_cache#29-oX)->header)->count: 1
		// (&(kmem_cache#29-oX)->header)->nreg: 1
		// (&(kmem_cache#29-oX)->header)->unregistering: NULL
		// (&(kmem_cache#29-oX)->header)->root: (&sysctl_table_root.default_set)->dir.header.root
		// (&(kmem_cache#29-oX)->header)->set: &sysctl_table_root.default_set
		// (&(kmem_cache#29-oX)->header)->parent: NULL
		// (&(kmem_cache#29-oX)->header)->node: (kmem_cache#29-oX + 36) (struct ctl_node)
		// ((kmem_cache#29-oX + 36) (struct ctl_node))->header: &(kmem_cache#29-oX)->header
		//
		// (&(&sysctl_table_root.default_set)->dir)->header.nreg: 3
		// (&(kmem_cache#29-oX)->header)->parent: &(&sysctl_table_root.default_set)->dir
		//
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node).__rb_parent_color: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_left: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_right: NULL
		// (&(&sysctl_table_root.default_set)->dir)->root.rb_node: &((kmem_cache#29-oX + 36) (struct ctl_node)).node
		//
		// RB Tree &((kmem_cache#29-oX + 36) (struct ctl_node)).node 을 black node 로 추가
		/*
		//                          proc-b
		//                         (kernel)
		*/
		// (&(&(&sysctl_table_root.default_set)->dir)->header)->nreg: 2
		// (&(kmem_cache#29-oX)->header)->nreg: 1

		// [f1] dir: kmem_cache#29-oX, IS_ERR(kmem_cache#29-oX): 0
		if (IS_ERR(dir))
			goto fail;

// 2016/07/02 종료
// 2016/07/09 시작

	}

	spin_lock(&sysctl_lock);

	// spin_unlock에서 한일:
	// &sysctl_lock을 이용한 spin unlock 수행

	// dir: kmem_cache#29-oX, header: kmem_cache#25-oX
	if (insert_header(dir, header))
		goto fail_put_dir_locked;

	drop_sysctl_table(&dir->header);
	spin_unlock(&sysctl_lock);

	return header;

fail_put_dir_locked:
	drop_sysctl_table(&dir->header);
	spin_unlock(&sysctl_lock);
fail:
	kfree(header);
	dump_stack();
	return NULL;
}
```

