##### Neuromancer : 151 주차 
##### 일시        : 2016.07.16 (151주차 스터디 진행)
##### 모임명      : neuromancer.kr
##### 장소        : 토즈 서현점
##### 장소지원    : 공개 소프트웨어 개발자 커뮤니티 지원 프로그램
##### 참여인원    : 2명
============

## 151주차 진도

* ᇂ151차 시작 위치
  - start_kernel        1  ~/init/main.c
  - proc_root_init    937  ~/init/main.c
  - proc_sys_init     609  ~/fs/proc/root.c
  - sysctl_init      2488  return sysctl_init();
  - register_sysctl_table  1696  ~/kernel/sysctl.c
  - register_sysctl_paths  2330  return register_sysctl_paths(null_path, table);
  - __register_sysctl_paths  2309  return __register_sysctl_paths(&sysctl_table_root.default_set,
  - register_leaf_sysctl_tables  2272  if (register_leaf_sysctl_tables(new_path, pos, &subheader,
  - __register_sysctl_table  2121  header = __register_sysctl_table(set, path, files);
  - insert_header    1885  if (insert_header(dir, header))

#### 151 주차 함수 호출 구조

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_leaf_sysctl_table()

* call: register_leaf_sysctl_table()
 - __register_sysctl_table()

* call: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()

* call: insert_keader()
 - insert_links()
 - insert_entry()

* return: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()
 - drop_sysctl_table()

* call: drop_sysctl_table()

## start_kernel()

* call: start_kernel()
 - proc_root_init()

```main.c
asmlinkage void __init start_kernel(void)
{
	char * command_line;
	extern const struct kernel_param __start___param[], __stop___param[];
	// ATAG,DTB 정보로 사용

...

    proc_caches_init();
	// sighand_struct, signal_struct, files_struct, fs_struct, mm_struct, vm_area_struct, nsproxy
	// 를 사용하기 위한 kmem_cache 할당자 및 percpu list 초기화 수행

...

	vfs_caches_init(totalram_pages);
	// virtual file system을 위한 names, dentry, inode, filp, mount cache 생성 후
	// file system 을 위한 초기화 수행 및 mount 수행, block, char dev 사용을 위한 초기화 수행

	signals_init();
	// signal을 사용하기 위한 kmem_cache 를 생성

	/* rootfs populating might need page-writeback */
	page_writeback_init();
	// page writeback을 위한 global_dirty_limit, ratelimit_pages 값을 초기화 수행

#ifdef CONFIG_PROC_FS // CONFIG_PROC_FS=y
	proc_root_init();
```

## proc_root_init()

* calll: start_kernel()
 - proc_root_init()

* call: call_root_init()

```root.c
// ARM10C 20160604
void __init proc_root_init(void)
{
	int err;

	proc_init_inodecache();

	// proc_init_inodecache 에서 한일:
	// struct proc_inode 크기 만큼의 메모리를 할당항는 kmem_cache 할당자를 생성함
	// proc_inode_cachep: kmem_cache#n#28 (struct proc_inode)

	// register_filesystem(&proc_fs_type): 0
	err = register_filesystem(&proc_fs_type);
	// err: 0

	// register_filesystem에서 한일:
	// (&bd_type)->next: &proc_fs_type
	//
	// file system 연결 결과
	// file_systems: sysfs_fs_type -> rootfs_fs_type -> shmem_fs_type -> bd_type -> proc_fs_type

	// err: 0
	if (err)
		return;

	proc_self_init();

	// proc_self_init 에서 한일:
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 2 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 1번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 1         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 1)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 1 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 2
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 1) 의 memory 공간을 반환함
	//
	// self_inum: 0xF0000001

	// proc_symlink("mounts", NULL, "self/mounts"): kmem_cache#29-oX (struct proc_dir_entry)
	proc_symlink("mounts", NULL, "self/mounts");

	// proc_symlink 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "mounts"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 6
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0120777
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: kmem_cache#30-oX: "self/mounts"
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 2번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 2         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 2)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 2 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 3
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 2) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000002
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_link_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)

	// proc_net_init(): 0
	proc_net_init();

	// proc_net_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "net"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0120777
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: kmem_cache#30-oX: "self/net"
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 3번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 3         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 3)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 3 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 4
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 3) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000003
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_link_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)
	//
	// list head 인 &pernet_list 에 &(&proc_net_ns_ops)->list 을 tail로 추가함

#ifdef CONFIG_SYSVIPC // CONFIG_SYSVIPC=y
	// proc_mkdir("sysvipc", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("sysvipc", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "sysvipc"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 7
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
#endif
	// proc_mkdir("fs", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("fs", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "fs"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 2
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_mkdir("driver", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("driver", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "driver"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 6
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_mkdir("fs/nfsd", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("fs/nfsd", NULL); /* somewhere for the nfsd filesystem to be mounted */

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "fs/nfsd"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 7
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE) // CONFIG_SUN_OPENPROMFS=n, CONFIG_SUN_OPENPROMFS_MODULE=n
	/* just give it a mountpoint */
	proc_mkdir("openprom", NULL);
#endif
	proc_tty_init();

	// proc_tty_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/ldisc"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 9
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/driver"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 10
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 00500
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/ldiscs"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 10
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0100444
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &tty_ldiscs_proc_fops
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: NULL
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 4번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 4         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 4)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 4 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 5
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 4) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000004
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_file_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/drivers"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 11
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0100444
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &proc_tty_drivers_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: NULL
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 5번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 5         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 5)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 5 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 6
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 5) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000005
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_file_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)

#ifdef CONFIG_PROC_DEVICETREE // CONFIG_PROC_DEVICETREE=y
	proc_device_tree_init();

	// proc_device_tree_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "device-tree"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 11
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// unflatten_device_tree 에서 만든 tree의 root node 의 값을 사용하여proc device tree를 만드는 작업을 수행
#endif
	proc_mkdir("bus", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "bus"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	proc_sys_init();
```

## proc_sys_init()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()

* call: proc_sys_init()

```proc_sysctl.c
// ARM10C 20160611
int __init proc_sys_init(void)
{
	struct proc_dir_entry *proc_sys_root;

	// proc_mkdir("sys", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_sys_root = proc_mkdir("sys", NULL);
	// proc_sys_root: kmem_cache#29-oX (struct proc_dir_entry)

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "sys"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_sys_root->proc_iops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops
	proc_sys_root->proc_iops = &proc_sys_dir_operations;
	// proc_sys_root->proc_iops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_sys_dir_operations

	// proc_sys_root->proc_fops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops
	proc_sys_root->proc_fops = &proc_sys_dir_file_operations;
	// proc_sys_root->proc_fops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &proc_sys_dir_file_operations

	// proc_sys_root->nlink: (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	proc_sys_root->nlink = 0;
	// proc_sys_root->nlink: (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 0

	return sysctl_init();
}
```

## sysctl_init()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()

```sysctl.c
// ARM10C 20160611
int __init sysctl_init(void)
{
	struct ctl_table_header *hdr;

	hdr = register_sysctl_table(sysctl_base_table);
```

## register_sysctl_table()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()

```proc_sysctl.c
// ARM10C 20160611
// sysctl_base_table
struct ctl_table_header *register_sysctl_table(struct ctl_table *table)
{
	static const struct ctl_path null_path[] = { {} };

	// table: sysctl_base_table
	return register_sysctl_paths(null_path, table);
}
EXPORT_SYMBOL(register_sysctl_table);
```

## register_sysctl_paths()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()

```proc_sysctl.c
// ARM10C 20160611
// null_path, table: sysctl_base_table
struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,
						struct ctl_table *table)
{
	// path: null_path, table: sysctl_base_table
	return __register_sysctl_paths(&sysctl_table_root.default_set,
					path, table);
}
EXPORT_SYMBOL(register_sysctl_paths);
```

## __register_sysctl_paths()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()

```proc_sysctl.c
// ARM10C 20160611
// &sysctl_table_root.default_set, path: null_path, table: sysctl_base_table
struct ctl_table_header *__register_sysctl_paths(
	struct ctl_table_set *set,
	const struct ctl_path *path, struct ctl_table *table)
{
	// table: sysctl_base_table
	struct ctl_table *ctl_table_arg = table;
	// ctl_table_arg: sysctl_base_table

	// table: sysctl_base_table
	int nr_subheaders = count_subheaders(table);
```

## count_subheaders()

* calll: start_kernel()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_sys_root()
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_leaf_sysctl_table()

* call: register_leaf_sysctl_table()
 - __register_sysctl_tables()

```
// ARM10C 20160625
// [rc1] set: &sysctl_table_root.default_set, path: kmem_cache#23-oX, files: kmem_cache#24-oX
struct ctl_table_header *__register_sysctl_table(
	struct ctl_table_set *set,
	const char *path, struct ctl_table *table)
{
	// set->dir.header.root: (&sysctl_table_root.default_set)->dir.header.root: &sysctl_table_root
	struct ctl_table_root *root = set->dir.header.root;
	// root: &sysctl_table_root

	struct ctl_table_header *header;
	const char *name, *nextname;
	struct ctl_dir *dir;
	struct ctl_table *entry;
	struct ctl_node *node;
	int nr_entries = 0;
	// nr_entries: 0

	// table: kmem_cache#24-oX, entry: kmem_cache#24-oX, entry->procname: (kmem_cache#24-oX)->procname: "sched_child_runs_first"
	for (entry = table; entry->procname; entry++)
		// nr_entries: 0
		nr_entries++;
		// nr_entries: 1

		// kern_table 의 child 없는 index 만큼 loop 수행

	// 위 loop 의 수행결과:
	// nr_entries: 46

	// sizeof(struct ctl_table_header): 32 bytes, sizeof(struct ctl_node): 16 bytes, nr_entries: 46, GFP_KERNEL: 0xD0
	// kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
	header = kzalloc(sizeof(struct ctl_table_header) +
			 sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);
	// header: kmem_cache#25-oX

	// header: kmem_cache#25-oX
	if (!header)
		return NULL;

	// header: kmem_cache#25-oX
	node = (struct ctl_node *)(header + 1);
	// node: &(kmem_cache#25-oX)[1] (struct ctl_node)

// 2016/06/25 종료
// 2016/07/02 시작

	// header: kmem_cache#25-oX, root: &sysctl_table_root, set: &sysctl_table_root.default_set,
	// node: &(kmem_cache#25-oX)[1] (struct ctl_node), table: kmem_cache#24-oX
	init_header(header, root, set, node, table);

	// init_header 에서 한일:
	// (kmem_cache#25-oX)->ctl_table: kmem_cache#24-oX
	// (kmem_cache#25-oX)->ctl_table_arg: kmem_cache#24-oX
	// (kmem_cache#25-oX)->used: 0
	// (kmem_cache#25-oX)->count: 1
	// (kmem_cache#25-oX)->nreg: 1
	// (kmem_cache#25-oX)->unregistering: NULL
	// (kmem_cache#25-oX)->root: &sysctl_table_root
	// (kmem_cache#25-oX)->set: &sysctl_table_root.default_set
	// (kmem_cache#25-oX)->parent: NULL
	// (kmem_cache#25-oX)->node: &(kmem_cache#25-oX)[1] (struct ctl_node)
	// (&(kmem_cache#25-oX)[1...46] (struct ctl_node))->header: kmem_cache#25-oX

	// path: kmem_cache#23-oX, table: kmem_cache#24-oX
	// sysctl_check_table(kmem_cache#23-oX, kmem_cache#24-oX): 0
	if (sysctl_check_table(path, table))
		goto fail;

	// sysctl_check_table 에서 한일:
	// table: kmem_cache#24-oX (kern_table) 의 child 없는 맴버 46개 만큼 loop를 수행하면서 
	// kern_table 의 맴버값을 체크함

	spin_lock(&sysctl_lock);

	// spin_lock에서 한일:
	// &sysctl_lock을 이용한 spin lock 수행

	// &set->dir: &(&sysctl_table_root.default_set)->dir
	dir = &set->dir;
	// dir: &(&sysctl_table_root.default_set)->dir

	/* Reference moved down the diretory tree get_subdir */
	// dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
	dir->header.nreg++;
	// dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2

	spin_unlock(&sysctl_lock);

	// spin_unlock에서 한일:
	// &sysctl_lock을 이용한 spin unlock 수행

	/* Find the directory for the ctl_table */
	// [f1] path: kmem_cache#23-oX: "kernel/", name: kmem_cache#23-oX: "kernel/"
	for (name = path; name; name = nextname) {
		int namelen;

		// [f2] name: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값+1: NULL

		// [f1] name: kmem_cache#23-oX: "kernel/"
		// [f1] strchr(kmem_cache#23-oX, '/'): kmem_cache#23-oX 의 '/' 위치의 주소값
		nextname = strchr(name, '/');
		// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값

		// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값
		if (nextname) {
			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값,
			// [f1] name: kmem_cache#23-oX: "kernel/"
			namelen = nextname - name;
			// [f1] namelen: 6

			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값
			nextname++;
			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값+1
		} else {
			namelen = strlen(name);
		}

		// [f1] namelen: 6
		if (namelen == 0)
			continue;

		// [f1] dir: &(&sysctl_table_root.default_set)->dir, name: kmem_cache#23-oX: "kernel/", namelen: 6
		// [f1] get_subdir(&(&sysctl_table_root.default_set)->dir, "kernel/", 6): kmem_cache#29-oX
		dir = get_subdir(dir, name, namelen);
		// [f1] dir: kmem_cache#29-oX

		// [f1] get_subdir 에서 한일:
		// struct ctl_dir: 36, struct ctl_node: 16, struct ctl_table: 34 * 2, char: 7
		// 만큼의 메모리 kmem_cache#29-oX 를 할당 받음
		//
		// (kmem_cache#29-oX + 120): "kernel"
		// ((kmem_cache#29-oX + 52)[0] (struct ctl_table)).procname: (kmem_cache#29-oX + 120): "kernel"
		// ((kmem_cache#29-oX + 52)[0] (struct ctl_table)).mode: 0040555
		// (&(kmem_cache#29-oX)->header)->ctl_table: (kmem_cache#29-oX + 52) (struct ctl_table)
		// (&(kmem_cache#29-oX)->header)->ctl_table_arg: (kmem_cache#29-oX + 52) (struct ctl_table)
		// (&(kmem_cache#29-oX)->header)->used: 0
		// (&(kmem_cache#29-oX)->header)->count: 1
		// (&(kmem_cache#29-oX)->header)->nreg: 1
		// (&(kmem_cache#29-oX)->header)->unregistering: NULL
		// (&(kmem_cache#29-oX)->header)->root: (&sysctl_table_root.default_set)->dir.header.root
		// (&(kmem_cache#29-oX)->header)->set: &sysctl_table_root.default_set
		// (&(kmem_cache#29-oX)->header)->parent: NULL
		// (&(kmem_cache#29-oX)->header)->node: (kmem_cache#29-oX + 36) (struct ctl_node)
		// ((kmem_cache#29-oX + 36) (struct ctl_node))->header: &(kmem_cache#29-oX)->header
		//
		// (&(&sysctl_table_root.default_set)->dir)->header.nreg: 3
		// (&(kmem_cache#29-oX)->header)->parent: &(&sysctl_table_root.default_set)->dir
		//
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node).__rb_parent_color: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_left: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_right: NULL
		// (&(&sysctl_table_root.default_set)->dir)->root.rb_node: &((kmem_cache#29-oX + 36) (struct ctl_node)).node
		//
		// RB Tree &((kmem_cache#29-oX + 36) (struct ctl_node)).node 을 black node 로 추가
		/*
		//                          proc-b
		//                         (kernel)
		*/
		// (&(&(&sysctl_table_root.default_set)->dir)->header)->nreg: 2
		// (&(kmem_cache#29-oX)->header)->nreg: 1

		// [f1] dir: kmem_cache#29-oX, IS_ERR(kmem_cache#29-oX): 0
		if (IS_ERR(dir))
			goto fail;

// 2016/07/02 종료
// 2016/07/09 시작

	}

	spin_lock(&sysctl_lock);

	// spin_unlock에서 한일:
	// &sysctl_lock을 이용한 spin unlock 수행

	// dir: kmem_cache#29-oX, header: kmem_cache#25-oX
	if (insert_header(dir, header))
		goto fail_put_dir_locked;
```

## insert_header()

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_leaf_sysctl_table()

* call: register_leaf_sysctl_table()
 - __register_sysctl_table()

* call: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()

* call: insert_keader()
 - insert_links()
 - insert_entry()

```
// ARM10C 20160709
// [2nd] dir: kmem_cache#29-oX, header: kmem_cache#25-oX
static int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)
{
	struct ctl_table *entry;
	int err;

	// [1st] dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
	// [2nd] dir->header.nreg: (kmem_cache#29-oX)->header.nreg: 1
	dir->header.nreg++;
	// [1st] dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 3
	// [2nd] dir->header.nreg: (kmem_cache#29-oX)->header.nreg: 2

	// [1st] header->parent: (&(kmem_cache#29-oX)->header)->parent: NULL,
	// [1st] dir: &(&sysctl_table_root.default_set)->dir
	// [2nd] header->parent: (kmem_cache#25-oX)->parent: NULL, dir: kmem_cache#29-oX
	header->parent = dir;
	// [1st] header->parent: (&(kmem_cache#29-oX)->header)->parent: &(&sysctl_table_root.default_set)->dir
	// [2nd] header->parent: (kmem_cache#25-oX)->parent: kmem_cache#29-oX

	// [1st] header: &(kmem_cache#29-oX)->header, insert_links(&(kmem_cache#29-oX)->header): 0
	// [2nd] header: kmem_cache#25-oX, insert_links(kmem_cache#25-oX): 0
	err = insert_links(header);
	// [1st] err: 0
	// [2nd] err: 0

	// [1st] err: 0
	// [2nd] err: 0
	if (err)
		goto fail_links;

	// [2nd] NOTE:
	// struct ctl_table 의 46 개 크기만큼 할당 받은 메모리 kmem_cache#24-oX 에
	// kern_table의 child 멤버 값이 NULL 인 index 의 table 값을 복사한 값

	// [1st][f1] header->ctl_table: (&(kmem_cache#29-oX)->header)->ctl_table: (kmem_cache#29-oX + 52) (struct ctl_table),
	// [1st][f1] entry: (kmem_cache#29-oX + 52) (struct ctl_table), ((kmem_cache#29-oX + 52) (struct ctl_table))->procname: "kernel"
	//
	// [2nd][f1] header->ctl_table: (kmem_cache#25-oX)->ctl_table: kmem_cache#24-oX
	// [2nd][f1] entry: kmem_cache#24-oX (struct ctl_table), (kmem_cache#24-oX (struct ctl_table))->procname: "sched_child_runs_first"
	for (entry = header->ctl_table; entry->procname; entry++) {
		// [1st][f2] entry: ((kmem_cache#29-oX + 52) (struct ctl_table))[1]
		// [1st][f2] entry->procname: (((kmem_cache#29-oX + 52) (struct ctl_table))[1]).procname: NULL

		// [2nd][f2] entry: (kmem_cache#24-oX (struct ctl_table))[1]
		// [2nd][f2] entry->procname: ((kmem_cache#24-oX (struct ctl_table))[1]).procname: "sched_min_granularity_ns"

		// [1st][f1] header: &(kmem_cache#29-oX)->header, entry: (kmem_cache#29-oX + 52) (struct ctl_table)
		// [1st][f1] insert_entry(&(kmem_cache#29-oX)->header, (kmem_cache#29-oX + 52) (struct ctl_table)): 0
		// [2nd][f1] header: kmem_cache#25-oX, entry: kmem_cache#24-oX (struct ctl_table)
		// [2nd][f1] insert_entry(kmem_cache#25-oX, kmem_cache#24-oX (struct ctl_table)): 0
		// [2nd][f2] header: kmem_cache#25-oX, entry: (kmem_cache#24-oX (struct ctl_table))[1]
		// [2nd][f2] insert_entry(kmem_cache#25-oX, kmem_cache#24-oX (struct ctl_table)): 0
		err = insert_entry(header, entry);
		// [1st][f1] err: 0
		// [2nd][f1] err: 0
		// [2nd][f2] err: 0

		// [1st][f1] insert_entry 에서 한일:
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node).__rb_parent_color: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_left: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_right: NULL
		// (&(&sysctl_table_root.default_set)->dir)->root.rb_node: &((kmem_cache#29-oX + 36) (struct ctl_node)).node
		//
		// &((kmem_cache#29-oX + 36) (struct ctl_node)).node 을 black node 로 추가
		// (proc의 kernel directory)
		/*
		//                          proc-b
		//                         (kernel)
		*/

		// [2nd][f1] insert_entry 에서 한일:
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node)).node).__rb_parent_color: NULL
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node)).node)->rb_left: NULL
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node)).node)->rb_right: NULL
		// &(kmem_cache#29-oX)->root.rb_node: &(&(kmem_cache#25-oX)[1] (struct ctl_node)).node
		//
		// &(&(kmem_cache#25-oX)[1] (struct ctl_node)).node 을 black node 로 추가
		// (kern_table 의 1 번째 index의 값)
		/*
		//                       kern_table-b
		//                 (sched_child_runs_first)
		*/

		// [2nd][f2] insert_entry 에서 한일:
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node) + 1).node).__rb_parent_color: &(&(kmem_cache#25-oX)[1] (struct ctl_node)).node
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node) + 1).node)->rb_left: NULL
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node) + 1).node)->rb_right: NULL
		// (&(&(kmem_cache#25-oX)[1] (struct ctl_node)).node)->rb_right: &(&(kmem_cache#25-oX)[1] (struct ctl_node) + 1).node
		//
		// &(&(kmem_cache#25-oX)[1] (struct ctl_node) + 1).node 을 node 로 추가 후 rbtree 로 구성
		// (kern_table 의 2 번째 index의 값)
		/*
		//                       kern_table-b
		//                 (sched_child_runs_first)
		//                                      \
		//                                        kern_table-r
		//                                  (sched_min_granularity_ns)
		//
		*/

		// [1st][f1] err: 0
		// [2nd][f1] err: 0
		// [2nd][f2] err: 0
		if (err)
			goto fail;

		// [2nd][f2] 위의 loop를 kern_table 의 index 수만큼 수행 (46개)
	}

	// [2nd] 위의 loop 수행 결과
	// TODO: kern_table 의 rbtree 그림을 그려야함

// 2016/07/09 종료

	return 0;
	// [1st] return 0
	// [2nd] return 0
fail:
	erase_header(header);
	put_links(header);
fail_links:
	header->parent = NULL;
	drop_sysctl_table(&dir->header);
	return err;
}
```

## __register_sysctl_table()

## insert_header()

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_leaf_sysctl_table()

* call: register_leaf_sysctl_table()
 - __register_sysctl_table()

* call: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()

* call: insert_keader()
 - insert_links()
 - insert_entry()

* return: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()
 - drop_sysctl_table()

```
// ARM10C 20160625
// [rc1] set: &sysctl_table_root.default_set, path: kmem_cache#23-oX, files: kmem_cache#24-oX
struct ctl_table_header *__register_sysctl_table(
	struct ctl_table_set *set,
	const char *path, struct ctl_table *table)
{
	// set->dir.header.root: (&sysctl_table_root.default_set)->dir.header.root: &sysctl_table_root
	struct ctl_table_root *root = set->dir.header.root;
	// root: &sysctl_table_root

	struct ctl_table_header *header;
	const char *name, *nextname;
	struct ctl_dir *dir;
	struct ctl_table *entry;
	struct ctl_node *node;
	int nr_entries = 0;
	// nr_entries: 0

	// table: kmem_cache#24-oX, entry: kmem_cache#24-oX, entry->procname: (kmem_cache#24-oX)->procname: "sched_child_runs_first"
	for (entry = table; entry->procname; entry++)
		// nr_entries: 0
		nr_entries++;
		// nr_entries: 1

		// kern_table 의 child 없는 index 만큼 loop 수행

	// 위 loop 의 수행결과:
	// nr_entries: 46

	// sizeof(struct ctl_table_header): 32 bytes, sizeof(struct ctl_node): 16 bytes, nr_entries: 46, GFP_KERNEL: 0xD0
	// kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
	header = kzalloc(sizeof(struct ctl_table_header) +
			 sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);
	// header: kmem_cache#25-oX

	// header: kmem_cache#25-oX
	if (!header)
		return NULL;

	// header: kmem_cache#25-oX
	node = (struct ctl_node *)(header + 1);
	// node: &(kmem_cache#25-oX)[1] (struct ctl_node)

// 2016/06/25 종료
// 2016/07/02 시작

	// header: kmem_cache#25-oX, root: &sysctl_table_root, set: &sysctl_table_root.default_set,
	// node: &(kmem_cache#25-oX)[1] (struct ctl_node), table: kmem_cache#24-oX
	init_header(header, root, set, node, table);

	// init_header 에서 한일:
	// (kmem_cache#25-oX)->ctl_table: kmem_cache#24-oX
	// (kmem_cache#25-oX)->ctl_table_arg: kmem_cache#24-oX
	// (kmem_cache#25-oX)->used: 0
	// (kmem_cache#25-oX)->count: 1
	// (kmem_cache#25-oX)->nreg: 1
	// (kmem_cache#25-oX)->unregistering: NULL
	// (kmem_cache#25-oX)->root: &sysctl_table_root
	// (kmem_cache#25-oX)->set: &sysctl_table_root.default_set
	// (kmem_cache#25-oX)->parent: NULL
	// (kmem_cache#25-oX)->node: &(kmem_cache#25-oX)[1] (struct ctl_node)
	// (&(kmem_cache#25-oX)[1...46] (struct ctl_node))->header: kmem_cache#25-oX

	// path: kmem_cache#23-oX, table: kmem_cache#24-oX
	// sysctl_check_table(kmem_cache#23-oX, kmem_cache#24-oX): 0
	if (sysctl_check_table(path, table))
		goto fail;

	// sysctl_check_table 에서 한일:
	// table: kmem_cache#24-oX (kern_table) 의 child 없는 맴버 46개 만큼 loop를 수행하면서 
	// kern_table 의 맴버값을 체크함

	spin_lock(&sysctl_lock);

	// spin_lock에서 한일:
	// &sysctl_lock을 이용한 spin lock 수행

	// &set->dir: &(&sysctl_table_root.default_set)->dir
	dir = &set->dir;
	// dir: &(&sysctl_table_root.default_set)->dir

	/* Reference moved down the diretory tree get_subdir */
	// dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
	dir->header.nreg++;
	// dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2

	spin_unlock(&sysctl_lock);

	// spin_unlock에서 한일:
	// &sysctl_lock을 이용한 spin unlock 수행

	/* Find the directory for the ctl_table */
	// [f1] path: kmem_cache#23-oX: "kernel/", name: kmem_cache#23-oX: "kernel/"
	for (name = path; name; name = nextname) {
		int namelen;

		// [f2] name: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값+1: NULL

		// [f1] name: kmem_cache#23-oX: "kernel/"
		// [f1] strchr(kmem_cache#23-oX, '/'): kmem_cache#23-oX 의 '/' 위치의 주소값
		nextname = strchr(name, '/');
		// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값

		// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값
		if (nextname) {
			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값,
			// [f1] name: kmem_cache#23-oX: "kernel/"
			namelen = nextname - name;
			// [f1] namelen: 6

			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값
			nextname++;
			// [f1] nextname: kmem_cache#23-oX: "kernel/" 의 '/' 위치의 주소값+1
		} else {
			namelen = strlen(name);
		}

		// [f1] namelen: 6
		if (namelen == 0)
			continue;

		// [f1] dir: &(&sysctl_table_root.default_set)->dir, name: kmem_cache#23-oX: "kernel/", namelen: 6
		// [f1] get_subdir(&(&sysctl_table_root.default_set)->dir, "kernel/", 6): kmem_cache#29-oX
		dir = get_subdir(dir, name, namelen);
		// [f1] dir: kmem_cache#29-oX

		// [f1] get_subdir 에서 한일:
		// struct ctl_dir: 36, struct ctl_node: 16, struct ctl_table: 34 * 2, char: 7
		// 만큼의 메모리 kmem_cache#29-oX 를 할당 받음
		//
		// (kmem_cache#29-oX + 120): "kernel"
		// ((kmem_cache#29-oX + 52)[0] (struct ctl_table)).procname: (kmem_cache#29-oX + 120): "kernel"
		// ((kmem_cache#29-oX + 52)[0] (struct ctl_table)).mode: 0040555
		// (&(kmem_cache#29-oX)->header)->ctl_table: (kmem_cache#29-oX + 52) (struct ctl_table)
		// (&(kmem_cache#29-oX)->header)->ctl_table_arg: (kmem_cache#29-oX + 52) (struct ctl_table)
		// (&(kmem_cache#29-oX)->header)->used: 0
		// (&(kmem_cache#29-oX)->header)->count: 1
		// (&(kmem_cache#29-oX)->header)->nreg: 1
		// (&(kmem_cache#29-oX)->header)->unregistering: NULL
		// (&(kmem_cache#29-oX)->header)->root: (&sysctl_table_root.default_set)->dir.header.root
		// (&(kmem_cache#29-oX)->header)->set: &sysctl_table_root.default_set
		// (&(kmem_cache#29-oX)->header)->parent: NULL
		// (&(kmem_cache#29-oX)->header)->node: (kmem_cache#29-oX + 36) (struct ctl_node)
		// ((kmem_cache#29-oX + 36) (struct ctl_node))->header: &(kmem_cache#29-oX)->header
		//
		// (&(&sysctl_table_root.default_set)->dir)->header.nreg: 3
		// (&(kmem_cache#29-oX)->header)->parent: &(&sysctl_table_root.default_set)->dir
		//
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node).__rb_parent_color: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_left: NULL
		// (&((kmem_cache#29-oX + 36) (struct ctl_node)).node)->rb_right: NULL
		// (&(&sysctl_table_root.default_set)->dir)->root.rb_node: &((kmem_cache#29-oX + 36) (struct ctl_node)).node
		//
		// RB Tree &((kmem_cache#29-oX + 36) (struct ctl_node)).node 을 black node 로 추가
		/*
		//                          proc-b
		//                         (kernel)
		*/
		// (&(&(&sysctl_table_root.default_set)->dir)->header)->nreg: 2
		// (&(kmem_cache#29-oX)->header)->nreg: 1

		// [f1] dir: kmem_cache#29-oX, IS_ERR(kmem_cache#29-oX): 0
		if (IS_ERR(dir))
			goto fail;

// 2016/07/02 종료
// 2016/07/09 시작

	}

	spin_lock(&sysctl_lock);

	// spin_unlock에서 한일:
	// &sysctl_lock을 이용한 spin unlock 수행

	// dir: kmem_cache#29-oX, header: kmem_cache#25-oX
	if (insert_header(dir, header))
		goto fail_put_dir_locked;

	drop_sysctl_table(&dir->header);
	spin_unlock(&sysctl_lock);

	return header;

fail_put_dir_locked:
	drop_sysctl_table(&dir->header);
	spin_unlock(&sysctl_lock);
fail:
	kfree(header);
	dump_stack();
	return NULL;
}
```

# drop_sysctl_table()

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_leaf_sysctl_table()

* call: register_leaf_sysctl_table()
 - __register_sysctl_table()

* call: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()

* call: insert_keader()
 - insert_links()
 - insert_entry()

* return: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()
 - drop_sysctl_table()

* call: drop_sysctl_table()

```
// ARM10C 20160702
// &new->header: &(kmem_cache#29-oX)->header
static void drop_sysctl_table(struct ctl_table_header *header)
{
	// header->parent: (&(&(&sysctl_table_root.default_set)->dir)->header)->parent: NULL
	// header->parent: (&(kmem_cache#29-oX)->header)->parent: &(&sysctl_table_root.default_set)->dir
	struct ctl_dir *parent = header->parent;
	// parent: NULL
	// parent: &(&sysctl_table_root.default_set)->dir

	// header->nreg: (&(&(&sysctl_table_root.default_set)->dir)->header)->nreg: 3
	// header->nreg: (&(kmem_cache#29-oX)->header)->nreg: 2
	if (--header->nreg)
		// header->nreg: (&(&(&sysctl_table_root.default_set)->dir)->header)->nreg: 2
		// header->nreg: (&(kmem_cache#29-oX)->header)->nreg: 1
		return;
		// return
		// return

	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);

	if (parent)
		drop_sysctl_table(&parent->header);
}
```

## register_leaf_sysctl_table()

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_leaf_sysctl_table()

* call: register_leaf_sysctl_table()
 - __register_sysctl_table()

* call: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_header()

* call: insert_keader()
 - insert_links()
 - insert_entry()

* return: __register_sysctl_table()
 - kzalloc(768, GFP_KERNEL: 0xD0): kmem_cache#25-oX
 - init_header()
 - sysctl_check_table()
 - spin_lock()
   - // &sysctl_lock을 이용한 spin lock 수행
   - // &set->dir: &(&sysctl_table_root.default_set)->dir
   - dir = &set->dir;
   - // dir: &(&sysctl_table_root.default_set)->dir
   - /* Reference moved down the diretory tree get_subdir */
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 1
   - dir->header.nreg++;
   - // dir->header.nreg: (&(&sysctl_table_root.default_set)->dir)->header.nreg: 2
 - spin_unlock()
 - get_subdir()
 - spin_lock()
 - insert_keaher()
 - drop_sysctl_table()

* return: register_leaf_sysctl_table()
 - __register_sysctl_table()

```
// ARM10C 20160625
// [rc1] path: kmem_cache#23-oX, child_pos: &(kmem_cache#23-oX)[7] subheader: &(kmem_cache#27-oX)[1] (struct ctl_table_header)
// [rc1] set: &sysctl_table_root.default_set, entry->child: sysctl_base_table[0].child: kern_table
static int register_leaf_sysctl_tables(const char *path, char *pos,
	struct ctl_table_header ***subheader, struct ctl_table_set *set,
	struct ctl_table *table)
{
	struct ctl_table *ctl_table_arg = NULL;
	// ctl_table_arg: NULL
	// [rc1] ctl_table_arg: NULL

	struct ctl_table *entry, *files;
	int nr_files = 0;
	// nr_files: 0
	// [rc1] nr_files: 0

	int nr_dirs = 0;
	// nr_dirs: 0
	// [rc1] nr_dirs: 0

	// ENOMEM: 12
	// [rc1] ENOMEM: 12
	int err = -ENOMEM;
	// err: -12
	// [rc1] err: -12

	// table: sysctl_base_table, entry: sysctl_base_table,
	// entry->procname: sysctl_base_table[0].procname: "kernel"
	// [rc1] table: kern_table, entry: kern_table,
	// [rc1] entry->procname: kern_table[0].procname: "sched_child_runs_first"
	for (entry = table; entry->procname; entry++) {
		// entry->child: sysctl_base_table[0].child: kern_table
		// [rc1] entry->child: kern_table[0].child: NULL
		if (entry->child)
			// nr_dirs: 0
			nr_dirs++;
			// nr_dirs: 1
		else
			// [rc1] nr_files: 0
			nr_files++;
			// [rc1] nr_files: 1

		// sysctl_base_table 맴버 값 만큼 loop 수행
		// [rc1] kern_table 맴버 값 만큼 loop 수행
	}

	// 위 loop를 수행한 결과
	// nr_dirs: 5

	// [rc1] 위 loop를 수행한 결과
	// [rc1] nr_dirs: 2, [rc1] nr_files: 46

	// table: sysctl_base_table
	// [rc1] table: kern_table
	files = table;
	// files: sysctl_base_table
	// [rc1] files: kern_table

	/* If there are mixed files and directories we need a new table */
	// nr_dirs: 5, nr_files: 0
	// [rc1] nr_dirs: 2, nr_files: 46
	if (nr_dirs && nr_files) {
		struct ctl_table *new;

		// [rc1] sizeof(struct ctl_table): 34 bytes, nr_files: 46, GFP_KERNEL: 0xD0
		// [rc1] kzalloc(1598, GFP_KERNEL: 0xD0): kmem_cache#24-oX
		files = kzalloc(sizeof(struct ctl_table) * (nr_files + 1),
				GFP_KERNEL);
		// [rc1] files: kmem_cache#24-oX

		// [rc1] files: kmem_cache#24-oX
		if (!files)
			goto out;

		// [rc1] ctl_table_arg: NULL, [rc1] files: kmem_cache#24-oX
		ctl_table_arg = files;
		// [rc1] ctl_table_arg: kmem_cache#24-oX

		// [rc1] files: kmem_cache#24-oX, new: kmem_cache#24-oX, table: kern_table, entry: kern_table,
		// [rc1] entry->procname: kern_table[0].procname: "sched_child_runs_first"
		for (new = files, entry = table; entry->procname; entry++) {
			// [rc1] entry->child: kern_table[0].child: NULL
			if (entry->child)
				continue;
			// [rc1] *new: (kmem_cache#24-oX)[0], *entry: kern_table[0]
			*new = *entry;
			// [rc1] *new: (kmem_cache#24-oX)[0]: kern_table[0]

			// [rc1] new: kmem_cache#24-oX
			new++;
			// [rc1] new: &(kmem_cache#24-oX + 1)

			// [rc1] kern_table 이 가지고 있는 index 만큼 loop 수행
		}

		// [rc1] 위 loop의 수행 결과:
		// struct ctl_table 의 46 개 크기만큼 할당 받은 메모리 kmem_cache#24-oX 에
		// kern_table의 child 멤버 값이 NULL 인 index 의 table 값을 복사함
	}

	/* Register everything except a directory full of subdirectories */
	// nr_files: 0, nr_dirs: 5
	// [rc1] nr_files: 46, nr_dirs: 2
	if (nr_files || !nr_dirs) {
		struct ctl_table_header *header;

		// [rc1] set: &sysctl_table_root.default_set, path: kmem_cache#23-oX, files: kmem_cache#24-oX
		header = __register_sysctl_table(set, path, files);
		if (!header) {
			kfree(ctl_table_arg);
			goto out;
		}

		/* Remember if we need to free the file table */
		header->ctl_table_arg = ctl_table_arg;
		**subheader = header;
		(*subheader)++;
	}

	/* Recurse into the subdirectories. */
	// table: sysctl_base_table, entry: sysctl_base_table,
	// entry->procname: sysctl_base_table[0].procname: "kernel"
	for (entry = table; entry->procname; entry++) {
		char *child_pos;

		// entry->child: sysctl_base_table[0].child: kern_table
		if (!entry->child)
			continue;

		// ENAMETOOLONG: 36
		err = -ENAMETOOLONG;
		// err: -36

		// path: kmem_cache#23-oX, pos: kmem_cache#23-oX,
		// entry->procname: sysctl_base_table[0].procname: "kernel"
		// append_path(kmem_cache#23-oX, kmem_cache#23-oX, "kernel"): &(kmem_cache#23-oX)[7]
		child_pos = append_path(path, pos, entry->procname);
		// child_pos: &(kmem_cache#23-oX)[7]

		// append_path 에서 한일:
		// pos: kmem_cache#23-oX: "kernel/"

		// child_pos: &(kmem_cache#23-oX)[7]
		if (!child_pos)
			goto out;

		// path: kmem_cache#23-oX, child_pos: &(kmem_cache#23-oX)[7] subheader: &(kmem_cache#27-oX)[1] (struct ctl_table_header)
		// set: &sysctl_table_root.default_set, entry->child: sysctl_base_table[0].child: kern_table
		// register_leaf_sysctl_tables(kmem_cache#23-oX, &(kmem_cache#23-oX)[7], &(kmem_cache#27-oX)[1] (struct ctl_table_header), 
		//                             &sysctl_table_root.default_set, kern_table): 0
		err = register_leaf_sysctl_tables(path, child_pos, subheader,
						  set, entry->child);
		// err: 0

		// register_leaf_sysctl_tables 에서 한일:

		pos[0] = '\0';
		if (err)
			goto out;
	}
	err = 0;
out:
	/* On failure our caller will unregister all registered subheaders */
	return err;
}
```

## __register_sysctl_paths()

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

* call: __register_sysctl_paths()
 - count_subheaders()
 - kmalloc(): PATH_MAX: 4096
 - kzalloc(): header: 256
 - register_leaf_sysctl_table()

```
// ARM10C 20160611
// &sysctl_table_root.default_set, path: null_path, table: sysctl_base_table
struct ctl_table_header *__register_sysctl_paths(
	struct ctl_table_set *set,
	const struct ctl_path *path, struct ctl_table *table)
{
	// table: sysctl_base_table
	struct ctl_table *ctl_table_arg = table;
	// ctl_table_arg: sysctl_base_table

	// table: sysctl_base_table, count_subheaders(sysctl_base_table): 2
	int nr_subheaders = count_subheaders(table);
	// nr_subheaders: 2

	struct ctl_table_header *header = NULL, **subheaders, **subheader;
	// header: NULL

	const struct ctl_path *component;
	char *new_path, *pos;

	// PATH_MAX: 4096, GFP_KERNEL: 0xD0,
	// kmalloc(4096, GFP_KERNEL: 0xD0): kmem_cache#23-oX
	pos = new_path = kmalloc(PATH_MAX, GFP_KERNEL);
	// pos: kmem_cache#23-oX, new_path: kmem_cache#23-oX

	// new_path: kmem_cache#23-oX
	if (!new_path)
		return NULL;

	// pos[0]: (kmem_cache#23-oX)[0]
	pos[0] = '\0';
	// pos[0]: (kmem_cache#23-oX)[0]: '\0'

	// path: null_path, component: null_path, component->procname: null_path->procname: NULL
	for (component = path; component->procname; component++) {
		pos = append_path(new_path, pos, component->procname);
		if (!pos)
			goto out;
	}

	// table->procname: sysctl_base_table[0].procname: "kernel",
	// table->child: sysctl_base_table[0].child: kern_table,
	// table[1]->procname: sysctl_base_table[1].procname: "vm",
	while (table->procname && table->child && !table[1].procname) {
		pos = append_path(new_path, pos, table->procname);
		if (!pos)
			goto out;
		table = table->child;
	}

	// nr_subheaders: 2
	if (nr_subheaders == 1) {
		header = __register_sysctl_table(set, new_path, table);
		if (header)
			header->ctl_table_arg = ctl_table_arg;
	} else {
		// header: NULL, sizeof(struct ctl_table_header): 32 bytes
		// sizeof(*header): 32, sizeof(*subheaders): 4, nr_subheaders: 2, GFP_KERNEL: 0xD0,
		// kzalloc(256, GFP_KERNEL: 0xD0): kmem_cache#27-oX
		header = kzalloc(sizeof(*header) +
				 sizeof(*subheaders)*nr_subheaders, GFP_KERNEL);
		// header: kmem_cache#27-oX

		// header: kmem_cache#27-oX
		if (!header)
			goto out;

		// header: kmem_cache#27-oX
		subheaders = (struct ctl_table_header **) (header + 1);
		// subheaders: &(kmem_cache#27-oX)[1] (struct ctl_table_header)

		// subheaders: &(kmem_cache#27-oX)[1] (struct ctl_table_header)
		subheader = subheaders;
		// subheader: &(kmem_cache#27-oX)[1] (struct ctl_table_header)

		// header->ctl_table_arg: (kmem_cache#27-oX)->ctl_table_arg, ctl_table_arg: sysctl_base_table
		header->ctl_table_arg = ctl_table_arg;
		// header->ctl_table_arg: (kmem_cache#27-oX)->ctl_table_arg: sysctl_base_table

		// new_path: kmem_cache#23-oX, pos: kmem_cache#23-oX, subheader: &(kmem_cache#27-oX)[1] (struct ctl_table_header)
		// set: &sysctl_table_root.default_set, table: sysctl_base_table
		if (register_leaf_sysctl_tables(new_path, pos, &subheader,
						set, table))
			goto err_register_leaves;
	}

out:
	kfree(new_path);
	return header;

err_register_leaves:
	while (subheader > subheaders) {
		struct ctl_table_header *subh = *(--subheader);
		struct ctl_table *table = subh->ctl_table_arg;
		unregister_sysctl_table(subh);
		kfree(table);
	}
	kfree(header);
	header = NULL;
	goto out;
}
```

## register_sysctl_paths()

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

* call: register_sysctl_paths()
 - __register_sysctl_paths()

```
// ARM10C 20160611
// null_path, table: sysctl_base_table
struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,
						struct ctl_table *table)
{
	// path: null_path, table: sysctl_base_table
	return __register_sysctl_paths(&sysctl_table_root.default_set,
					path, table);
}
EXPORT_SYMBOL(register_sysctl_paths);
```

# register_sysctl_table()

* start_kernel()
...
 -  - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

* call: register_sysctl_table()
 - register_sysctl_paths()

``
// ARM10C 20160611
// sysctl_base_table
struct ctl_table_header *register_sysctl_table(struct ctl_table *table)
{
	static const struct ctl_path null_path[] = { {} };

	// table: sysctl_base_table
	return register_sysctl_paths(null_path, table);
}
EXPORT_SYMBOL(register_sysctl_table);
```

## sysctl_init()

* start_kernel()
...
 -  - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

* call: sysctl_init()
 - register_sysctl_table()

```
// ARM10C 20160611
int __init sysctl_init(void)
{
	struct ctl_table_header *hdr;

	hdr = register_sysctl_table(sysctl_base_table);
	kmemleak_not_leak(hdr);
	return 0;
}
```

## proc_sys_init()

* start_kernel()
...
 -  - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()
 
* call: proc_sys_init()
 - proc_mkdir("sys", NULL);
 - sysctl_init();

```
// ARM10C 20160611
int __init proc_sys_init(void)
{
	struct proc_dir_entry *proc_sys_root;

	// proc_mkdir("sys", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_sys_root = proc_mkdir("sys", NULL);
	// proc_sys_root: kmem_cache#29-oX (struct proc_dir_entry)

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "sys"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_sys_root->proc_iops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops
	proc_sys_root->proc_iops = &proc_sys_dir_operations;
	// proc_sys_root->proc_iops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_sys_dir_operations

	// proc_sys_root->proc_fops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops
	proc_sys_root->proc_fops = &proc_sys_dir_file_operations;
	// proc_sys_root->proc_fops: (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &proc_sys_dir_file_operations

	// proc_sys_root->nlink: (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	proc_sys_root->nlink = 0;
	// proc_sys_root->nlink: (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 0

	return sysctl_init();
}
```

## proc_root_init()

* start_kernel()
...
 -  - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()
 - proc_net_init()
 - proc_mkdir("sysvipc", NULL);
 - proc_mkdir("fs", NULL);
 - proc_mkdir("driver", NULL);
 - proc_mkdir("fs/nfsd", NULL);
 - proc_mkdir("openprom", NULL);
 - proc_tty_init()
 - proc_device_tree_init();
 - proc_mkdir"bus", NULL);
 - proc_sys_init()

```
// ARM10C 20160604
void __init proc_root_init(void)
{
	int err;

	proc_init_inodecache();

	// proc_init_inodecache 에서 한일:
	// struct proc_inode 크기 만큼의 메모리를 할당항는 kmem_cache 할당자를 생성함
	// proc_inode_cachep: kmem_cache#n#28 (struct proc_inode)

	// register_filesystem(&proc_fs_type): 0
	err = register_filesystem(&proc_fs_type);
	// err: 0

	// register_filesystem에서 한일:
	// (&bd_type)->next: &proc_fs_type
	//
	// file system 연결 결과
	// file_systems: sysfs_fs_type -> rootfs_fs_type -> shmem_fs_type -> bd_type -> proc_fs_type

	// err: 0
	if (err)
		return;

	proc_self_init();

	// proc_self_init 에서 한일:
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 2 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 1번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 1         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 1)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 1 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 2
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 1) 의 memory 공간을 반환함
	//
	// self_inum: 0xF0000001

	// proc_symlink("mounts", NULL, "self/mounts"): kmem_cache#29-oX (struct proc_dir_entry)
	proc_symlink("mounts", NULL, "self/mounts");

	// proc_symlink 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "mounts"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 6
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0120777
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: kmem_cache#30-oX: "self/mounts"
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 2번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 2         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 2)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 2 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 3
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 2) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000002
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_link_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)

	// proc_net_init(): 0
	proc_net_init();

	// proc_net_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "net"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0120777
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: kmem_cache#30-oX: "self/net"
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 3번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 3         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 3)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 3 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 4
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 3) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000003
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_link_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)
	//
	// list head 인 &pernet_list 에 &(&proc_net_ns_ops)->list 을 tail로 추가함

#ifdef CONFIG_SYSVIPC // CONFIG_SYSVIPC=y
	// proc_mkdir("sysvipc", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("sysvipc", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "sysvipc"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 7
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
#endif
	// proc_mkdir("fs", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("fs", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "fs"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 2
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_mkdir("driver", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("driver", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "driver"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 6
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	// proc_mkdir("fs/nfsd", NULL): kmem_cache#29-oX (struct proc_dir_entry)
	proc_mkdir("fs/nfsd", NULL); /* somewhere for the nfsd filesystem to be mounted */

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "fs/nfsd"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 7
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE) // CONFIG_SUN_OPENPROMFS=n, CONFIG_SUN_OPENPROMFS_MODULE=n
	/* just give it a mountpoint */
	proc_mkdir("openprom", NULL);
#endif
	proc_tty_init();

	// proc_tty_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/ldisc"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 9
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/driver"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 10
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 00500
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/ldiscs"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 10
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0100444
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &tty_ldiscs_proc_fops
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: NULL
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 4번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 4         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 4)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 4 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 5
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 4) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000004
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_file_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)
	//
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "tty/drivers"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 11
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0100444
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 1
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_fops: &proc_tty_drivers_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->data: NULL
	//
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 1 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 5번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 5         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 5)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 5 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 6
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 5) 의 memory 공간을 반환함
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->low_ino: 0xF0000005
	// (kmem_cache#29-oX (struct proc_dir_entry))->proc_iops: &proc_file_inode_operations
	// (kmem_cache#29-oX (struct proc_dir_entry))->next: NULL
	// (kmem_cache#29-oX (struct proc_dir_entry))->parent: &proc_root
	//
	// (&proc_root)->subdir: kmem_cache#29-oX (struct proc_dir_entry)

#ifdef CONFIG_PROC_DEVICETREE // CONFIG_PROC_DEVICETREE=y
	proc_device_tree_init();

	// proc_device_tree_init 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "device-tree"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 11
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root
	//
	// unflatten_device_tree 에서 만든 tree의 root node 의 값을 사용하여proc device tree를 만드는 작업을 수행
#endif
	proc_mkdir("bus", NULL);

	// proc_mkdir 에서 한일:
	// struct proc_dir_entry 만큼 메모리를 할당 받음 kmem_cache#29-oX (struct proc_dir_entry)
	//
	// (kmem_cache#29-oX (struct proc_dir_entry))->name: "bus"
	// (kmem_cache#29-oX (struct proc_dir_entry))->namelen: 3
	// (kmem_cache#29-oX (struct proc_dir_entry))->mode: 0040555
	// (kmem_cache#29-oX (struct proc_dir_entry))->nlink: 2
	// (&(kmem_cache#29-oX (struct proc_dir_entry))->count)->counter: 1
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock을 이용한 spin lock 초기화 수행
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->magic: 0xdead4ead
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner: 0xffffffff
	// ((&(kmem_cache#29-oX (struct proc_dir_entry))->pde_unload_lock)->rlock)->owner_cpu: 0xffffffff
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->next: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	// &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list->prev: &(kmem_cache#29-oX (struct proc_dir_entry))->pde_openers->i_sb_list
	//
	// parent: &proc_root

	proc_sys_init();
}
```

# start_kernel()

* call: start_kernel()
 - lockdep_init()
 - smp_setup_processor_id()
 - debug_objects_early_init()
 - boot_init_stack_canary()
 - cgroup_init_early()
 - local_irq_disable()
 - boot_cpu_init()
 - page_address_init()
 - pr_notice()
 - setup_arch()
 - mm_init_owner()
 - mm_init_cpumask()
 - setup_command_line
 - build_all_zonelists()
 - page_alloc_init()
 - pr_notice()
 - parse_early_param()
 - parse_args()
 - jump_label_init()
 - setup_log_buf()
 - pidhash_init()
 - vfs_caches_init_early()
 - sort_main_extable()
 - trap_init()
 - mm_init()
 - sched_init()
 - preempt_disable()
 - irqs_disabled()
 - local_irq_disabled()
 - idr_init_cache()
 - rcu_init()
 - tick_nohz_init()
 - contect_tracking_init()
 - radix_tree_init()
 - early_irq_init()
 - init_IRQ()
 - tick_init()
 - init_timers()
 - hrtimers_init()
 - softirq_init()
 - timekeeping_init()
 - time_init()
 - sched_clock_postinit()
 - pref_event_init()
 - profile_init()
 - call_function_init()
 - irqs_disabled()
 - local_irq_enabled()
 - kmem_cache_init_late()
 - console_init()
 - lockdep_init()
 - lockdep_info()
 - locking_selftest()
 - virt_to_page()
 - page_to_pfn()
 - page_cgroup_init()
 - debug_objects_mem_init()
 - kmemleak_init()
 - setup_per_cpu_pageset()
 - numa_policy_init()
 - sched_clock_init()
 - calibrate_delay()
 - pidmap_init()
 - anon_vma_init()
 - thread_info_cache_init()
 - cred_init()
 - fork_init()
 - proc_caches_init()
 - buffer_init()
 - key_init()
 - security_init()
 - dbg_late_init()
 - vfs_caches_init()
 - signals_init()
 - page_writeback_init()
 - proc_root_init()

```
// ARM10C 20130824
asmlinkage void __init start_kernel(void)
{
	char * command_line;
	extern const struct kernel_param __start___param[], __stop___param[];
	// ATAG,DTB 정보로 사용

	/*
	 * Need to run as early as possible, to initialize the
	 * lockdep hash:
	 */
	lockdep_init();
	smp_setup_processor_id();
	debug_objects_early_init();

	/*
	 * Set up the the initial canary ASAP:
	 */
	boot_init_stack_canary();

	cgroup_init_early();
	// cgroup 를 사용하기 위한 cgroup_dummy_root, cgroup_subsys 의 구조체 초기화 수행

	local_irq_disable();
	// IRQ를 disable 함

	early_boot_irqs_disabled = true;
	// early_boot_irqs_disabled: true

/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */
	boot_cpu_init();
	// 현재 cpu(core id)를 얻어서 cpu_XXX_bits[] 의 cpu를 셋한다.
	
	page_address_init();
	// 128개의 page_address_htable 배열을 초기화

	pr_notice("%s", linux_banner);
	// 배너:
	//	Linux version 2.6.37_DM385_IPNC_3.50.00
	// 	(a0875405@bangvideoapps01) (gcc version 4.5.3 20110311
	// 	(prerelease) (GCC) ) #1 Fri Dec 21 17:27:08 IST 2012

	setup_arch(&command_line);

	mm_init_owner(&init_mm, &init_task); // null function
	mm_init_cpumask(&init_mm); // null function

	// command_line: exynos5420-smdk5420.dts 파일의 chosen node 의 bootarg 값
	// "console=ttySAC2,115200 init=/linuxrc"
	setup_command_line(command_line);
	// saved_command_line 및 static_command_line 할당

	setup_nr_cpu_ids();
	setup_per_cpu_areas();
	// pcpu 구조체를 만들어 줌 (mm/percpu.c)

	smp_prepare_boot_cpu();	/* arch-specific boot-cpu hooks */
	// boot cpu 0의 pcpu 영역의 base주소를 core register에 설정해줌

	build_all_zonelists(NULL, NULL);

	page_alloc_init();
	// cpu_chain에 page_alloc_cpu_notify를 연결함 (mutex lock/unlock 사용)

	// boot_command_line: "console=ttySAC2,115200 init=/linuxrc"
	pr_notice("Kernel command line: %s\n", boot_command_line);
	// "Kernel command line: console=ttySAC2,115200 init=/linuxrc"

	parse_early_param();
	// setup_arch에서 수행했던 작업 다시 수행
	// command arg에서 각 요소들을 파싱하여 early init section으로 설정된 디바이스 초기화.
	// 우리는 serial device가 검색이 되지만 config설정은 없어서 아무것도 안함.

	// static_command_line: "console=ttySAC2,115200 init=/linuxrc"
	parse_args("Booting kernel", static_command_line, __start___param,
		   __stop___param - __start___param,
		   -1, -1, &unknown_bootoption);
	// DTB에서 넘어온 bootargs를 파싱하여 param, val을 뽑아내고 그에 대응되는
	// kernel_param 구조체에 값을 등록함.

	jump_label_init();
	// HAVE_JUMP_LABEL 이 undefined 이므로 NULL 함수

	/*
	 * These use large bootmem allocations and must precede
	 * kmem_cache_init()
	 */
	setup_log_buf(0);
	// defalut log_buf의 크기는 __LOG_BUF_LEN: 0x20000 (128KB) 임
	// early_param 에서 호출했던 log_buf_len 값이 있다면 log_buf의 크기를 넘어온 크기로 만듬

	pidhash_init();
	// pidhash의 크기를 16kB만큼 할당 받고 4096개의 hash list를 만듬

	vfs_caches_init_early();
	// Dentry cache, Inode-cache용 hash를 위한 메모리 공간을 각각 512kB, 256kB만큼 할당 받고,
	// 131072, 65536개 만큼 hash table을 각각 만듬

	sort_main_extable();
	// extable 을 cmp_ex를 이용하여 sort수행

	trap_init(); // null function

	mm_init();
	// buddy와 slab 을 활성화 하고 기존 할당 받은 bootmem 은 buddy,
	// pcpu 메모리, vmlist 는 slab으로 이관

	/*
	 * Set up the scheduler prior starting any interrupts (such as the
	 * timer interrupt). Full topology setup happens at smp_init()
	 * time - but meanwhile we still have a functioning scheduler.
	 */
	sched_init();
	// scheduler가 사용하는 자료 구조 초기화, idle_threads를 init_task로 세팅

	/*
	 * Disable preemption - early bootup scheduling is extremely
	 * fragile until we cpu_idle() for the first time.
	 */
	preempt_disable();
	// preempt count를 증가시켜 preemption 못하도록 막음

	// irqs_disabled(): 1
	if (WARN(!irqs_disabled(), "Interrupts were enabled *very* early, fixing it\n"))
		local_irq_disable();

	idr_init_cache();
	// integer ID management로 사용하는 idr_layer_cache에 kmem_cache#21 을 생성 및 초기화 후 할당

	rcu_init();
	// rcu 자료구조 bh, sched, preempt 를 각각 초기화 수행함

	tick_nohz_init(); // null function
	context_tracking_init(); // null function

	radix_tree_init();
	// radix tree로 사용하는 radix_tree_node_cachep에 kmem_cache#20을 생성 및 초기화 후 할당하고
	// height_to_maxindex을 초기화 수행

	/* init some links before init_ISA_irqs() */
	early_irq_init();
	// irq_desc 0 ~ 15 까지의 object을 할당 받고 초기화를 수행
	// allocated_irqs에 bit를 1로 세팅하고 radix tree에 각 irq_desc를 노트로 추가

	init_IRQ();
	// gic, combiner이 사용할 메모리 할당과 자료 구조 설정,
	// gic irq (0~15), combiner irq (32~63) interrupt 를 enable 시킴

	tick_init();
	// tick 관련 mask 변수를 0으로 초기화 수행

	init_timers();
	// boot_tvec_bases의 맴버 값을 초기화하고 timers_nb를 cpu_notifier 에 등록,
	// softirq_vec[1] 에 run_timer_softirq 등록하여 초기화 수행

	hrtimers_init();
	// hrtimer_bases의 맴버 값을 초기화하고 hrtimers_nb를 cpu_notifier 에 등록,
	// softirq_vec[8] 에 run_hrtimer_softirq 등록하여 초기화 수행

	softirq_init();
	// tasklet_vec, tasklet_hi_vec 맴버 값을 초기화하고,
	// softirq_vec[6]에 tasklet_action, softirq_vec[0]에 tasklet_hi_action 등록하여 초기화 수행

	timekeeping_init();
	// ntp 관련 전역변수 초기화, timekeeper, shadow_timekeeper의 맴버값 초기화 수행

	time_init();
	// timer 를 사용하기 위한 clk source, clk_table 메모리 할당 및 초기화,
	// timer event를 위한 timer irq (MCT) 초기화 수행

	sched_clock_postinit();
	// sched_clock_timer을 초기화 수행

	perf_event_init(); // null function
	profile_init(); // null function
	call_function_init();
	// 각 cpu core에서 사용할 call_single_queue를 맴버값 초기화
	// cfd_data 맴버값을 초기화하고 pcp에서 사용할 메모리 공간 할당
	// cpu_chain에 hotplug_cfd_notifier 를 등록함

	// irqs_disabled(): 1
	WARN(!irqs_disabled(), "Interrupts were enabled early\n");

	// early_boot_irqs_disabled: true
	early_boot_irqs_disabled = false;
	// early_boot_irqs_disabled: false

	local_irq_enable();
	// IRQ를 enable 함

	kmem_cache_init_late(); // null function

	/*
	 * HACK ALERT! This is early. We're enabling the console before
	 * we've done PCI setups etc, and console_init() must be aware of
	 * this. But we do want output early, in case something goes wrong.
	 */
	console_init();

	// panic_later: NULL
	if (panic_later)
		panic(panic_later, panic_param);

	lockdep_info(); // null function

	/*
	 * Need to run this when irqs are enabled, because it wants
	 * to self-test [hard/soft]-irqs on/off lock inversion bugs
	 * too:
	 */
	locking_selftest(); // null function

#ifdef CONFIG_BLK_DEV_INITRD // CONFIG_BLK_DEV_INITRD=y
	// initrd_start: NULL, initrd_below_start_ok: 0
	if (initrd_start && !initrd_below_start_ok &&
	    page_to_pfn(virt_to_page((void *)initrd_start)) < min_low_pfn) {
		pr_crit("initrd overwritten (0x%08lx < 0x%08lx) - disabling it.\n",
		    page_to_pfn(virt_to_page((void *)initrd_start)),
		    min_low_pfn);
		initrd_start = 0;
	}
#endif

	page_cgroup_init(); // null function
	debug_objects_mem_init(); // null function
	kmemleak_init(); // null function

	setup_per_cpu_pageset();
	// per cpu가 사용하는 pageset의 각각의 zone 맴버값 초기화 수행

	numa_policy_init(); // null function

	// late_time_init: NULL
	if (late_time_init)
		late_time_init();

	sched_clock_init();
	// sched_clock_running 값을 1 로 초기화 수행

	calibrate_delay();
	// BogoMIPS값을 결정하기위한 계산을 수행하고 결과를 출력함

	pidmap_init();
	// pidmap 을 사용하기 위한 초기화 수행

	anon_vma_init();
	// anon vma 를 사용하기 위한 kmem_cache 할당자 초기화 수행

#ifdef CONFIG_X86 // CONFIG_X86=n
	if (efi_enabled(EFI_RUNTIME_SERVICES))
		efi_enter_virtual_mode();
#endif
	thread_info_cache_init(); // null function
	cred_init();
	// credentials 를 사용하기 위한 kmem_cache 할당자 초기화 수행

	// totalram_pages: 총 free된 page 수
	fork_init(totalram_pages);
	// task_struct 를 사용하기 위한 kmem_cache 할당자 초기화 수행
	// max_threads값을 계산하여 init_task에 threads값의 limit 값 설정함

	proc_caches_init();
	// sighand_struct, signal_struct, files_struct, fs_struct, mm_struct, vm_area_struct, nsproxy
	// 를 사용하기 위한 kmem_cache 할당자 및 percpu list 초기화 수행

	buffer_init();
	// buffer_head 를 사용하기 위한 kmem_cache 할당자 및 max_buffer_heads 값 초기화 수행

	key_init(); // null funtion
	security_init(); // null funtion
	dbg_late_init(); // null funtion

	// totalram_pages: 총 free된 page 수
	vfs_caches_init(totalram_pages);
	// virtual file system을 위한 names, dentry, inode, filp, mount cache 생성 후
	// file system 을 위한 초기화 수행 및 mount 수행, block, char dev 사용을 위한 초기화 수행

	signals_init();
	// signal을 사용하기 위한 kmem_cache 를 생성

	/* rootfs populating might need page-writeback */
	page_writeback_init();
	// page writeback을 위한 global_dirty_limit, ratelimit_pages 값을 초기화 수행

#ifdef CONFIG_PROC_FS // CONFIG_PROC_FS=y
	proc_root_init();
#endif
```
