##### Neuromancer : 147 주차 
##### 일시        : 2016.06.11 (147주차 스터디 진행)
##### 모임명      : Kernelstudy.net
##### 장소        : 토즈 서현점
##### 장소지원    : 공개 소프트웨어 개발자 커뮤니티 지원 프로그램
##### 참여인원    : 2명
============

## 147주차 진도

* ᇂ147차 시작 위치
 - start_kernel        1  ~/init/main.c
   - proc_root_init    937  ~/init/main.c
      - proc_symlink      215  ~/proc/root.c
	    - __proc_create     597  ent = __proc_create(&parent, name,


#### 147주차 함수 호출 구조

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

* proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()

* call: proc_symlink()
 
## main.c::start_kernel()

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

```main.c
asmlinkage void __init start_kernel(void)
{
	char * command_line;
	extern const struct kernel_param __start___param[], __stop___param[];
	// ATAG,DTB 정보로 사용

...

    proc_caches_init();
	// sighand_struct, signal_struct, files_struct, fs_struct, mm_struct, vm_area_struct, nsproxy
	// 를 사용하기 위한 kmem_cache 할당자 및 percpu list 초기화 수행

...

	vfs_caches_init(totalram_pages);
	// virtual file system을 위한 names, dentry, inode, filp, mount cache 생성 후
	// file system 을 위한 초기화 수행 및 mount 수행, block, char dev 사용을 위한 초기화 수행

	signals_init();
	// signal을 사용하기 위한 kmem_cache 를 생성

	/* rootfs populating might need page-writeback */
	page_writeback_init();
	// page writeback을 위한 global_dirty_limit, ratelimit_pages 값을 초기화 수행

#ifdef CONFIG_PROC_FS // CONFIG_PROC_FS=y
	proc_root_init();
```

## root.c::proc_root_init()

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

* call: call_root_init()

```root.c
// ARM10C 20160604
void __init proc_root_init(void)
{
	int err;

	proc_init_inodecache();

	// proc_init_inodecache 에서 한일:
	// struct proc_inode 크기 만큼의 메모리를 할당항는 kmem_cache 할당자를 생성함
	// proc_inode_cachep: kmem_cache#n#28 (struct proc_inode)

	// register_filesystem(&proc_fs_type): 0
	err = register_filesystem(&proc_fs_type);
	// err: 0

	// register_filesystem에서 한일:
	// (&bd_type)->next: &proc_fs_type
	//
	// file system 연결 결과
	// file_systems: sysfs_fs_type -> rootfs_fs_type -> shmem_fs_type -> bd_type -> proc_fs_type

	// err: 0
	if (err)
		return;

	proc_self_init();

	// proc_self_init 에서 한일:
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 2 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object new 1번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object new 1         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL     |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 1)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8
	//
	// (&(&proc_inum_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// (&(&proc_inum_ida)->idr)->layers: 1
	// (&(&proc_inum_ida)->idr)->id_free: (idr object new 0)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 7
	//
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 1 bit를 1로 set 수행
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 2
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 1) 의 memory 공간을 반환함
	//
	// self_inum: 0xF0000001

	proc_symlink("mounts", NULL, "self/mounts");
```

## inode.c::proc_init_inodecache()

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

* proc_root_init()
 - proc_init_inodecache()

* struct proc_inode()

```internal.h
struct proc_inode {
	struct pid *pid;
	int fd;
	union proc_op op;
	struct proc_dir_entry *pde;
	struct ctl_table_header *sysctl;
	struct ctl_table *sysctl_entry;
	struct proc_ns ns;
	struct inode vfs_inode;
};
```

* SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD | SLAB_PANIC

```slab.h
#define SLAB_RECLAIM_ACCOUNT	0x00020000UL		/* Objects are reclaimable */
#define SLAB_MEM_SPREAD		0x00100000UL	/* Spread some memory over cpuset */
#define SLAB_PANIC		0x00040000UL	/* Panic if kmem_cache_create() fails */
```

```inode.c
void __init proc_init_inodecache(void)
{
	proc_inode_cachep = kmem_cache_create("proc_inode_cache",
					     sizeof(struct proc_inode),
					     0, (SLAB_RECLAIM_ACCOUNT|
						SLAB_MEM_SPREAD|SLAB_PANIC),
					     init_once);
}
```

* proc_init_inodecache() 가 한일 


## root.c::proc_root_init()

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

* proc_root_init()
 - proc_init_inodecache()

```root.c
void __init proc_root_init(void)
{
	int err;

	proc_init_inodecache();
	err = register_filesystem(&proc_fs_type);
```

## filesystem.c::register_filesystem()

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

* proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()

```root.c
static struct file_system_type proc_fs_type = {
	.name		= "proc",
	.mount		= proc_mount,
	.kill_sb	= proc_kill_sb,
	.fs_flags	= FS_USERNS_MOUNT,
};
```

```filesystems.c
// ARM10C 20160521
// &bd_type
int register_filesystem(struct file_system_type * fs)
{
	int res = 0;
	// res: 0

	struct file_system_type ** p;

	// fs->name: (&proc_fs_type)->name: "proc", strchr("proc", '.'): NULL
	BUG_ON(strchr(fs->name, '.'));

	// fs->next: (&proc_fs_type)->next: NULL
	if (fs->next)
		return -EBUSY;

	write_lock(&file_systems_lock);
	// write_lock에서 한일:
	// &file_systems_lock 을 사용한 write lock 수행

	// fs->name: (&proc_fs_type)->name: "proc", strlen("proc"): 4
	// find_filesystem("proc", 4): &(&bd-type)->next
	p = find_filesystem(fs->name, strlen(fs->name));
	// p: &file_systems
	// p: &(&sysfs_fs_type)->next
	// p: &(&rootfs_fs_type)->next
	// p: &(&shmem_fs_type)->next
	// p: &(&bd_type)->next
    
	// *p: file_systems: NULL
	// *p: (&sysfs_fs_type)->next: NULL
	// *p: (&rootfs_fs_type)->next: NULL
	// *p: (&shmem_fs_type)->next: NULL
	// *p: (&bd_type)->next: NULL
	if (*p)
		res = -EBUSY;
	else
		// *p: file_systems: NULL, fs: &sysfs_fs_type
		// *p: (&sysfs_fs_type)->next: NULL, fs: &rootfs_fs_type
		// *p: (&rootfs_fs_type)->next: NULL, fs: &shmem_fs_type
		// *p: (&shmem_fs_type)->next: NULL, fs: &bd_type
		// *p: (&bd_type)->next: NULL, fs: &proc_fs_type
		*p = fs;
		// *p: file_systems: &sysfs_fs_type
		// *p: (&sysfs_fs_type)->next: &rootfs_fs_type
		// *p: (&rootfs_fs_type)->next: &shmem_fs_type
		// *p: (&shmem_fs_type)->next: &bd_type
		// *p: (&bd_type)->next: &proc_fs_type
        
	write_unlock(&file_systems_lock);

	// write_unlock에서 한일:
	// &file_systems_lock 을 사용한 write lock 수행

	// res: 0
	return res;
	// return 0
}
```

* register_filesystem()이 한일

## root.c::proc_root_init()

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

* proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()

```root.c
void __init proc_root_init(void)
{
	int err;

	proc_init_inodecache();
	err = register_filesystem(&proc_fs_type);

	if (err)
		return;

	proc_self_init();
```

## self.c::proc_self_init()

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 
* call: proc_self_init()

```self.c
void __init proc_self_init(void)
{
	proc_alloc_inum(&self_inum);
}
```

## self.c::proc_self_init()

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

* call: proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()

* call: proc_self_init()

```generic.c
// ARM10C 20160514
// &new_ns->proc_inum: &(kmem_cache#30-oX (struct mnt_namespace))->proc_inum
int proc_alloc_inum(unsigned int *inum)
{
	unsigned int i;
	int error;

retry:
	// GFP_KERNEL: 0xD0, ida_pre_get(&proc_inum_ida, 0xD0): 1
	if (!ida_pre_get(&proc_inum_ida, GFP_KERNEL))
		return -ENOMEM;

	// ida_pre_get 에서 한일:
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-o0...7를 8 개를 할당 받음
	//
	// (&(&proc_inum_ida)->idr)->id_free 이 idr object 8 번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object 8         | idr object 7         | idr object 6         | idr object 5         | .... | idr object 0         |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object 7 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL         |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object 8)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 8

	spin_lock_irq(&proc_inum_lock);

	// spin_lock_irq 에서 한일:
	// &proc_inum_lock 을 사용하여 spin lock을 수행

	// ida_get_newa(&proc_inum_ida, &i): 0
	error = ida_get_new(&proc_inum_ida, &i);
	// error: 0

	// ida_get_new 에서 한일:
	// (&(&proc_inum_ida)->idr)->id_free: kmem_cache#21-oX (idr object 6)
	// (&(&proc_inum_ida)->idr)->id_free_cnt: 6
	// (&(&proc_inum_ida)->idr)->layers: 1
	// ((&(&proc_inum_ida)->idr)->top): kmem_cache#21-oX (idr object 8)
	//
	// (kmem_cache#21-oX (idr object 8))->layer: 0
	// kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// ((kmem_cache#21-oX (struct idr_layer) (idr object 8))->ary[0]): (typeof(*kmem_cache#27-oX (struct ida_bitmap)) __force space *)(kmem_cache#27-oX (struct ida_bitmap))
	// (kmem_cache#21-oX (struct idr_layer) (idr object 8))->count: 1
	//
	// (&proc_inum_ida)->free_bitmap: NULL
	// kmem_cache#27-oX (struct ida_bitmap) 메모리을 0으로 초기화
	// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 1
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 0 bit를 1로 set 수행
	//
	// i: 0
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object 7) 의 memory 공간을 반환함

	spin_unlock_irq(&proc_inum_lock);

	// spin_unlock_irq 에서 한일:
	// &proc_inum_lock 을 사용하여 spin lock을 수행

	// error: 0
	if (error == -EAGAIN)
		goto retry;
	else if (error)
		return error;

	// i: 0, UINT_MAX: 0xFFFFFFFF, PROC_DYNAMIC_FIRST: 0xF0000000
	if (i > UINT_MAX - PROC_DYNAMIC_FIRST) {
		spin_lock_irq(&proc_inum_lock);
		ida_remove(&proc_inum_ida, i);
		spin_unlock_irq(&proc_inum_lock);
		return -ENOSPC;
	}

	// *inum: (kmem_cache#30-oX (struct mnt_namespace))->proc_inum,
	// PROC_DYNAMIC_FIRST: 0xF0000000, i: 0
	*inum = PROC_DYNAMIC_FIRST + i;
	// *inum: (kmem_cache#30-oX (struct mnt_namespace))->proc_inum: 0xF0000000

	return 0;
	// return 0
}
```

## root.c::proc_root_init()

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

* proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()

```root.c
void __init proc_root_init(void)
{
	int err;

	proc_init_inodecache();
	err = register_filesystem(&proc_fs_type);
	if (err)
		return;

	proc_self_init();
	proc_symlink("mounts", NULL, "self/mounts");
```

## generic.c::proc_symlink()

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

* proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()

```generic.c
struct proc_dir_entry *proc_symlink(const char *name,
		struct proc_dir_entry *parent, const char *dest)
{
	struct proc_dir_entry *ent;

	ent = __proc_create(&parent, name,
			  (S_IFLNK | S_IRUGO | S_IWUGO | S_IXUGO),1);
```

## generic.c::__proc_create()

* calll: start_kernel()
 - page_writeback_init()
 - proc_root_init()

* proc_root_init()
 - proc_init_inodecache()
 - register_filesystem()
 - proc_self_init()
 - proc_symlink()

* call: proc_symlink()

```generic.c
static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,
					  const char *name,
					  umode_t mode,
					  nlink_t nlink)
{
	struct proc_dir_entry *ent = NULL;
	const char *fn = name;
	unsigned int len;

	/* make sure name is valid */
	if (!name || !strlen(name))
		goto out;

	if (xlate_proc_name(name, parent, &fn) != 0)
		goto out;

	/* At this point there must not be any '/' characters beyond *fn */
	if (strchr(fn, '/'))
		goto out;

	len = strlen(fn);

	ent = kzalloc(sizeof(struct proc_dir_entry) + len + 1, GFP_KERNEL);
	if (!ent)
		goto out;

	memcpy(ent->name, fn, len + 1);
	ent->namelen = len;
	ent->mode = mode;
	ent->nlink = nlink;
	atomic_set(&ent->count, 1);
	spin_lock_init(&ent->pde_unload_lock);
	INIT_LIST_HEAD(&ent->pde_openers);
out:
	return ent;
}
```

