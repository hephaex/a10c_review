##### KernelStudy : 136 주차 
##### 일시        : 2016.03.19 (136 주차 스터디 진행)
##### 모임명      : KernelStudy_ARM
##### 장소        : 토즈 서현점
##### 장소지원    : 공개 소프트웨어 개발자 커뮤니티 지원 프로그램
##### 참여인원    : 3명
============

## 136 주차 진도

* ᇂ136차 시작 위치
 - start_kernel        1  ~/init/main.c
 - vfs_caches_init   925  ~/init/main.c
 - mnt_init         3807  ~/fs/dcache.c
 - init_rootfs      4191  init_rootfs();
 - shmem_init        639  ~/init/do_mounts.c
 - kern_mount       2937  ~/mm/shmem.c
 - kern_mount_data  1968  ~/include/linux/fs.h
 - vfs_kern_mount   4215  // vfs_kern_mount(&shmem_fs_type, 0x400000, "tmpfs", NULL):
 - alloc_vfsmnt     1183  mnt = alloc_vfsmnt(name);

* 135주차 함수 호출 구조
 - 주석이 잘못 된부분을 발견해서 sysfs_init()를 수정.
 
* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()


* call: kobject_create_adn_add(): fs
 - 수정된 주석.
 - kobject_create()
 - kobject_add()

* call: kobject_add()
 - va_start()
 - kobject_add_varg()

* call: kobject_add_varg()
 - kobject_set_name_vargs()
 - kobject_add_internal()

* call: kobject_add_internal()
 - kobject_get()
  - 여기서 주석 수정
 - create_dir()
 - return: kobject_add_varg()
 
* return: kobject_add_internal() -> kobject_add_varg()
 - kobject_set_name_vargs()
 - kobject_add_internal()
 - return: kobejct_add()

* return: kobject_add() <- kobject_add_varg() <- kobject_add_internal()
 - va_start()
 - return: kobject_add_varg()
   - 주석 수정했음.
 - va_end()

* return: kobject_create_and_add() <- kobject_add() <- kobject_add_varg() <- kobject_add_internal()
 - kobject_set_name_vargs()
 - kobject_add()
 - return: mnt_init() 

* retrun: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - return: kobject_create_and_add() : fs
    - kobject_create_and_add() <- kobject_add() <- kobject_add_varg() <- kobject_add_internal()
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()

* call: vfs_kern_mount()
  - alloc_vfsmnt()

* call: alloc_vfsmnt()

## main.c::start_kernel()

* call: start_kernel()->vfs_caches_init()

```main.c
asmlinkage void __init start_kernel(void)
{
	char * command_line;
	extern const struct kernel_param __start___param[], __stop___param[];
	// ATAG,DTB 정보로 사용

...

    proc_caches_init();
	// sighand_struct, signal_struct, files_struct, fs_struct, mm_struct, vm_area_struct, nsproxy
	// 를 사용하기 위한 kmem_cache 할당자 및 percpu list 초기화 수행

	buffer_init();
	// buffer_head 를 사용하기 위한 kmem_cache 할당자 및 max_buffer_heads 값 초기화 수행

	key_init(); // null funtion
	security_init(); // null funtion
	dbg_late_init(); // null funtion

	// totalram_pages: 총 free된 page 수
	vfs_caches_init(totalram_pages);
```

## dcache.c::vfs_caches_init()

* call: start_kernel()
 - vfs_caches_init()

```dcache.c
// ARM10C 20151003
// totalram_pages: 총 free된 page 수
void __init vfs_caches_init(unsigned long mempages)
{
	unsigned long reserve;

	/* Base hash sizes on available memory, with a reserve equal to
           150% of current kernel size */

	// NOTE:
	// mempages 값과 nr_free_pages() 의 값을 정확히 알 수 없음
	// 계산된 reserve의 값을 XXX 로 함

	// mempages: 총 free된 page 수, nr_free_pages(): 현재의 free pages 수
	reserve = min((mempages - nr_free_pages()) * 3/2, mempages - 1);
	// reserve: XXX

	// mempages: 총 free된 page 수, reserve: XXX
	mempages -= reserve;
	// mempages: 총 free된 page 수 - XXX

	// PATH_MAX: 4096
	// SLAB_HWCACHE_ALIGN: 0x00002000UL, SLAB_PANIC: 0x00040000UL
	// kmem_cache_create("names_cache", 4096, 0, 0x42000, NULL): kmem_cache#6
	names_cachep = kmem_cache_create("names_cache", PATH_MAX, 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
	// names_cachep: kmem_cache#6

	dcache_init();

	// dcache_init에서 한일:
	//
	// struct dentry를 위한 kmem_cache 생성
	// dentry_cache: kmem_cache#5

	inode_init();

	// inode_init에서 한일:
	//
	// struct inode를 위한 kmem_cache 생성
	// inode_cachep: kmem_cache#4

	// mempages: 총 free된 page 수 - XXX
	files_init(mempages);

	// files_init에서 한일:
	//
	// filp_cachep: kmem_cache#3
	// files_stat.max_files: (총 free된 page 수 - XXX) * 4 / 10
	// sysctl_nr_open_max: 0x3FFFFFE0
	//
	// (&(&(&(&nr_files)->lock)->wait_lock)->rlock)->raw_lock: { { 0 } }
	// (&(&(&(&nr_files)->lock)->wait_lock)->rlock)->magic: 0xdead4ead
	// (&(&(&(&nr_files)->lock)->wait_lock)->rlock)->owner: 0xffffffff
	// (&(&(&(&nr_files)->lock)->wait_lock)->rlock)->owner_cpu: 0xffffffff
	// (&(&nr_files)->list)->next: &(&nr_files)->list
	// (&(&nr_files)->list)->prev: &(&nr_files)->list
	// (&nr_files)->count: 0
	// (&nr_files)->counters: kmem_cache#26-o0 에서 할당된 4 bytes 메모리 주소
	// list head 인 &percpu_counters에 &(&nr_files)->list를 연결함

	mnt_init();
```

## namespace.c::mnt_init()

* call: start_kernel()
  - vfs_caches_init()

* call: vfs_caches_init()
  - kmem_cache_create(): names_cache
  - dcache_init()
  - inode_init()
  - files_init()
  - mnt_init()

```namespace.c
// ARM10C 20151024
void __init mnt_init(void)
{
	unsigned u;
	int err;
	// sizeof(struct mount): 152 bytes, SLAB_HWCACHE_ALIGN: 0x00002000UL, SLAB_PANIC: 0x00040000UL
	// kmem_cache_create("mnt_cache", 152, 0, 0x42000, NULL): kmem_cache#2
	mnt_cache = kmem_cache_create("mnt_cache", sizeof(struct mount),
			0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);
	// mnt_cache: kmem_cache#2

	// sizeof(struct hlist_head): 4 bytes, mhash_entries: 0
	// alloc_large_system_hash("Mount-cache", 4, 0, 19, 0, &m_hash_shift, &m_hash_mask, 0, 0): 16kB만큼 할당받은 메모리 주소
	mount_hashtable = alloc_large_system_hash("Mount-cache",
				sizeof(struct hlist_head),
				mhash_entries, 19,
				0,
				&m_hash_shift, &m_hash_mask, 0, 0);
	// mount_hashtable: 16kB만큼 할당받은 메모리 주소

	// sizeof(struct hlist_head): 4 bytes, mphash_entries: 0
	// alloc_large_system_hash("Mountpoint-cache", 4, 0, 19, 0, &m_hash_shift, &m_hash_mask, 0, 0): 16kB만큼 할당받은 메모리 주소
	mountpoint_hashtable = alloc_large_system_hash("Mountpoint-cache",
				sizeof(struct hlist_head),
				mphash_entries, 19,
				0,
				&mp_hash_shift, &mp_hash_mask, 0, 0);
	// mountpoint_hashtable: 16kB만큼 할당받은 메모리 주소

	// mount_hashtable: 16kB만큼 할당받은 메모리 주소, mountpoint_hashtable: 16kB만큼 할당받은 메모리 주소
	if (!mount_hashtable || !mountpoint_hashtable)
		panic("Failed to allocate mount hash table\n");

	// m_hash_mask: 0xFFF
	for (u = 0; u <= m_hash_mask; u++)
		// u: 0
		INIT_HLIST_HEAD(&mount_hashtable[u]);

		// INIT_HLIST_HEAD 에서 한일:
		// ((&mount_hashtable[0])->first = NULL)

		// u: 1...4095 까지 loop 수행

	// mp_hash_mask: 0xFFF
	for (u = 0; u <= mp_hash_mask; u++)
		// u: 0
		INIT_HLIST_HEAD(&mountpoint_hashtable[u]);

		// INIT_HLIST_HEAD 에서 한일:
		// ((&mountpoint_hashtable[0])->first = NULL)

		// u: 1...4095 까지 loop 수행

	// sysfs_init(): 0
	err = sysfs_init();
	// err: 0

	// err: 0
	if (err)
		printk(KERN_WARNING "%s: sysfs_init error: %d\n",
			__func__, err);

	// kobject_create_and_add("fs", NULL): kmem_cache#30-oX (struct kobject)
	fs_kobj = kobject_create_and_add("fs", NULL);
	// fs_kobj: kmem_cache#30-oX (struct kobject)

	// fs_kobj: kmem_cache#30-oX (struct kobject)
	if (!fs_kobj)
		printk(KERN_WARNING "%s: kobj create error\n", __func__);

	init_rootfs();
```

## do_mounts.c::init_rootfs()

* call: start_kernel()
  - vfs_caches_init()

* call: start_kernel()->vfs_caches_init()
  - kmem_cache_create(): names_cache
  - dcache_init()
  - inode_init()
  - files_init()
  - mnt_init()

* call: start_kernel()->vfs_caches_init()->mnt_init()
  - kmem_cache_create(): mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

```do_mounts.c
// ARM10C 20160123
int __init init_rootfs(void)
{
	// register_filesystem(&rootfs_fs_type): 0
	int err = register_filesystem(&rootfs_fs_type);
	// err: 0

	// register_filesystem에서 한일:
	// (&sysfs_fs_type)->next: &rootfs_fs_type

	// err: 0
	if (err)
		return err;

	// CONFIG_TMPFS: y, IS_ENABLED(CONFIG_TMPFS): 1, saved_root_name[0]: 0,
	// root_fs_names: NULL, strstr(NULL, "tmpfs"): NULL
	if (IS_ENABLED(CONFIG_TMPFS) && !saved_root_name[0] &&
		(!root_fs_names || strstr(root_fs_names, "tmpfs"))) {
		err = shmem_init();
```

## shmem.c::shmem_init()

* call: start_kernel()
  - vfs_caches_init()

* call: start_kernel()->vfs_caches_init()
  - kmem_cache_create(): names_cache
  - dcache_init()
  - inode_init()
  - files_init()
  - mnt_init()

* call: start_kernel()->vfs_caches_init()->mnt_init()
  - kmem_cache_create(): mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()
  - register_filesystem(): rootfs_fs_type
  - shmem_init()
	
* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()->shmem_init()
  - bdi_init(): shmem_backing_dev_info
  - shmem_init_inodecache()
  - register_filesystem(): shmem_fs_type
  - kern_mount(): shmem_fs_type

```shmem.c
// ARM10C 20160123
int __init shmem_init(void)
{
	int error;

	/* If rootfs called this, don't re-init */
	// shmem_inode_cachep: NULL
	if (shmem_inode_cachep)
		return 0;

	// bdi_init(&shmem_backing_dev_info): 0
	error = bdi_init(&shmem_backing_dev_info);
	// error: 0

	// error: 0
	if (error)
		goto out4;

	// shmem_init_inodecache(): 0
	error = shmem_init_inodecache();
	// error: 0

	// shmem_init_inodecache에서 한일:
	// struct shmem_inode_info 의 type의 메모리 할당하는 kmem_cache를 생성함
	// shmem_inode_cachep: kmem_cache#0

	// error: 0
	if (error)
		goto out3;

	// register_filesystem(&shmem_fs_type): 0
	error = register_filesystem(&shmem_fs_type);
	// error: 0

	// register_filesystem에서 한일:
	// (&rootfs_fs_type)->next: &shmem_fs_type

	// error: 0
	if (error) {
		printk(KERN_ERR "Could not register tmpfs\n");
		goto out2;
	}

	shm_mnt = kern_mount(&shmem_fs_type);
```

## fs.h::kern_mount()

* call: start_kernel()
  - vfs_caches_init()

* call: start_kernel()->vfs_caches_init()
  - kmem_cache_create(): names_cache
  - dcache_init()
  - inode_init()
  - files_init()
  - mnt_init()

* call: start_kernel()->vfs_caches_init()->mnt_init()
  - kmem_cache_create(): mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()
  - register_filesystem(): rootfs_fs_type
  - shmem_init()
	
* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()->shmem_init()
  - bdi_init(): shmem_backing_dev_info
  - shmem_init_inodecache()
  - register_filesystem(): shmem_fs_type
  - kern_mount(): shmem_fs_type

```fs.h
// ARM10C 20151031
// &sysfs_fs_type
#define kern_mount(type) kern_mount_data(type, NULL)
```

## namespace.c::kern_mount_data()

* call: start_kernel()
  - vfs_caches_init()

* call: start_kernel()->vfs_caches_init()
  - kmem_cache_create(): names_cache
  - dcache_init()
  - inode_init()
  - files_init()
  - mnt_init()

* call: start_kernel()->vfs_caches_init()->mnt_init()
  - kmem_cache_create(): mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()
  - register_filesystem(): rootfs_fs_type
  - shmem_init()
	
* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()->shmem_init()
  - bdi_init(): shmem_backing_dev_info
  - shmem_init_inodecache()
  - register_filesystem(): shmem_fs_type
  - kern_mount(): shmem_fs_type :: kern_mount_data()
  	
* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()->shmem_init()->kern_mount_data()
  - vfs_kern_mount()

* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()->shmem_init()->kern_mount_data()->vfs_kern_mount()

```namespace.c
// ARM10C 20151031
// &sysfs_fs_type, NULL
struct vfsmount *kern_mount_data(struct file_system_type *type, void *data)
{
	struct vfsmount *mnt;

	// type: &sysfs_fs_type, MS_KERNMOUNT: 0x400000, type->name: (&sysfs_fs_type)->name: "sysfs", data: NULL
	// vfs_kern_mount(&sysfs_fs_type, 0x400000, "sysfs", NULL): &(kmem_cache#2-oX (struct mount))->mnt
	mnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, data);
```

## namespace.c::vfs_kern_mount()

* call: start_kernel()
  - vfs_caches_init()

* call: start_kernel()->vfs_caches_init()
  - kmem_cache_create(): names_cache
  - dcache_init()
  - inode_init()
  - files_init()
  - mnt_init()

* call: start_kernel()->vfs_caches_init()->mnt_init()
  - kmem_cache_create(): mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()
  - register_filesystem(): rootfs_fs_type
  - shmem_init()
	
* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()->shmem_init()
  - bdi_init(): shmem_backing_dev_info
  - shmem_init_inodecache()
  - register_filesystem(): shmem_fs_type
  - kern_mount(): shmem_fs_type :: kern_mount_data()
  	
* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()->shmem_init()->kern_mount_data()
  - vfs_kern_mount()

* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()->shmem_init()->kern_mount_data()->vfs_kern_mount()

```namespace.c
// ARM10C 20151031
// type: &sysfs_fs_type, MS_KERNMOUNT: 0x400000, type->name: (&sysfs_fs_type)->name: "sysfs", data: NULL
struct vfsmount *
vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)
{
	struct mount *mnt;
	struct dentry *root;

	// type: &sysfs_fs_type
	if (!type)
		return ERR_PTR(-ENODEV);

	// name: "sysfs", alloc_vfsmnt("sysfs"): kmem_cache#2-oX (struct mount)
	mnt = alloc_vfsmnt(name);
```

## namespace.c::alloc_vfsmnt()

* call: start_kernel()
  - vfs_caches_init()

* call: start_kernel()->vfs_caches_init()
  - kmem_cache_create(): names_cache
  - dcache_init()
  - inode_init()
  - files_init()
  - mnt_init()

* call: start_kernel()->vfs_caches_init()->mnt_init()
  - kmem_cache_create(): mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()
  - register_filesystem(): rootfs_fs_type
  - shmem_init()
	
* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()->shmem_init()
  - bdi_init(): shmem_backing_dev_info
  - shmem_init_inodecache()
  - register_filesystem(): shmem_fs_type
  - kern_mount(): shmem_fs_type :: kern_mount_data()
  	
* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()->shmem_init()->kern_mount_data()
  - vfs_kern_mount()

* call: start_kernel()->vfs_caches_init()->mnt_init()->init_rootfs()->shmem_init()->kern_mount_data()->vfs_kern_mount()

```namespace.c
// ARM10C 20151031
// name: "sysfs"
// ARM10C 20160213
// name: "tmpfs"
static struct mount *alloc_vfsmnt(const char *name)
{
	// mnt_cache: kmem_cache#2, GFP_KERNEL: 0xD0
	// kmem_cache_zalloc(kmem_cache#2, 0xD0): kmem_cache#2-oX (struct mount)
	// mnt_cache: kmem_cache#2, GFP_KERNEL: 0xD0
	// kmem_cache_zalloc(kmem_cache#2, 0xD0): kmem_cache#2-oX (struct mount)
	struct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);
	// mnt: kmem_cache#2-oX (struct mount)
	// mnt: kmem_cache#2-oX (struct mount)

	// mnt: kmem_cache#2-oX (struct mount)
	// mnt: kmem_cache#2-oX (struct mount)
	if (mnt) {
		int err;

		// mnt: kmem_cache#2-oX (struct mount)
		// mnt_alloc_id(kmem_cache#2-oX (struct mount)): 0
		// mnt: kmem_cache#2-oX (struct mount)
		// mnt_alloc_id(kmem_cache#2-oX (struct mount)): 0
		err = mnt_alloc_id(mnt);
		// err: 0
		// err: 0

		// mnt_alloc_id에서 한일:
		// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-o0...7를 8 개를 할당 받음
		//
		// (&(&mnt_id_ida)->idr)->id_free 이 idr object 8 번을 가르킴
		// |
		// |-> ---------------------------------------------------------------------------------------------------------------------------
		//     | idr object 8         | idr object 7         | idr object 6         | idr object 5         | .... | idr object 0         |
		//     ---------------------------------------------------------------------------------------------------------------------------
		//     | ary[0]: idr object 7 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL         |
		//     ---------------------------------------------------------------------------------------------------------------------------
		//
		// (&(&mnt_id_ida)->idr)->id_free: kmem_cache#21-oX (idr object 8)
		// (&(&mnt_id_ida)->idr)->id_free_cnt: 8
		//
		// struct ida_bitmap 의 메모리 kmem_cache#27-oX 할당 받음
		// (&mnt_id_ida)->free_bitmap: kmem_cache#27-oX (struct ida_bitmap)
		//
		// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object 7) 의 memory 공간을 반환함
		//
		// (&(&mnt_id_ida)->idr)->id_free: kmem_cache#21-oX (idr object 6)
		// (&(&mnt_id_ida)->idr)->id_free_cnt: 6
		// (&(&mnt_id_ida)->idr)->layers: 1
		// ((&(&mnt_id_ida)->idr)->top): kmem_cache#21-oX (idr object 8)
		//
		// (kmem_cache#21-oX (idr object 8))->layer: 0
		// kmem_cache#21-oX (struct idr_layer) (idr object 8)
		// ((kmem_cache#21-oX (struct idr_layer) (idr object 8))->ary[0]): (typeof(*kmem_cache#27-oX (struct ida_bitmap)) __force space *)(kmem_cache#27-oX (struct ida_bitmap))
		// (kmem_cache#21-oX (struct idr_layer) (idr object 8))->count: 1
		//
		// (&mnt_id_ida)->free_bitmap: NULL
		// kmem_cache#27-oX (struct ida_bitmap) 메모리을 0으로 초기화
		// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 0 bit를 1로 set 수행
		// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 1
		//
		// (kmem_cache#2-oX (struct mount))->mnt_id: 0
		//
		// mnt_id_start: 1

		// mnt_alloc_id에서 한일:
		// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-oX를 2 개를 할당 받음
		//
		// (&(&mnt_id_ida)->idr)->id_free 이 idr object new 1번을 가르킴
		// |
		// |-> ---------------------------------------------------------------------------------------------------------------------------
		//     | idr object new 1         | idr object new 0     | idr object 6         | idr object 5         | .... | idr object 0         |
		//     ---------------------------------------------------------------------------------------------------------------------------
		//     | ary[0]: idr object new 0 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL         |
		//     ---------------------------------------------------------------------------------------------------------------------------
		//
		// (&(&mnt_id_ida)->idr)->id_free: kmem_cache#21-oX (idr object new 1)
		// (&(&mnt_id_ida)->idr)->id_free_cnt: 8
		//
		// struct ida_bitmap 의 메모리 kmem_cache#27-oX 할당 받음
		// (&mnt_id_ida)->free_bitmap: kmem_cache#27-oX (struct ida_bitmap)
		//
		// (&(&mnt_id_ida)->idr)->top: kmem_cache#21-oX (struct idr_layer) (idr object 8)
		// (&(&mnt_id_ida)->idr)->layers: 1
		// (&(&mnt_id_ida)->idr)->id_free: (idr object new 0)
		// (&(&mnt_id_ida)->idr)->id_free_cnt: 7
		//
		// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 1 bit를 1로 set 수행
		// (kmem_cache#27-oX (struct ida_bitmap))->nr_busy: 2
		//
		// (kmem_cache#2-oX (struct mount))->mnt_id: 1
		//
		// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object new 1) 의 memory 공간을 반환함
		//
		// mnt_id_start: 2

		// err: 0
		// err: 0
		if (err)
			goto out_free_cache;

// 2016/03/05 종료

		// name: "sysfs"
		if (name) {
			// mnt->mnt_devname: (kmem_cache#2-oX (struct mount))->mnt_devname, name: "sysfs", GFP_KERNEL: 0xD0
			// kstrdup("sysfs", GFP_KERNEL: 0xD0): kmem_cache#30-oX: "sysfs"
			mnt->mnt_devname = kstrdup(name, GFP_KERNEL);
			// mnt->mnt_devname: (kmem_cache#2-oX (struct mount))->mnt_devname: kmem_cache#30-oX: "sysfs"

			// mnt->mnt_devname: (kmem_cache#2-oX (struct mount))->mnt_devname: kmem_cache#30-oX: "sysfs"
			if (!mnt->mnt_devname)
				goto out_free_id;
		}

#ifdef CONFIG_SMP // CONFIG_SMP=y
		// mnt->mnt_pcp: (kmem_cache#2-oX (struct mount))->mnt_pcp, sizeof(struct mnt_pcp): 8 bytes
		// alloc_percpu(struct mnt_pcp): kmem_cache#26-o0 에서 할당된 8 bytes 메모리 주소
		mnt->mnt_pcp = alloc_percpu(struct mnt_pcp);
		// mnt->mnt_pcp: (kmem_cache#2-oX (struct mount))->mnt_pcp: kmem_cache#26-o0 에서 할당된 8 bytes 메모리 주소

		// mnt->mnt_pcp: (kmem_cache#2-oX (struct mount))->mnt_pcp: kmem_cache#26-o0 에서 할당된 8 bytes 메모리 주소
		if (!mnt->mnt_pcp)
			goto out_free_devname;

		// mnt->mnt_pcp->mnt_count: (kmem_cache#2-oX (struct mount))->mnt_pcp->mnt_count
		this_cpu_add(mnt->mnt_pcp->mnt_count, 1);
		// [pcp0] mnt->mnt_pcp->mnt_count: (kmem_cache#2-oX (struct mount))->mnt_pcp->mnt_count: 1
#else
		mnt->mnt_count = 1;
		mnt->mnt_writers = 0;
#endif

		// mnt->mnt_hash: (kmem_cache#2-oX (struct mount))->mnt_hash
		INIT_HLIST_NODE(&mnt->mnt_hash);

		// INIT_HLIST_NODE에서 한일:
		// ((kmem_cache#2-oX (struct mount))->mnt_hash)->next: NULL
		// ((kmem_cache#2-oX (struct mount))->mnt_hash)->pprev: NULL

		// mnt->mnt_child: (kmem_cache#2-oX (struct mount))->mnt_child
		INIT_LIST_HEAD(&mnt->mnt_child);

		// INIT_LIST_HEAD에서 한일:
		// ((kmem_cache#2-oX (struct mount))->mnt_child)->next: (kmem_cache#2-oX (struct mount))->mnt_child
		// ((kmem_cache#2-oX (struct mount))->mnt_child)->prev: (kmem_cache#2-oX (struct mount))->mnt_child

		// mnt->mnt_mounts: (kmem_cache#2-oX (struct mount))->mnt_mounts
		INIT_LIST_HEAD(&mnt->mnt_mounts);

		// INIT_LIST_HEAD에서 한일:
		// ((kmem_cache#2-oX (struct mount))->mnt_mounts)->next: (kmem_cache#2-oX (struct mount))->mnt_mounts
		// ((kmem_cache#2-oX (struct mount))->mnt_mounts)->prev: (kmem_cache#2-oX (struct mount))->mnt_mounts
		
		// mnt->mnt_list: (kmem_cache#2-oX (struct mount))->mnt_list
		INIT_LIST_HEAD(&mnt->mnt_list);

		// INIT_LIST_HEAD에서 한일:
		// ((kmem_cache#2-oX (struct mount))->mnt_list)->next: (kmem_cache#2-oX (struct mount))->mnt_list
		// ((kmem_cache#2-oX (struct mount))->mnt_list)->prev: (kmem_cache#2-oX (struct mount))->mnt_list

		// mnt->mnt_expire: (kmem_cache#2-oX (struct mount))->mnt_expire
		INIT_LIST_HEAD(&mnt->mnt_expire);

		// INIT_LIST_HEAD에서 한일:
		// ((kmem_cache#2-oX (struct mount))->mnt_expire)->next: (kmem_cache#2-oX (struct mount))->mnt_expire
		// ((kmem_cache#2-oX (struct mount))->mnt_expire)->prev: (kmem_cache#2-oX (struct mount))->mnt_expire

		// mnt->mnt_share: (kmem_cache#2-oX (struct mount))->mnt_share
		INIT_LIST_HEAD(&mnt->mnt_share);

		// INIT_LIST_HEAD에서 한일:
		// ((kmem_cache#2-oX (struct mount))->mnt_share)->next: (kmem_cache#2-oX (struct mount))->mnt_share
		// ((kmem_cache#2-oX (struct mount))->mnt_share)->prev: (kmem_cache#2-oX (struct mount))->mnt_share

		// mnt->mnt_slave_list: (kmem_cache#2-oX (struct mount))->mnt_slave_list
		INIT_LIST_HEAD(&mnt->mnt_slave_list);

		// INIT_LIST_HEAD에서 한일:
		// ((kmem_cache#2-oX (struct mount))->mnt_slave_list)->next: (kmem_cache#2-oX (struct mount))->mnt_slave_list
		// ((kmem_cache#2-oX (struct mount))->mnt_slave_list)->prev: (kmem_cache#2-oX (struct mount))->mnt_slave_list

		// mnt->mnt_slave: (kmem_cache#2-oX (struct mount))->mnt_slave
		INIT_LIST_HEAD(&mnt->mnt_slave);

		// INIT_LIST_HEAD에서 한일:
		// ((kmem_cache#2-oX (struct mount))->mnt_slave)->next: (kmem_cache#2-oX (struct mount))->mnt_slave
		// ((kmem_cache#2-oX (struct mount))->mnt_slave)->prev: (kmem_cache#2-oX (struct mount))->mnt_slave

#ifdef CONFIG_FSNOTIFY // CONFIG_FSNOTIFY=y
		// mnt->mnt_fsnotify_marks: (kmem_cache#2-oX (struct mount))->mnt_fsnotify_marks
		INIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);

		// INIT_HLIST_HEAD에서 한일:
		// ((kmem_cache#2-oX (struct mount))->mnt_fsnotify_marks)->first: NULL
#endif
	}

	// mnt: kmem_cache#2-oX (struct mount)
	return mnt;
	// return kmem_cache#2-oX (struct mount)

#ifdef CONFIG_SMP
out_free_devname:
	kfree(mnt->mnt_devname);
#endif
out_free_id:
	mnt_free_id(mnt);
out_free_cache:
	kmem_cache_free(mnt_cache, mnt);
	return NULL;
}
```

## namespace.c::vfs_kern_mount()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - return: alloc_vfsmnt()

```namespace.c
// ARM10C 20160213
// type: &shmem_fs_type, MS_KERNMOUNT: 0x400000, type->name: (&shmem_fs_type)->name: "tmpfs", data: NULL
struct vfsmount *
vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)
{
	struct mount *mnt;
	struct dentry *root;

	// type: &sysfs_fs_type
	// type: &shmem_fs_type
	if (!type)
		return ERR_PTR(-ENODEV);

	// name: "sysfs", alloc_vfsmnt("sysfs"): kmem_cache#2-oX (struct mount)
	// name: "tmpfs", alloc_vfsmnt("tmpfs"):
	mnt = alloc_vfsmnt(name);
	// mnt: kmem_cache#2-oX (struct mount)

	// mnt: kmem_cache#2-oX (struct mount)
	if (!mnt)
		return ERR_PTR(-ENOMEM);

// 2015/11/07 종료
// 2015/11/14 시작

	// flags: 0x400000, MS_KERNMOUNT: 0x400000
	if (flags & MS_KERNMOUNT)
		// mnt->mnt.mnt_flags: (kmem_cache#2-oX (struct mount))->mnt.mnt_flags, MNT_INTERNAL: 0x4000
		mnt->mnt.mnt_flags = MNT_INTERNAL;
		// mnt->mnt.mnt_flags: (kmem_cache#2-oX (struct mount))->mnt.mnt_flags: 0x4000

	// type: &sysfs_fs_type, flags: 0x400000, name: "sysfs", data: NULL
	// mount_fs(&sysfs_fs_type, 0x400000, "sysfs", NULL): kmem_cache#5-oX (struct dentry)
	root = mount_fs(type, flags, name, data);
	// root: kmem_cache#5-oX (struct dentry)
```

## namespace.c::mount_fs()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

```super.c
// ARM10C 20151114
// type: &sysfs_fs_type, flags: 0x400000, name: "sysfs", data: NULL
struct dentry *
mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
{
	struct dentry *root;
	struct super_block *sb;
	char *secdata = NULL;
	// secdata: NULL

	// ENOMEM: 12
	int error = -ENOMEM;
	// error: -12

	// data: NULL, type->fs_flags: (&sysfs_fs_type)->fs_flags: 8, FS_BINARY_MOUNTDATA: 2
	if (data && !(type->fs_flags & FS_BINARY_MOUNTDATA)) {
		secdata = alloc_secdata();
		if (!secdata)
			goto out;

		error = security_sb_copy_data(data, secdata);
		if (error)
			goto out_free_secdata;
	}

	// type->mount: (&sysfs_fs_type)->mount: sysfs_mount
	// type: &sysfs_fs_type, flags: 0x400000, name: "sysfs", data: NULL
	// sysfs_mount(&sysfs_fs_type, 0x400000, "sysfs", NULL): kmem_cache#5-oX (struct dentry)
	root = type->mount(type, flags, name, data);
	// root: kmem_cache#5-oX (struct dentry)
```

## shmem.c::shmem_mount()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

```shmem.c
static struct dentry *shmem_mount(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data)
{
	return mount_nodev(fs_type, flags, data, shmem_fill_super);
}
```

## super.c::mount_nodev()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

```super.c
struct dentry *mount_nodev(struct file_system_type *fs_type,
	int flags, void *data,
	int (*fill_super)(struct super_block *, void *, int))
{
	int error;
	struct super_block *s = sget(fs_type, NULL, set_anon_super, flags, NULL);

	if (IS_ERR(s))
		return ERR_CAST(s);

	error = fill_super(s, data, flags & MS_SILENT ? 1 : 0);
	if (error) {
		deactivate_locked_super(s);
		return ERR_PTR(error);
	}
	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);
}
EXPORT_SYMBOL(mount_nodev);
```

## super.c::sget()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()

```super.c
// ARM10C 20151114
// fs_type: &sysfs_fs_type, sysfs_test_super, sysfs_set_super, flags: 0x400000, info: kmem_cache#30-oX (struct sysfs_super_info)
struct super_block *sget(struct file_system_type *type,
			int (*test)(struct super_block *,void *),
			int (*set)(struct super_block *,void *),
			int flags,
			void *data)
{
	struct super_block *s = NULL;
	// s: NULL

	struct super_block *old;
	int err;

retry:
	spin_lock(&sb_lock);

	// spin_lock에서 한일:
	// &sb_lock 을 사용한 spin lock 수행

	// [re] spin_lock에서 한일:
	// [re] &sb_lock 을 사용한 spin lock 수행

	// test: sysfs_test_super
	// [re] test: sysfs_test_super
	if (test) {
		// &type->fs_supers: &(&sysfs_fs_type)->fs_supers
		// hlist_entry_safe((&(&sysfs_fs_type)->fs_supers)->first, struct super_block, s_instances): NULL
		// [re] &type->fs_supers: &(&sysfs_fs_type)->fs_supers
		// [re] hlist_entry_safe((&(&sysfs_fs_type)->fs_supers)->first, struct super_block, s_instances): NULL
		hlist_for_each_entry(old, &type->fs_supers, s_instances) {
		// for (old = hlist_entry_safe((&type->fs_supers)->first, typeof(*(old)), s_instances);
		//      old; old = hlist_entry_safe((old)->s_instances.next, typeof(*(old)), s_instances))

			if (!test(old, data))
				continue;
			if (!grab_super(old))
				goto retry;
			if (s) {
				up_write(&s->s_umount);
				destroy_super(s);
				s = NULL;
			}
			return old;
		}
	}

	// s: NULL
	// [re] s: kmem_cache#25-oX (struct super_block)
	if (!s) {
		spin_unlock(&sb_lock);

		// spin_unlock에서 한일:
		// &sb_lock 을 사용한 spin unlock 수행

		// type: &sysfs_fs_type, flags: 0x400000
		// alloc_super(&sysfs_fs_type, 0x400000): kmem_cache#25-oX (struct super_block)
		s = alloc_super(type, flags);
		// s: kmem_cache#25-oX (struct super_block)

		// alloc_super에서 한일:
		// struct super_block 만큼의 메모리를 할당 받음 kmem_cache#25-oX (struct super_block)
		//
		// (&(&(&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0...2])->lock)->wait_lock)->rlock)->raw_lock: { { 0 } }
		// (&(&(&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0...2])->lock)->wait_lock)->rlock)->magic: 0xdead4ead
		// (&(&(&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0...2])->lock)->wait_lock)->rlock)->owner: 0xffffffff
		// (&(&(&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0...2])->lock)->wait_lock)->rlock)->owner_cpu: 0xffffffff
		// (&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0...2])->list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0...2])->list
		// (&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0...2])->list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0...2])->list
		// (&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0...2])->count: 0
		// (&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0...2])->counters: kmem_cache#26-o0 에서 할당된 4 bytes 메모리 주소
		// list head 인 &percpu_counters에 &(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0...2])->list를 연결함
		//
		// &(&(kmem_cache#25-oX (struct super_block))->s_writers.wait)->lock을 사용한 spinlock 초기화
		// &(&(kmem_cache#25-oX (struct super_block))->s_writers.wait)->task_list를 사용한 list 초기화
		// &(&(kmem_cache#25-oX (struct super_block))->s_writers.wait_unfrozen)->lock을 사용한 spinlock 초기화
		// &(&(kmem_cache#25-oX (struct super_block))->s_writers.wait_unfrozen)->task_list를 사용한 list 초기화
		//
		// (&(kmem_cache#25-oX (struct super_block))->s_instances)->next: NULL
		// (&(kmem_cache#25-oX (struct super_block))->s_instances)->pprev: NULL
		// (&(kmem_cache#25-oX (struct super_block))->s_anon)->first: NULL
		//
		// (&(kmem_cache#25-oX (struct super_block))->s_inodes)->next: &(kmem_cache#25-oX (struct super_block))->s_inodes
		// (&(kmem_cache#25-oX (struct super_block))->s_inodes)->prev: &(kmem_cache#25-oX (struct super_block))->s_inodes
		//
		// (&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node: kmem_cache#30-oX
		// (&(&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->active_nodes)->bits[0]: 0
		// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].lock)->raw_lock: { { 0 } }
		// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].lock)->magic: 0xdead4ead
		// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].lock)->owner: 0xffffffff
		// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].lock)->owner_cpu: 0xffffffff
		// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].list)->next: (&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].list
		// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].list)->prev: (&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].list
		// (&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].nr_items: 0
		// (&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node: kmem_cache#30-oX
		// (&(&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->active_nodes)->bits[0]: 0
		// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].lock)->raw_lock: { { 0 } }
		// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].lock)->magic: 0xdead4ead
		// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].lock)->owner: 0xffffffff
		// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].lock)->owner_cpu: 0xffffffff
		// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].list)->next: (&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].list
		// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].list)->prev: (&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].list
		// (&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].nr_items: 0
		//
		// (&(kmem_cache#25-oX (struct super_block))->s_mounts)->next: &(kmem_cache#25-oX (struct super_block))->s_mounts
		// (&(kmem_cache#25-oX (struct super_block))->s_mounts)->prev: &(kmem_cache#25-oX (struct super_block))->s_mounts
		//
		// (&(kmem_cache#25-oX (struct super_block))->s_umount)->activity: 0
		// &(&(kmem_cache#25-oX (struct super_block))->s_umount)->wait_lock을 사용한 spinlock 초기화
		// (&(&(kmem_cache#25-oX (struct super_block))->s_umount)->wait_list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_umount)->wait_list
		// (&(&(kmem_cache#25-oX (struct super_block))->s_umount)->wait_list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_umount)->wait_list
		//
		// (&(kmem_cache#25-oX (struct super_block))->s_umount)->activity: -1
		//
		// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->count: 1
		// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_lock)->rlock)->raw_lock: { { 0 } }
		// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_lock)->rlock)->magic: 0xdead4ead
		// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_lock)->rlock)->owner: 0xffffffff
		// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_lock)->rlock)->owner_cpu: 0xffffffff
		// (&(&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_list
		// (&(&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_list
		// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->onwer: NULL
		// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->magic: &(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->count: 1
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_lock)->rlock)->raw_lock: { { 0 } }
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_lock)->rlock)->magic: 0xdead4ead
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_lock)->rlock)->owner: 0xffffffff
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_lock)->rlock)->owner_cpu: 0xffffffff
		// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_list
		// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_list
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->onwer: NULL
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->magic: &(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->count: 1
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_lock)->rlock)->raw_lock: { { 0 } }
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_lock)->rlock)->magic: 0xdead4ead
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_lock)->rlock)->owner: 0xffffffff
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_lock)->rlock)->owner_cpu: 0xffffffff
		// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_list
		// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_list
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->onwer: NULL
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->magic: &(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex
		// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->activity: 0
		// &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->wait_lock을 사용한 spinlock 초기화
		// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->wait_list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->wait_list
		// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->wait_list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->wait_list
		//
		// (kmem_cache#25-oX (struct super_block))->s_flags: 0x400000
		// (kmem_cache#25-oX (struct super_block))->s_bdi: &default_backing_dev_info
		// (kmem_cache#25-oX (struct super_block))->s_count: 1
		// ((kmem_cache#25-oX (struct super_block))->s_active)->counter: 1
		// (kmem_cache#25-oX (struct super_block))->s_maxbytes: 0x7fffffff
		// (kmem_cache#25-oX (struct super_block))->s_op: &default_op
		// (kmem_cache#25-oX (struct super_block))->s_time_gran: 1000000000
		// (kmem_cache#25-oX (struct super_block))->cleancache_poolid: -1
		// (kmem_cache#25-oX (struct super_block))->s_shrink.seeks: 2
		// (kmem_cache#25-oX (struct super_block))->s_shrink.scan_objects: super_cache_scan
		// (kmem_cache#25-oX (struct super_block))->s_shrink.count_objects: super_cache_count
		// (kmem_cache#25-oX (struct super_block))->s_shrink.batch: 1024
		// (kmem_cache#25-oX (struct super_block))->s_shrink.flags: 1

		// s: kmem_cache#25-oX (struct super_block)
		if (!s)
			return ERR_PTR(-ENOMEM);
		goto retry;
		// goto retry
	}

	// [re] set: sysfs_set_super, s: kmem_cache#25-oX (struct super_block), data: kmem_cache#30-oX (struct sysfs_super_info)
	// [re] sysfs_set_super(kmem_cache#25-oX (struct super_block), kmem_cache#30-oX (struct sysfs_super_info)): 0
	err = set(s, data);
	// [re] err: 0

	// [re] sysfs_set_super에서 한일:
	// idr_layer_cache를 사용하여 struct idr_layer 의 메모리 kmem_cache#21-o0...7를 8 개를 할당 받음
	//
	// (&(&unnamed_dev_ida)->idr)->id_free 이 idr object 8 번을 가르킴
	// |
	// |-> ---------------------------------------------------------------------------------------------------------------------------
	//     | idr object 8         | idr object 7         | idr object 6         | idr object 5         | .... | idr object 0         |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//     | ary[0]: idr object 7 | ary[0]: idr object 6 | ary[0]: idr object 5 | ary[0]: idr object 4 | .... | ary[0]: NULL         |
	//     ---------------------------------------------------------------------------------------------------------------------------
	//
	// (&(&unnamed_dev_ida)->idr)->id_free: kmem_cache#21-oX (idr object 8)
	// (&(&unnamed_dev_ida)->idr)->id_free_cnt: 8
	//
	// struct ida_bitmap 의 메모리 kmem_cache#27-oX 할당 받음
	// (&unnamed_dev_ida)->free_bitmap: kmem_cache#27-oX (struct ida_bitmap)
	//
	// (&(&unnamed_dev_ida)->idr)->id_free: kmem_cache#21-oX (idr object 6)
	// (&(&unnamed_dev_ida)->idr)->id_free_cnt: 6
	// (&(&unnamed_dev_ida)->idr)->layers: 1
	// ((&(&unnamed_dev_ida)->idr)->top): kmem_cache#21-oX (idr object 8)
	//
	// (kmem_cache#21-oX (idr object 8))->layer: 0
	// kmem_cache#21-oX (struct idr_layer) (idr object 8)
	// ((kmem_cache#21-oX (struct idr_layer) (idr object 8))->ary[0]): (typeof(*kmem_cache#27-oX (struct ida_bitmap)) __force space *)(kmem_cache#27-oX (struct ida_bitmap))
	// (kmem_cache#21-oX (struct idr_layer) (idr object 8))->count: 1
	//
	// (&unnamed_dev_ida)->free_bitmap: NULL
	// kmem_cache#27-oX (struct ida_bitmap) 메모리을 0으로 초기화
	// (kmem_cache#27-oX (struct ida_bitmap))->bitmap 의 0 bit를 1로 set 수행
	//
	// (kmem_cache#2-oX (struct mount))->mnt_id: 0
	//
	// kmem_cache인 kmem_cache#21 에서 할당한 object인 kmem_cache#21-oX (idr object 7) 의 memory 공간을 반환함
	//
	// unnamed_dev_start: 1
	//
	// (kmem_cache#25-oX (struct super_block))->s_dev: 0
	// (kmem_cache#25-oX (struct super_block))->s_bdi: &noop_backing_dev_info
	// (kmem_cache#25-oX (struct super_block))->s_fs_info: kmem_cache#30-oX (struct sysfs_super_info)

	// [re] err: 0
	if (err) {
		spin_unlock(&sb_lock);
		up_write(&s->s_umount);
		destroy_super(s);
		return ERR_PTR(err);
	}

	// [re] s->s_type: (kmem_cache#25-oX (struct super_block))->s_type, type: &sysfs_fs_type
	s->s_type = type;
	// [re] s->s_type: (kmem_cache#25-oX (struct super_block))->s_type: &sysfs_fs_type

	// [re] s->s_id: (kmem_cache#25-oX (struct super_block))->s_id, type->name: (&sysfs_fs_type)->name: "sysfs",
	// [re] sizeof((kmem_cache#25-oX (struct super_block))->s_id): 32 bytes
	strlcpy(s->s_id, type->name, sizeof(s->s_id));

	// [re] strlcpy에서 한일:
	// s->s_id: (kmem_cache#25-oX (struct super_block))->s_id: "sysfs"

	// [re] s->s_list: (kmem_cache#25-oX (struct super_block))->s_list,
	list_add_tail(&s->s_list, &super_blocks);

	// [re] list_add_tail에서 한일:
	// list head인 &super_blocks 에 (kmem_cache#25-oX (struct super_block))->s_list을 tail에 추가

	// [re] &s->s_instances: &(kmem_cache#25-oX (struct super_block))->s_instances, &type->fs_supers: &(&sysfs_fs_type)->fs_supers
	hlist_add_head(&s->s_instances, &type->fs_supers);

	// [re] hlist_add_head에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_instances)->next: NULL
	// (&(&sysfs_fs_type)->fs_supers)->first: &(kmem_cache#25-oX (struct super_block))->s_instances
	// (&(kmem_cache#25-oX (struct super_block))->s_instances)->pprev: &(&(&sysfs_fs_type)->fs_supers)->first

	spin_unlock(&sb_lock);

	// [re] spin_unlock에서 한일:
	// &sb_lock 을 사용한 spin unlock 수행

	// [re] type: &sysfs_fs_type
	get_filesystem(type);

// 2015/11/14 종료
// 2015/11/21 시작

	// [re] &s->s_shrink: &(kmem_cache#25-oX (struct super_block))->s_shrink
	register_shrinker(&s->s_shrink);

	// register_shrinker에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_shrink)->flags: 0
	// (&(kmem_cache#25-oX (struct super_block))->s_shrink)->nr_deferred: kmem_cache#30-oX
	// head list인 &shrinker_list에 &(&(kmem_cache#25-oX (struct super_block))->s_shrink)->list를 tail로 추가함

	// s: kmem_cache#25-oX (struct super_block)
	return s;
	// return kmem_cache#25-oX (struct super_block)
}

EXPORT_SYMBOL(sget);
```

## super.c::alloc_super

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()

* call: sget()
 - alloc_super()

```super.c
// ARM10C 20151114
// type: &sysfs_fs_type, flags: 0x400000
static struct super_block *alloc_super(struct file_system_type *type, int flags)
{
	// sizeof(struct super_block): 709 bytes, GFP_USER: 0x200D0
	// kzalloc(709, GFP_USER: 0x200D0): kmem_cache#25-oX (struct super_block)
	struct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);
	// s: kmem_cache#25-oX (struct super_block)

	static const struct super_operations default_op;
	int i;

	// s: kmem_cache#25-oX (struct super_block)
	if (!s)
		return NULL;

	// s: kmem_cache#25-oX (struct super_block), security_sb_alloc(kmem_cache#25-oX (struct super_block)): 0
	if (security_sb_alloc(s))
		goto fail;

	// SB_FREEZE_LEVELS: 3
	for (i = 0; i < SB_FREEZE_LEVELS; i++) {
		// i: 0, &s->s_writers.counter[0]: &(kmem_cache#25-oX (struct super_block))->s_writers.counter[0]
		// percpu_counter_init(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0], 0): 0
		if (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)
			goto fail;

		// percpu_counter_init에서 한일:
		// (&(&(&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0])->lock)->wait_lock)->rlock)->raw_lock: { { 0 } }
		// (&(&(&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0])->lock)->wait_lock)->rlock)->magic: 0xdead4ead
		// (&(&(&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0])->lock)->wait_lock)->rlock)->owner: 0xffffffff
		// (&(&(&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0])->lock)->wait_lock)->rlock)->owner_cpu: 0xffffffff
		// (&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0])->list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0])->list
		// (&(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0])->list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0])->list
		// (&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0])->count: 0
		// (&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0])->counters: kmem_cache#26-o0 에서 할당된 4 bytes 메모리 주소
		// list head 인 &percpu_counters에 &(&(kmem_cache#25-oX (struct super_block))->s_writers.counter[0])->list를 연결함

		// i: 0, &s->s_writers.lock_map[i]: &(kmem_cache#25-oX (struct super_block))->s_writers.lock_map[0],
		// sb_writers_name[0]: "sb_writers", &type->s_writers_key[i]: &(&sysfs_fs_type)->s_writers_key[0]
		lockdep_init_map(&s->s_writers.lock_map[i], sb_writers_name[i],
				 &type->s_writers_key[i], 0); // null function

		// i: 1...2 loop 수행
	}

	// &s->s_writers.wait: &(kmem_cache#25-oX (struct super_block))->s_writers.wait
	init_waitqueue_head(&s->s_writers.wait);

	// init_waitqueue_head에서 한일:
	// &(&(kmem_cache#25-oX (struct super_block))->s_writers.wait)->lock을 사용한 spinlock 초기화
	// &(&(kmem_cache#25-oX (struct super_block))->s_writers.wait)->task_list를 사용한 list 초기화

	// &s->s_writers.wait_unfrozen: &(kmem_cache#25-oX (struct super_block))->s_writers.wait_unfrozen
	init_waitqueue_head(&s->s_writers.wait_unfrozen);

	// init_waitqueue_head에서 한일:
	// &(&(kmem_cache#25-oX (struct super_block))->s_writers.wait_unfrozen)->lock을 사용한 spinlock 초기화
	// &(&(kmem_cache#25-oX (struct super_block))->s_writers.wait_unfrozen)->task_list를 사용한 list 초기화

	// s->s_flags: (kmem_cache#25-oX (struct super_block))->s_flags, flags: 0x400000
	s->s_flags = flags;
	// s->s_flags: (kmem_cache#25-oX (struct super_block))->s_flags: 0x400000

	// s->s_bdi: (kmem_cache#25-oX (struct super_block))->s_bdi
	s->s_bdi = &default_backing_dev_info;
	// s->s_bdi: (kmem_cache#25-oX (struct super_block))->s_bdi: &default_backing_dev_info

	// &s->s_instances: &(kmem_cache#25-oX (struct super_block))->s_instances
	INIT_HLIST_NODE(&s->s_instances);

	// INIT_HLIST_NODE에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_instances)->next: NULL
	// (&(kmem_cache#25-oX (struct super_block))->s_instances)->pprev: NULL

	// &s->s_anon: &(kmem_cache#25-oX (struct super_block))->s_anon
	INIT_HLIST_BL_HEAD(&s->s_anon);

	// INIT_HLIST_BL_HEAD에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_anon)->first: NULL

	// &s->s_inodes: &(kmem_cache#25-oX (struct super_block))->s_inodes
	INIT_LIST_HEAD(&s->s_inodes);

	// INIT_LIST_HEAD에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_inodes)->next: &(kmem_cache#25-oX (struct super_block))->s_inodes
	// (&(kmem_cache#25-oX (struct super_block))->s_inodes)->prev: &(kmem_cache#25-oX (struct super_block))->s_inodes

	// &s->s_dentry_lru: &(kmem_cache#25-oX (struct super_block))->s_dentry_lru
	// list_lru_init(&(kmem_cache#25-oX (struct super_block))->s_dentry_lru): 0
	if (list_lru_init(&s->s_dentry_lru))
		goto fail;

	// list_lru_init에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node: kmem_cache#30-oX
	// (&(&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->active_nodes)->bits[0]: 0
	// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].lock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].lock)->magic: 0xdead4ead
	// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].lock)->owner: 0xffffffff
	// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].lock)->owner_cpu: 0xffffffff
	// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].list)->next: (&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].list
	// ((&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].list)->prev: (&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].list
	// (&(kmem_cache#25-oX (struct super_block))->s_dentry_lru)->node[0].nr_items: 0

	// &s->s_inode_lru: &(kmem_cache#25-oX (struct super_block))->s_inode_lru
	if (list_lru_init(&s->s_inode_lru))
		goto fail;

	// list_lru_init에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node: kmem_cache#30-oX
	// (&(&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->active_nodes)->bits[0]: 0
	// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].lock)->raw_lock: { { 0 } }
	// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].lock)->magic: 0xdead4ead
	// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].lock)->owner: 0xffffffff
	// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].lock)->owner_cpu: 0xffffffff
	// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].list)->next: (&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].list
	// ((&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].list)->prev: (&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].list
	// (&(kmem_cache#25-oX (struct super_block))->s_inode_lru)->node[0].nr_items: 0

	// &s->s_mounts: &(kmem_cache#25-oX (struct super_block))->s_mounts
	INIT_LIST_HEAD(&s->s_mounts);

	// INIT_LIST_HEAD에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_mounts)->next: &(kmem_cache#25-oX (struct super_block))->s_mounts
	// (&(kmem_cache#25-oX (struct super_block))->s_mounts)->prev: &(kmem_cache#25-oX (struct super_block))->s_mounts

	// &s->s_umount: &(kmem_cache#25-oX (struct super_block))->s_umount
	init_rwsem(&s->s_umount);

	// init_rwsem에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_umount)->activity: 0
	// &(&(kmem_cache#25-oX (struct super_block))->s_umount)->wait_lock을 사용한 spinlock 초기화
	// (&(&(kmem_cache#25-oX (struct super_block))->s_umount)->wait_list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_umount)->wait_list
	// (&(&(kmem_cache#25-oX (struct super_block))->s_umount)->wait_list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_umount)->wait_list

	// &s->s_umount: &(kmem_cache#25-oX (struct super_block))->s_umount, &type->s_umount_key: &(&sysfs_fs_type)->s_umount_key
	lockdep_set_class(&s->s_umount, &type->s_umount_key); // null function
	/*
	 * sget() can have s_umount recursion.
	 *
	 * When it cannot find a suitable sb, it allocates a new
	 * one (this one), and tries again to find a suitable old
	 * one.
	 *
	 * In case that succeeds, it will acquire the s_umount
	 * lock of the old one. Since these are clearly distrinct
	 * locks, and this object isn't exposed yet, there's no
	 * risk of deadlocks.
	 *
	 * Annotate this by putting this lock in a different
	 * subclass.
	 */
	// &s->s_umount: &(kmem_cache#25-oX (struct super_block))->s_umount, SINGLE_DEPTH_NESTING: 1
	down_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);

	// down_write_nested에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_umount)->activity: -1

	// s->s_count: (kmem_cache#25-oX (struct super_block))->s_count
	s->s_count = 1;
	// s->s_count: (kmem_cache#25-oX (struct super_block))->s_count: 1

	// &s->s_active: &(kmem_cache#25-oX (struct super_block))->s_active
	atomic_set(&s->s_active, 1);

	// atomic_set에서 한일:
	// ((kmem_cache#25-oX (struct super_block))->s_active)->counter: 1

	// &s->s_vfs_rename_mutex: &(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex
	mutex_init(&s->s_vfs_rename_mutex);

	// mutex_init에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->count: 1
	// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_lock)->rlock)->raw_lock: { { 0 } }
	// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_lock)->rlock)->magic: 0xdead4ead
	// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_lock)->rlock)->owner: 0xffffffff
	// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_lock)->rlock)->owner_cpu: 0xffffffff
	// (&(&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_list
	// (&(&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->wait_list
	// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->onwer: NULL
	// (&(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex)->magic: &(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex

	// &s->s_vfs_rename_mutex: &(kmem_cache#25-oX (struct super_block))->s_vfs_rename_mutex,
	// &type->s_vfs_rename_key: &(&sysfs_fs_type)->s_vfs_rename_key
	lockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key); // null function

	// &s->s_dquot.dqio_mutex: &(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex
	mutex_init(&s->s_dquot.dqio_mutex);

	// mutex_init에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->count: 1
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_lock)->rlock)->raw_lock: { { 0 } }
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_lock)->rlock)->magic: 0xdead4ead
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_lock)->rlock)->owner: 0xffffffff
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_lock)->rlock)->owner_cpu: 0xffffffff
	// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_list
	// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->wait_list
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->onwer: NULL
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex)->magic: &(kmem_cache#25-oX (struct super_block))->s_dquot.dqio_mutex

	// &s->s_dquot.dqonoff_mutex: &(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex
	mutex_init(&s->s_dquot.dqonoff_mutex);

	// mutex_init에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->count: 1
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_lock)->rlock)->raw_lock: { { 0 } }
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_lock)->rlock)->magic: 0xdead4ead
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_lock)->rlock)->owner: 0xffffffff
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_lock)->rlock)->owner_cpu: 0xffffffff
	// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_list
	// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->wait_list
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->onwer: NULL
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex)->magic: &(kmem_cache#25-oX (struct super_block))->s_dquot.dqonoff_mutex

	// &s->s_dquot.dqptr_sem: &(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem
	init_rwsem(&s->s_dquot.dqptr_sem);

	// init_rwsem에서 한일:
	// (&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->activity: 0
	// &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->wait_lock을 사용한 spinlock 초기화
	// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->wait_list)->next: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->wait_list
	// (&(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->wait_list)->prev: &(&(kmem_cache#25-oX (struct super_block))->s_dquot.dqptr_sem)->wait_list

	// s->s_maxbytes: (kmem_cache#25-oX (struct super_block))->s_maxbytes, MAX_NON_LFS: 0x7fffffff
	s->s_maxbytes = MAX_NON_LFS;
	// s->s_maxbytes: (kmem_cache#25-oX (struct super_block))->s_maxbytes: 0x7fffffff

	// s->s_op: (kmem_cache#25-oX (struct super_block))->s_op
	s->s_op = &default_op;
	// s->s_op: (kmem_cache#25-oX (struct super_block))->s_op: &default_op

	// s->s_time_gran: (kmem_cache#25-oX (struct super_block))->s_time_gran
	s->s_time_gran = 1000000000;
	// s->s_time_gran: (kmem_cache#25-oX (struct super_block))->s_time_gran: 1000000000

	// s->cleancache_poolid: (kmem_cache#25-oX (struct super_block))->cleancache_poolid
	s->cleancache_poolid = -1;
	// s->cleancache_poolid: (kmem_cache#25-oX (struct super_block))->cleancache_poolid: -1

	// s->s_shrink.seeks: (kmem_cache#25-oX (struct super_block))->s_shrink.seeks, DEFAULT_SEEKS: 2
	s->s_shrink.seeks = DEFAULT_SEEKS;
	// s->s_shrink.seeks: (kmem_cache#25-oX (struct super_block))->s_shrink.seeks: 2

	// s->s_shrink.scan_objects: (kmem_cache#25-oX (struct super_block))->s_shrink.scan_objects
	s->s_shrink.scan_objects = super_cache_scan;
	// s->s_shrink.scan_objects: (kmem_cache#25-oX (struct super_block))->s_shrink.scan_objects: super_cache_scan

	// s->s_shrink.count_objects: (kmem_cache#25-oX (struct super_block))->s_shrink.count_objects
	s->s_shrink.count_objects = super_cache_count;
	// s->s_shrink.count_objects: (kmem_cache#25-oX (struct super_block))->s_shrink.count_objects: super_cache_count

	// s->s_shrink.batch: (kmem_cache#25-oX (struct super_block))->s_shrink.batch
	s->s_shrink.batch = 1024;
	// s->s_shrink.batch: (kmem_cache#25-oX (struct super_block))->s_shrink.batch: 1024

	// s->s_shrink.flags: (kmem_cache#25-oX (struct super_block))->s_shrink.flags, SHRINKER_NUMA_AWARE: 1
	s->s_shrink.flags = SHRINKER_NUMA_AWARE;
	// s->s_shrink.flags: (kmem_cache#25-oX (struct super_block))->s_shrink.flags: 1

	// s: kmem_cache#25-oX (struct super_block)
	return s;
	// return kmem_cache#25-oX (struct super_block)

fail:
	destroy_super(s);
	return NULL;
}
```

## mount.c::sysfs_set_super()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()

* call: sget()
 - alloc_super()
 - set(): sysfs_set_super()

```mount.c::sysfs_set_super()
// ARM10C 20151114
// fs_type: &sysfs_fs_type, sysfs_test_super, sysfs_set_super, flags: 0x400000, info: kmem_cache#30-oX (struct sysfs_super_info)
struct super_block *sget(struct file_system_type *type,
			int (*test)(struct super_block *,void *),
			int (*set)(struct super_block *,void *),
			int flags,
			void *data)
{
	struct super_block *s = NULL;
	// s: NULL

	struct super_block *old;
	int err;

// ARM10C 20151114
// fs_type: &sysfs_fs_type, sysfs_test_super, sysfs_set_super, flags: 0x400000, info: kmem_cache#30-oX (struct sysfs_super_info)
struct super_block *sget(struct file_system_type *type,
			int (*test)(struct super_block *,void *),
			int (*set)(struct super_block *,void *),
			int flags,
			void *data)
{
	struct super_block *s = NULL;
	// s: NULL

	struct super_block *old;
	int err;

retry:
	spin_lock(&sb_lock);

	// spin_lock에서 한일:
	// &sb_lock 을 사용한 spin lock 수행

	// [re] spin_lock에서 한일:
	// [re] &sb_lock 을 사용한 spin lock 수행

	// test: sysfs_test_super
	// [re] test: sysfs_test_super
	if (test) {
		// &type->fs_supers: &(&sysfs_fs_type)->fs_supers
		// hlist_entry_safe((&(&sysfs_fs_type)->fs_supers)->first, struct super_block, s_instances): NULL
		// [re] &type->fs_supers: &(&sysfs_fs_type)->fs_supers
		// [re] hlist_entry_safe((&(&sysfs_fs_type)->fs_supers)->first, struct super_block, s_instances): NULL
		hlist_for_each_entry(old, &type->fs_supers, s_instances) {
		// for (old = hlist_entry_safe((&type->fs_supers)->first, typeof(*(old)), s_instances);
		//      old; old = hlist_entry_safe((old)->s_instances.next, typeof(*(old)), s_instances))

			if (!test(old, data))
				continue;
			if (!grab_super(old))
				goto retry;
			if (s) {
				up_write(&s->s_umount);
				destroy_super(s);
				s = NULL;
			}
			return old;
		}
	}

	// s: NULL
	// [re] s: kmem_cache#25-oX (struct super_block)
	if (!s) {
		spin_unlock(&sb_lock);

		// spin_unlock에서 한일:
		// &sb_lock 을 사용한 spin unlock 수행

		// type: &sysfs_fs_type, flags: 0x400000
		// alloc_super(&sysfs_fs_type, 0x400000): kmem_cache#25-oX (struct super_block)
		s = alloc_super(type, flags);
		// s: kmem_cache#25-oX (struct super_block)

...

retry:
	spin_lock(&sb_lock);

	// spin_lock에서 한일:
	// &sb_lock 을 사용한 spin lock 수행

	// [re] spin_lock에서 한일:
	// [re] &sb_lock 을 사용한 spin lock 수행

	// test: sysfs_test_super
	// [re] test: sysfs_test_super
	if (test) {
		// &type->fs_supers: &(&sysfs_fs_type)->fs_supers
		// hlist_entry_safe((&(&sysfs_fs_type)->fs_supers)->first, struct super_block, s_instances): NULL
		// [re] &type->fs_supers: &(&sysfs_fs_type)->fs_supers
		// [re] hlist_entry_safe((&(&sysfs_fs_type)->fs_supers)->first, struct super_block, s_instances): NULL
		hlist_for_each_entry(old, &type->fs_supers, s_instances) {
		// for (old = hlist_entry_safe((&type->fs_supers)->first, typeof(*(old)), s_instances);
		//      old; old = hlist_entry_safe((old)->s_instances.next, typeof(*(old)), s_instances))

			if (!test(old, data))
				continue;
			if (!grab_super(old))
				goto retry;
			if (s) {
				up_write(&s->s_umount);
				destroy_super(s);
				s = NULL;
			}
			return old;
		}
	}

	// s: NULL
	// [re] s: kmem_cache#25-oX (struct super_block)
	if (!s) {
		spin_unlock(&sb_lock);

		// spin_unlock에서 한일:
		// &sb_lock 을 사용한 spin unlock 수행

		// type: &sysfs_fs_type, flags: 0x400000
		// alloc_super(&sysfs_fs_type, 0x400000): kmem_cache#25-oX (struct super_block)
		s = alloc_super(type, flags);
		// s: kmem_cache#25-oX (struct super_block)

		// s: kmem_cache#25-oX (struct super_block)
		if (!s)
			return ERR_PTR(-ENOMEM);
		goto retry;
		// goto retry
	}

    // [re] set: sysfs_set_super, s: kmem_cache#25-oX (struct super_block), data: kmem_cache#30-oX (struct sysfs_super_info)
	// [re] sysfs_set_super(kmem_cache#25-oX (struct super_block), kmem_cache#30-oX (struct sysfs_super_info)): 0
	err = set(s, data);
```

## mount.c::sysfs_set_super()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()

* call: sget()
 - alloc_super()
 - set(): sysfs_set_super()
 
* call: sysfs_set_super()
 - set_anon_super()

```
// ARM10C 20151114
// s: kmem_cache#25-oX (struct super_block), data: kmem_cache#30-oX (struct sysfs_super_info)
static int sysfs_set_super(struct super_block *sb, void *data)
{
	int error;

	// sb: kmem_cache#25-oX (struct super_block), data: kmem_cache#30-oX (struct sysfs_super_info)
	// set_anon_super(kmem_cache#25-oX (struct super_block), kmem_cache#30-oX (struct sysfs_super_info)): 0
	error = set_anon_super(sb, data);
	// error: 0
```

## super.c::set_anon_super()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()

* call: sget()
 - alloc_super()
 - set(): sysfs_set_super()
 
* call: sysfs_set_super()
 - set_anon_super()

```super.c
// ARM10C 20151114
// sb: kmem_cache#25-oX (struct super_block), data: kmem_cache#30-oX (struct sysfs_super_info)
int set_anon_super(struct super_block *s, void *data)
{
	// &s->s_dev: &(kmem_cache#25-oX (struct super_block))->s_dev
	// get_anon_bdev(&(kmem_cache#25-oX (struct super_block))->s_dev): 0
	int error = get_anon_bdev(&s->s_dev);
	// error: 0

	// error: 0
	if (!error)
		// s->s_bdi: (kmem_cache#25-oX (struct super_block))->s_bdi
		s->s_bdi = &noop_backing_dev_info;
		// s->s_bdi: (kmem_cache#25-oX (struct super_block))->s_bdi: &noop_backing_dev_info

	// error: 0
	return error;
	// return 0
}
```

## ...

get_anon_dbdev에서 한일.
정리
start_kernel        1  ~/kernel/iamroot/linux-stable/init/main.c
  2  1 vfs_caches_init   925  ~/kernel/iamroot/linux-stable/init/main.c
    3  1 mnt_init         3807  ~/kernel/iamroot/linux-stable/fs/dcache.c
	  4  1 init_rootfs      4312  ~/kernel/iamroot/linux-stable/fs/namespace.c
	    5  1 shmem_init        639  ~/kernel/iamroot/linux-stable/init/do_mounts.c
		  6  1 kern_mount       2943  ~/kernel/iamroot/linux-stable/mm/shmem.c
		    7  1 kern_mount_data  1971  ~/kernel/iamroot/linux-stable/include/linux/fs.h
			  8  1 vfs_kern_mount   4336  ~/kernel/iamroot/linux-stable/fs/namespace.c
			    9  1 mount_fs         1381  ~/kernel/iamroot/linux-stable/fs/namespace.c
				 10  1 shmem_mount      2281  // shmem_mount(&shmem_fs_type, 0x400000, "tmpfs", NULL):
				  11  1 mount_nodev      2821  ~/kernel/iamroot/linux-stable/mm/shmem.c
				  >12  1 fill_super       2206  error = fill_super(s, data, flags & MS_SILENT ? 1 : 0);

## shmem.c::mount_nodev()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()
 - fill_super()

```super.c
struct dentry *mount_nodev(struct file_system_type *fs_type,
	int flags, void *data,
	int (*fill_super)(struct super_block *, void *, int))
{
	int error;
	struct super_block *s = sget(fs_type, NULL, set_anon_super, flags, NULL);

	if (IS_ERR(s))
		return ERR_CAST(s);

	error = fill_super(s, data, flags & MS_SILENT ? 1 : 0);
	if (error) {
		deactivate_locked_super(s);
		return ERR_PTR(error);
	}
	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);
}
EXPORT_SYMBOL(mount_nodev);
```

```fs.h
struct tree_descr { char *name; const struct file_operations *ops; int mode; };
```

```inode.c
static int fill_super(struct super_block *sb, void *data, int silent)
{
	static struct tree_descr files[] = {{""}};

	return simple_fill_super(sb, SECURITYFS_MAGIC, files);
}
```

* 여기서 static struct tree_descr files[] = {{""}};를 알아보자.
 - tree_descr 구조체는
   - char *name
   - const struct file_operrations *ops
   - int mode
 - 이것을 { { "" } } 로 초기화 한것이므로
 - tree_descr = { {""} , NULL, 0 } 이라고 할 수 있다.

## libfs.c::simple_fill_super()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()
 - fill_super()

* call: fill_super()
 - simple_fill_super()

```libfs.c
int simple_fill_super(struct super_block *s, unsigned long magic,
		      struct tree_descr *files)
{
	struct inode *inode;
	struct dentry *root;
	struct dentry *dentry;
	int i;

	s->s_blocksize = PAGE_CACHE_SIZE;
	s->s_blocksize_bits = PAGE_CACHE_SHIFT;
	s->s_magic = magic;
	s->s_op = &simple_super_operations;
	s->s_time_gran = 1;

	inode = new_inode(s);
```

## inode.c::new_inode()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()
 - fill_super()

* call: fill_super()
 - new_inode()

```inode.c
struct inode *new_inode(struct super_block *sb)
{
	struct inode *inode;

	spin_lock_prefetch(&inode_sb_list_lock);

	inode = new_inode_pseudo(sb);
	if (inode)
		inode_sb_list_add(inode);
	return inode;
}
EXPORT_SYMBOL(new_inode);
```

* spin_lock_prefetch(&inode_sb_list_lock);

```prefetch.h
#define spin_lock_prefetch(x) prefetchw(x)
```

```
// ARM10C 20140329
// page: 0x20000의 해당하는 struct page의 주소
static inline void prefetchw(const void *ptr)
{
	__asm__ __volatile__(
		".arch_extension	mp\n"
		__ALT_SMP_ASM(
			WASM(pldw)		"\t%a0",
			WASM(pld)		"\t%a0"
		)
		:: "p" (ptr));
}
#endif
```

* pldw, pld 의 인스트럭션 설명
 - Preload Data and Preload Instruction allow the processor to signal
 - the memory system that a data or instruction load from an address is likely
 - in the near future.

## inode.c::new_inode_pseudo()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()
 - fill_super()

* call: fill_super()
 - new_inode()

* call: new_inode()
 - new_inode_pseudo()

```inode.c
struct inode *new_inode_pseudo(struct super_block *sb)
{
	struct inode *inode = alloc_inode(sb);

	if (inode) {
		spin_lock(&inode->i_lock);
		inode->i_state = 0;
		spin_unlock(&inode->i_lock);
		INIT_LIST_HEAD(&inode->i_sb_list);
	}
	return inode;
}
```

## inode.c::new_inode()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()
 - fill_super()

* call: fill_super()
 - new_inode()

* call: new_inode()
 - spin_lock_prefetch()
 - new_inode_pseudo()
 
```inode.c
struct inode *new_inode(struct super_block *sb)
{
	struct inode *inode;

	spin_lock_prefetch(&inode_sb_list_lock);

	inode = new_inode_pseudo(sb);
	if (inode)
		inode_sb_list_add(inode);
	return inode;
}
EXPORT_SYMBOL(new_inode);
```

## inode.c::inode_sb_list_add()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()
 - fill_super()

* call: fill_super()
 - new_inode()

* call: new_inode()
 - spin_lock_prefetch()
 - new_inode_pseudo()
 - inode_sb_list_add()

* call: inode_sb_list_add()

```inode.c
// ARM10C 20151205
// inode: kmem_cache#4-oX (struct inode)
void inode_sb_list_add(struct inode *inode)
{
	spin_lock(&inode_sb_list_lock);

	// spin_lock에서 한일:
	// &inode_sb_list_lock을 이용한 spin lock 수행

	// &inode->i_sb_list: &(kmem_cache#4-oX (struct inode))->i_sb_list,
	// &inode->i_sb->s_inodes: &(kmem_cache#4-oX (struct inode))->i_sb->s_inodes
	list_add(&inode->i_sb_list, &inode->i_sb->s_inodes);

	// list_add에서 한일:
	// head list인 &(kmem_cache#4-oX (struct inode))->i_sb->s_inodes에 &(kmem_cache#4-oX (struct inode))->i_sb_list를 추가함

	spin_unlock(&inode_sb_list_lock);

	// spin_unlock에서 한일:
	// &inode_sb_list_lock을 이용한 spin unlock 수행
}
EXPORT_SYMBOL_GPL(inode_sb_list_add);
```

* inode_sb_list_add() 에서 한 일

* new_inode() 에서 한 일


## libfs.c::simple_fill_super()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()
 - fill_super()

* call: fill_super()
 - simple_fill_super()

* call: simple_fill_super()
 - new_inode()
 - set_nlink()
 - d_make_root()

* set_nlink()

```inode.c
// ARM10C 20151212
// inode: kmem_cache#4-oX (struct inode), 2
void set_nlink(struct inode *inode, unsigned int nlink)
{
	// nlink: 2
	if (!nlink) {
		clear_nlink(inode);
	} else {
		/* Yes, some filesystems do change nlink from zero to one */
		// inode->i_nlink: (kmem_cache#4-oX (struct inode))->i_nlink: 1
		if (inode->i_nlink == 0)
			atomic_long_dec(&inode->i_sb->s_remove_count);

		// inode->__i_nlink: (kmem_cache#4-oX (struct inode))->__i_nlink: 1,  nlink: 2
		inode->__i_nlink = nlink;
		// inode->__i_nlink: (kmem_cache#4-oX (struct inode))->__i_nlink: 2
	}
}
EXPORT_SYMBOL(set_nlink);
```

* d_make_root()

```dcache.c
// ARM10C 20151212
// inode: kmem_cache#4-oX
struct dentry *d_make_root(struct inode *root_inode)
{
	struct dentry *res = NULL;
	// res: NULL

	// root_inode: kmem_cache#4-oX
	if (root_inode) {
		// QSTR_INIT("/", 1): { { { .len = 1 } }, .name = "/" }
		static const struct qstr name = QSTR_INIT("/", 1);

		// QSTR_INIT에서 한일:
		// name.name: "/"
		// name.len: 1

		// root_inode->i_sb: (kmem_cache#4-oX)->i_sb: kmem_cache#25-oX (struct super_block)
		// __d_alloc(kmem_cache#25-oX (struct super_block), &name): kmem_cache#5-oX (struct dentry)
		res = __d_alloc(root_inode->i_sb, &name);
		// res: kmem_cache#5-oX (struct dentry)

		// __d_alloc에서 한일:
		// dentry_cache인 kmem_cache#5을 사용하여 dentry로 사용할 메모리 kmem_cache#5-oX (struct dentry)을 할당받음
		//
		// (kmem_cache#5-oX (struct dentry))->d_iname[35]: 0
		// (kmem_cache#5-oX (struct dentry))->d_name.len: 1
		// (kmem_cache#5-oX (struct dentry))->d_name.hash: (&name)->hash: 0
		// (kmem_cache#5-oX (struct dentry))->d_iname: "/"
		//
		// 공유자원을 다른 cpu core가 사용할수 있게 함
		//
		// (kmem_cache#5-oX (struct dentry))->d_name.name: "/"
		// (kmem_cache#5-oX (struct dentry))->d_lockref.count: 1
		// (kmem_cache#5-oX (struct dentry))->d_flags: 0
		//
		// (&(kmem_cache#5-oX (struct dentry))->d_lock)->raw_lock: { { 0 } }
		// (&(kmem_cache#5-oX (struct dentry))->d_lock)->magic: 0xdead4ead
		// (&(kmem_cache#5-oX (struct dentry))->d_lock)->owner: 0xffffffff
		// (&(kmem_cache#5-oX (struct dentry))->d_lock)->owner_cpu: 0xffffffff
		//
		// (&(kmem_cache#5-oX (struct dentry))->d_seq)->sequence: 0
		//
		// (kmem_cache#5-oX (struct dentry))->d_inode: NULL
		//
		// (kmem_cache#5-oX (struct dentry))->d_parent: kmem_cache#5-oX (struct dentry)
		// (kmem_cache#5-oX (struct dentry))->d_sb: kmem_cache#25-oX (struct super_block)
		// (kmem_cache#5-oX (struct dentry))->d_op: NULL
		// (kmem_cache#5-oX (struct dentry))->d_fsdata: NULL
		//
		// (&(kmem_cache#5-oX (struct dentry))->d_hash)->next: NULL
		// (&(kmem_cache#5-oX (struct dentry))->d_hash)->pprev: NULL
		// (&(kmem_cache#5-oX (struct dentry))->d_lru)->next: &(kmem_cache#5-oX (struct dentry))->d_lru
		// (&(kmem_cache#5-oX (struct dentry))->d_lru)->prev: &(kmem_cache#5-oX (struct dentry))->d_lru
		// (&(kmem_cache#5-oX (struct dentry))->d_subdirs)->next: &(kmem_cache#5-oX (struct dentry))->d_subdirs
		// (&(kmem_cache#5-oX (struct dentry))->d_subdirs)->prev: &(kmem_cache#5-oX (struct dentry))->d_subdirs
		// (&(kmem_cache#5-oX (struct dentry))->d_alias)->next: NULL
		// (&(kmem_cache#5-oX (struct dentry))->d_alias)->pprev: NULL
		// (&(kmem_cache#5-oX (struct dentry))->d_u.d_child)->next: &(kmem_cache#5-oX (struct dentry))->d_u.d_child
		// (&(kmem_cache#5-oX (struct dentry))->d_u.d_child)->prev: &(kmem_cache#5-oX (struct dentry))->d_u.d_child
		//
		// (kmem_cache#5-oX (struct dentry))->d_op: NULL
		//
		// [pcp0] nr_dentry: 1

		// res: kmem_cache#5-oX (struct dentry)
		if (res)
			// res: kmem_cache#5-oX (struct dentry), root_inode: kmem_cache#4-oX
			d_instantiate(res, root_inode);

			// d_instantiate에서 한일:
			//
			// (&(kmem_cache#5-oX (struct dentry))->d_alias)->next: NULL
			// (&(kmem_cache#4-oX)->i_dentry)->first: &(kmem_cache#5-oX (struct dentry))->d_alias
			// (&(kmem_cache#5-oX (struct dentry))->d_alias)->pprev: &(&(kmem_cache#5-oX (struct dentry))->d_alias)
			//
			// (kmem_cache#5-oX (struct dentry))->d_inode: kmem_cache#4-oX
			//
			// 공유자원을 다른 cpu core가 사용할수 있게 함
			// (&(kmem_cache#5-oX (struct dentry))->d_seq)->sequence: 2
			//
			// (kmem_cache#5-oX (struct dentry))->d_flags: 0x00100000
		else
			iput(root_inode);
	}

	// res: kmem_cache#5-oX (struct dentry)
	return res;
	// return kmem_cache#5-oX (struct dentry)
}
EXPORT_SYMBOL(d_make_root);
```

* simple_fill_super()

```libfs.c
int simple_fill_super(struct super_block *s, unsigned long magic,
		      struct tree_descr *files)
{
	struct inode *inode;
	struct dentry *root;
	struct dentry *dentry;
	int i;

	s->s_blocksize = PAGE_CACHE_SIZE;
	s->s_blocksize_bits = PAGE_CACHE_SHIFT;
	s->s_magic = magic;
	s->s_op = &simple_super_operations;
	s->s_time_gran = 1;

	inode = new_inode(s);
	if (!inode)
		return -ENOMEM;
	/*
	 * because the root inode is 1, the files array must not contain an
	 * entry at index 1
	 */
	inode->i_ino = 1;
	inode->i_mode = S_IFDIR | 0755;
	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
	inode->i_op = &simple_dir_inode_operations;
	inode->i_fop = &simple_dir_operations;
	set_nlink(inode, 2);
	root = d_make_root(inode);
	if (!root)
		return -ENOMEM;
	for (i = 0; !files->name || files->name[0]; i++, files++) {
		if (!files->name)
			continue;

		/* warn if it tries to conflict with the root inode */
		if (unlikely(i == 1))
			printk(KERN_WARNING "%s: %s passed in a files array"
				"with an index of 1!\n", __func__,
				s->s_type->name);

		dentry = d_alloc_name(root, files->name);
		if (!dentry)
			goto out;
		inode = new_inode(s);
		if (!inode) {
			dput(dentry);
			goto out;
		}
		inode->i_mode = S_IFREG | files->mode;
		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
		inode->i_fop = files->ops;
		inode->i_ino = i;
		d_add(dentry, inode);
	}
	s->s_root = root;
	return 0;
out:
	d_genocide(root);
	shrink_dcache_parent(root);
	dput(root);
	return -ENOMEM;
}
EXPORT_SYMBOL(simple_fill_super);
```

* 주의: {""} 는 NULL이 아니다.
 - files->name: "" 이므로 if 문 안으로 들어가지 않는다.
```
	for (i = 0; !files->name || files->name[0]; i++, files++) {
		if (!files->name)
			continue;
```

* simple_fill_super()에서 한 일.

## super.c::mount_nodev()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

* call: mount_nodev()
 - sget()
 - fill_super()
 - dget()

```super.c
struct dentry *mount_nodev(struct file_system_type *fs_type,
	int flags, void *data,
	int (*fill_super)(struct super_block *, void *, int))
{
	int error;
	struct super_block *s = sget(fs_type, NULL, set_anon_super, flags, NULL);

	if (IS_ERR(s))
		return ERR_CAST(s);

	error = fill_super(s, data, flags & MS_SILENT ? 1 : 0);
	if (error) {
		deactivate_locked_super(s);
		return ERR_PTR(error);
	}
	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);
}
EXPORT_SYMBOL(mount_nodev);
```

* dget()

```dcache.h
// ARM10C 20151219
// sb->s_root: (kmem_cache#25-oX (struct super_block))->s_root: kmem_cache#5-oX (struct dentry)
static inline struct dentry *dget(struct dentry *dentry)
{
	// dentry: kmem_cache#5-oX (struct dentry)
	if (dentry)
		// &dentry->d_lockref: &(kmem_cache#5-oX (struct dentry))->d_lockref
		lockref_get(&dentry->d_lockref);

		// lockref_get에서 한일:
		// (&(kmem_cache#5-oX (struct dentry))->d_lockref)->count: 1

	// dentry: kmem_cache#5-oX (struct dentry)
	return dentry;
	// return kmem_cache#5-oX (struct dentry)
}
```

* mount_nodev() 에서 한 일

## shmem.c::shmem_mount()

* call: start_kernel()
 - vfs_caches_init()
  - mnt_init()

* call: mnt_init()
  - kmem_cache_create()
  - alloc_large_system_hash() : mnt_cache
  - alloc_large_system_hash() : Mount-cache
  - alloc_large_system_hash() : Mountpoint-cache
  - INIT_HLIST_HEAD() : &mount_hashtable[u]
  - INIT_HLIST_HEAD() : &mountpoint_hashtable[u]
  - sysfs_init()
  - kobject_create_and_add() : fs
  - init_rootfs()

* call: init_rootfs()
  - register_filesystem()
  - shmem_init()

* call: shmem_init()
  - bdi_init()
  - shmem_init_inodecache()
  - register_filesystem()
  - kern_mount(): kern_mount_data(): shmem_fs_type

* call: kern_mount_data()
  - vfs_kern_mount()
  
* call: vfs_kern_mount()
  - alloc_vfsmnt()
  - mount_fs()

* call: mount_fs()
 - shmem_mount()

* call: shmem_mount()
 - mount_nodev()

```shmem.c
static struct dentry *shmem_mount(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data)
{
	return mount_nodev(fs_type, flags, data, shmem_fill_super);
}
```

* shmem_mount() 가 한 일

## super.c::mount_fs()

```super.c
// ARM10C 20151114
// type: &sysfs_fs_type, flags: 0x400000, name: "sysfs", data: NULL
struct dentry *
mount_fs(struct file_system_type *type, int flags, const char *name, void *data)
{
	struct dentry *root;
	struct super_block *sb;
	char *secdata = NULL;
	// secdata: NULL

	// ENOMEM: 12
	int error = -ENOMEM;
	// error: -12

	// data: NULL, type->fs_flags: (&sysfs_fs_type)->fs_flags: 8, FS_BINARY_MOUNTDATA: 2
	if (data && !(type->fs_flags & FS_BINARY_MOUNTDATA)) {
		secdata = alloc_secdata();
		if (!secdata)
			goto out;

		error = security_sb_copy_data(data, secdata);
		if (error)
			goto out_free_secdata;
	}

	// type->mount: (&sysfs_fs_type)->mount: sysfs_mount
	// type: &sysfs_fs_type, flags: 0x400000, name: "sysfs", data: NULL
	// sysfs_mount(&sysfs_fs_type, 0x400000, "sysfs", NULL): kmem_cache#5-oX (struct dentry)
	root = type->mount(type, flags, name, data);
	// root: kmem_cache#5-oX (struct dentry)





## log

