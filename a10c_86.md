# ARM10C 86주차 후기
##### 일시 : 2015.01.10 (86주차)
##### 모임명 : NAVER개발자커뮤니티지원_IAMROOT.ORG_10차ARM-C
##### 장소 : 토즈 타워점
##### 장소지원 : NAVER 개발자 커뮤니티 지원 프로그램
##### 참여인원 :  3명
============

## 86주차 진도
* start_kernel()->time_init(); 진행중

## time.c
* start_kernel()->time_init()->of_clk_init(NULL);

```time.c
// ARM10C 20150103
void __init time_init(void)
{
	// machine_desc->init_time: __mach_desc_EXYNOS5_DT.init_time: NULL
	if (machine_desc->init_time) {
		machine_desc->init_time();
	} else {
#ifdef CONFIG_COMMON_CLK // CONFIG_COMMON_CLK=y
		of_clk_init(NULL);
#endif
		clocksource_of_init();
	}
}
```

## clk.c
* start_kernel()->time_init()->of_clk_init(NULL)->of_clk_init()

```clk.c
// ARM10C 20150103
// NULL
void __init of_clk_init(const struct of_device_id *matches)
{
	const struct of_device_id *match;
	struct device_node *np;

	// matches: NULL
	if (!matches)
		// __clk_of_table:
		// __clk_of_table_fixed_factor_clk
		// __clk_of_table_fixed_clk
		// __clk_of_table_exynos4210_audss_clk
		// __clk_of_table_exynos5250_audss_clk
		// __clk_of_table_exynos5420_clk
		matches = __clk_of_table;
		// matches:
		// __clk_of_table_fixed_factor_clk
		// __clk_of_table_fixed_clk
		// __clk_of_table_exynos4210_audss_clk
		// __clk_of_table_exynos5250_audss_clk
		// __clk_of_table_exynos5420_clk

	for_each_matching_node_and_match(np, matches, &match) {
	// for (np = of_find_matching_node_and_match(NULL, matches, &match);
	//      np; np = of_find_matching_node_and_match(np, matches, &match))

		// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소, match: __clk_of_table_exynos5420_clk

		// match->data: __clk_of_table_exynos5420_clk.data: exynos5420_clk_init
		of_clk_init_cb_t clk_init_cb = match->data;
		// clk_init_cb: exynos5420_clk_init

		// clk_init_cb: exynos5420_clk_init,
		// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
		// exynos5420_clk_init(devtree에서 allnext로 순회 하면서 찾은 clock node의 주소)
		clk_init_cb(np);
	}
}
```

## clk-exynos5420.c:clk_init_cb()
* start_kernel()->time_init()->of_clk_init(NULL)->of_clk_init()->exynos5420_clk_init()

```clk-exynos5420.c
/* register exynos5420 clocks */
// ARM10C 20150103
// devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
static void __init exynos5420_clk_init(struct device_node *np)
{
	void __iomem *reg_base;

// 2015/01/03 종료
// 2015/01/10 시작

	// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
	if (np) {
		// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
		reg_base = of_iomap(np, 0);
		if (!reg_base)
			panic("%s: failed to map registers\n", __func__);
	} else {
		panic("%s: unable to determine soc\n", __func__);
	}
```

* start_kernel()->time_init()->of_clk_init(NULL)->of_clk_init()->exynos5420_clk_init()->of_iomap();
 - // np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
 - reg_base = of_iomap(np, 0);

## address.c::of_iomap()
* start_kernel()->time_init()->of_clk_init(NULL)->of_clk_init()->exynos5420_clk_init()->of_iomap();

```address.c
// ARM10C 20150110
// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소, 0
void __iomem *of_iomap(struct device_node *np, int index)
{
	struct resource res;

	// np: devtree에서 allnext로 순회 하면서 찾은 gic node의 주소, index: 0
	// of_address_to_resource(devtree에서 allnext로 순회 하면서 찾은 gic node의 주소, 0, &res): 0
	// np: devtree에서 allnext로 순회 하면서 찾은 gic node의 주소, index: 1
	// of_address_to_resource(devtree에서 allnext로 순회 하면서 찾은 gic node의 주소, 1, &res): 0
	// np: devtree에서 allnext로 순회 하면서 찾은 combiner node의 주소, index: 0
	// of_address_to_resource(devtree에서 allnext로 순회 하면서 찾은 combiner node의 주소, 0, &res): 0
	// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소, index: 0
	// of_address_to_resource(devtree에서 allnext로 순회 하면서 찾은 clock node의 주소, 0, &res): 0
	if (of_address_to_resource(np, index, &res))
		return NULL;

	// np: devtree에서 allnext로 순회 하면서 찾은 gic node의 주소
	// of_address_to_resource에서 한일(index: 0):
	// (&res)->start: 0x10481000
	// (&res)->end: 0x10481fff
	// (&res)->flags: IORESOURCE_MEM: 0x00000200
	// (&res)->name: "/interrupt-controller@10481000"

	// of_address_to_resource에서 한일(index: 1):
	// (&res)->start: 0x10482000
	// (&res)->end: 0x10482fff
	// (&res)->flags: IORESOURCE_MEM: 0x00000200
	// (&res)->name: "/interrupt-controller@10481000"

	// np: devtree에서 allnext로 순회 하면서 찾은 combiner node의 주소
	// of_address_to_resource에서 한일(index: 0):
	// (&res)->start: 0x10440000
	// (&res)->end: 0x10440fff
	// (&res)->flags: IORESOURCE_MEM: 0x00000200
	// (&res)->name: "/interrupt-controller@10440000"

	// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
	// of_address_to_resource에서 한일(index: 0):
	// (&res)->start: 0x10010000
	// (&res)->end: 0x1003ffff
	// (&res)->flags: IORESOURCE_MEM: 0x00000200
	// (&res)->name: "/clock-controller@10010000"

	// res.start: 0x10481000, resource_size(&res): 0x1000
	// ioremap(0x10481000, 0x1000): 0xf0000000
	// res.start: 0x10482000, resource_size(&res): 0x1000
	// ioremap(0x10482000, 0x1000): 0xf0002000
	// res.start: 0x10440000, resource_size(&res): 0x1000
	// ioremap(0x10440000, 0x1000): 0xf0004000
	// res.start: 0x10010000, resource_size(&res): 0x30000
	// ioremap(0x10010000, 0x30000):
	return ioremap(res.start, resource_size(&res));
	// return 0xf0000000
	// return 0xf0002000
	// return 0xf0004000
}
EXPORT_SYMBOL(of_iomap);
```

## io.h::ioremap()

```io.h
// ARM10C 20150110
// res.start: 0x10010000, resource_size(&res): 0x30000
#define ioremap(cookie,size)		__arm_ioremap((cookie), (size), MT_DEVICE)
```

## ioremap.c
*

```ioremap.c
// ARM10C 20150110
// res.start: 0x10010000, resource_size(&res): 0x30000, MT_DEVICE: 0
void __iomem *
__arm_ioremap(phys_addr_t phys_addr, size_t size, unsigned int mtype)
{
	// phys_addr: 0x10481000, size: 0x1000, mtype: MT_DEVICE: 0
	// arch_ioremap_caller(0x10481000, 0x1000, MT_DEVICE: 0, __builtin_return_address(0)): 0xf0000000
	// phys_addr: 0x10482000, size: 0x1000, mtype: MT_DEVICE: 0
	// arch_ioremap_caller(0x10482000, 0x1000, MT_DEVICE: 0, __builtin_return_address(0)): 0xf0002000
	// phys_addr: 0x10440000, size: 0x1000, mtype: MT_DEVICE: 0
	// arch_ioremap_caller(0x10440000, 0x1000, MT_DEVICE: 0, __builtin_return_address(0)): 0xf0004000
	// phys_addr: 0x10010000, size: 0x30000, mtype: MT_DEVICE: 0
	// arch_ioremap_caller(0x10010000, 0x30000, MT_DEVICE: 0, __builtin_return_address(0)):
	return arch_ioremap_caller(phys_addr, size, mtype,
		__builtin_return_address(0));
	// return 0xf0000000
	// return 0xf0002000
	// return 0xf0004000
}
EXPORT_SYMBOL(__arm_ioremap);
```

## vmalloc.c::__insert_vmap_area()
* 채워넣자.

```vmalloc.c
o// ARM10C 20150110
// va: kmem_cache#30-oX (CLK)
static void __insert_vmap_area(struct vmap_area *va)
{
	struct rb_node **p = &vmap_area_root.rb_node;
	// p: &vmap_area_root.rb_node
	// p: &vmap_area_root.rb_node
	// p: &vmap_area_root.rb_node
	// p: &vmap_area_root.rb_node
	// p: &vmap_area_root.rb_node
	struct rb_node *parent = NULL;
	// parent: NULL
	// parent: NULL
	// parent: NULL
	// parent: NULL
	// parent: NULL
	struct rb_node *tmp;

	// *p: vmap_area_root.rb_node: NULL
	// *p: vmap_area_root.rb_node: CHID node
	// *p: vmap_area_root.rb_node: CHID node
	// *p: vmap_area_root.rb_node: CHID node
	// *p: vmap_area_root.rb_node: CHID node
	while (*p) {
		struct vmap_area *tmp_va;

		// *p: vmap_area_root.rb_node: CHID node
		parent = *p;
		// parent: CHID node

		// parent: CHID node
		// rb_entry(CHID node, struct vmap_area, rb_node):
		// CHID 의 vmap_area 시작주소
		tmp_va = rb_entry(parent, struct vmap_area, rb_node);
		// tmp_va: CHID 의 vmap_area 시작주소

		// va->va_start: (kmem_cache#30-oX (GIC))->va_start: 0xf0000000,
		// tmp_va->va_end: (CHID 의 vmap_area 시작주소)->va_end: 0xf8001000
		if (va->va_start < tmp_va->va_end)
			// &(*p)->rb_left: &(CHID node)->rb_left
			p = &(*p)->rb_left;
			// p: TMR node
		else if (va->va_end > tmp_va->va_start)
			p = &(*p)->rb_right;
		else
			BUG();

		// GIC#0 node를 추가 할때 까지 루프 수행
		// GIC#1 node를 추가 할때 까지 루프 수행
		// COMB node를 추가 할때 까지 루프 수행
		// CLK node를 추가 할때 까지 루프 수행
	}
	// while 수행 결과 rbtree를 순회 하여 GIC#0 node를 rbtree에 추가함
	/*
	// 가상주소 va_start 기준으로 GIC#0 를 RB Tree 추가한 결과
	//
	//                                  CHID-b
	//                               (0xF8000000)
	//                              /            \
	//                         TMR-r               PMU-r
	//                    (0xF6300000)             (0xF8180000)
	//                      /      \               /           \
	//                 SYSC-b      WDT-b         CMU-b         SRAM-b
	//            (0xF6100000)   (0xF6400000)  (0xF8100000)   (0xF8400000)
	//             /                                                 \
	//        GIC#0-r                                                 ROMC-r
	//    (0xF0000000)                                                (0xF84C0000)
	//
	*/

	// while 수행 결과 rbtree를 순회 하여 GIC#1 node를 rbtree에 추가함
	/*
	// 가상주소 va_start 기준으로 GIC#0 를 RB Tree 추가한 결과
	//
	//                                  CHID-b
	//                               (0xF8000000)
	//                              /            \
	//                         TMR-r               PMU-r
	//                    (0xF6300000)             (0xF8180000)
	//                      /      \               /           \
	//                SYSC-b       WDT-b         CMU-b         SRAM-b
	//            (0xF6100000)   (0xF6400000)  (0xF8100000)   (0xF8400000)
	//             /                                                  \
	//        GIC#0-r                                                  ROMC-r
	//    (0xF0000000)                                                (0xF84C0000)
	//             \
	//            GIC#1-r
	//          (0xF0002000)
	*/

	// while 수행 결과 rbtree를 순회 하여 COMB node를 rbtree에 추가함
	/*
	// 가상주소 va_start 기준으로 COMB 를 RB Tree 추가한 결과
	//
	//                                  CHID-b
	//                               (0xF8000000)
	//                              /            \
	//                         TMR-r               PMU-r
	//                    (0xF6300000)             (0xF8180000)
	//                      /      \               /           \
	//                GIC#1-b      WDT-b         CMU-b         SRAM-b
	//            (0xF0002000)   (0xF6400000)  (0xF8100000)   (0xF8400000)
	//             /       \                                          \
	//        GIC#0-r     SYSC-r                                       ROMC-r
	//    (0xF0000000)   (0xF6100000)                                 (0xF84C0000)
	//                   /
	//               COMB-r
	//          (0xF0004000)
	*/

	// while 수행 결과 rbtree를 순회 하여 CLK node를 rbtree에 추가함
	/*
	// 가상주소 va_start 기준으로 CLK 를 RB Tree 추가한 결과
	//
	//                                  CHID-b
	//                               (0xF8000000)
	//                              /            \
	//                         TMR-r               PMU-r
	//                    (0xF6300000)             (0xF8180000)
	//                      /      \               /           \
	//                GIC#1-b      WDT-b         CMU-b         SRAM-b
	//            (0xF0002000)   (0xF6400000)  (0xF8100000)   (0xF8400000)
	//             /       \                                          \
	//        GIC#0-r     SYSC-b                                       ROMC-r
	//    (0xF0000000)   (0xF6100000)                                 (0xF84C0000)
	//                   /
	//               COMB-r
	//          (0xF0004000)
	//                    \
	//                    CLK-r
	//                    (0xF0040000)
	*/

	// va->rb_node: (kmem_cache#30-o9)->rb_node, parent: NULL, p: &vmap_area_root.rb_node
	// va->rb_node: (kmem_cache#30-oX (GIC#0))->rb_node, parent: SYSC node, p: (SYSC node)->rb_left
	// va->rb_node: (kmem_cache#30-oX (GIC#1))->rb_node, parent: GIG#0 node, p: (GIG#0 node)->rb_right
	// va->rb_node: (kmem_cache#30-oX (COMB))->rb_node, parent: SYSC node, p: (SYSC node)->rb_left
	// va->rb_node: (kmem_cache#30-oX (CLK))->rb_node, parent: COMB node, p: (COMB node)->rb_right
	rb_link_node(&va->rb_node, parent, p);
	// vmap_area_root.rb_node: &(kmem_cache#30-o9)->rb_node
	// (SYSC node)->rb_left: &(GIC#0)->rb_node
	// vmap_area_root.rb_node: &(kmem_cache#30-o9)->rb_node
	// (GIG#0 node)->rb_right: &(GIC#1)->rb_node
	// vmap_area_root.rb_node: &(kmem_cache#30-o9)->rb_node
	// (SYSC node)->rb_left: &(COMB)->rb_node
	// vmap_area_root.rb_node: &(kmem_cache#30-o9)->rb_node
	// (COMB node)->rb_right: &(CLK)->rb_node

	// va->rb_node: (kmem_cache#30-o9)->rb_node
	// va->rb_node: (kmem_cache#30-oX (GIC#0))->rb_node
	// va->rb_node: (kmem_cache#30-oX (GIC#1))->rb_node
	// va->rb_node: (kmem_cache#30-oX (COMB))->rb_node
	// va->rb_node: (kmem_cache#30-oX (CLK))->rb_node
	rb_insert_color(&va->rb_node, &vmap_area_root);

	// rbtree 조건에 맞게 tree 구성 및 안정화 작업 수행
	/*
	// 가상주소 va_start 기준으로 GIC#0 를 RB Tree 추가한 결과
	//
	//                                  CHID-b
	//                               (0xF8000000)
	//                              /            \
	//                         TMR-r               PMU-r
	//                    (0xF6300000)             (0xF8180000)
	//                      /      \               /           \
	//                 SYSC-b      WDT-b         CMU-b         SRAM-b
	//            (0xF6100000)   (0xF6400000)  (0xF8100000)   (0xF8400000)
	//             /                                                 \
	//        GIC#0-r                                                 ROMC-r
	//    (0xF0000000)                                                (0xF84C0000)
	//
	*/

	// rbtree 조건에 맞게 tree 구성 및 안정화 작업 수행
	/*
	// 가상주소 va_start 기준으로 GIC#0 를 RB Tree 추가한 결과
	//
	//                                  CHID-b
	//                               (0xF8000000)
	//                              /            \
	//                         TMR-r               PMU-r
	//                    (0xF6300000)             (0xF8180000)
	//                      /      \               /           \
	//                GIC#1-b      WDT-b         CMU-b         SRAM-b
	//            (0xF0002000)   (0xF6400000)  (0xF8100000)   (0xF8400000)
	//             /       \                                          \
	//        GIC#0-r     SYSC-r                                       ROMC-r
	//    (0xF0000000)   (0xF6100000)                                 (0xF84C0000)
	//
	*/

	// rbtree 조건에 맞게 tree 구성 및 안정화 작업 수행
	/*
	// 가상주소 va_start 기준으로 COMB 를 RB Tree 추가한 결과
	//
	//                                  CHID-b
	//                               (0xF8000000)
	//                              /            \
	//                         TMR-b               PMU-b
	//                    (0xF6300000)             (0xF8180000)
	//                      /      \               /           \
	//                GIC#1-r      WDT-b         CMU-b         SRAM-b
	//            (0xF0002000)   (0xF6400000)  (0xF8100000)   (0xF8400000)
	//             /       \                                          \
	//        GIC#0-b     SYSC-b                                       ROMC-r
	//    (0xF0000000)   (0xF6100000)                                 (0xF84C0000)
	//                   /
	//               COMB-r
	//          (0xF0004000)
	*/

	// rbtree 조건에 맞게 tree 구성 및 안정화 작업 수행
	/*
	// 가상주소 va_start 기준으로 CLK 를 RB Tree 추가한 결과
	//
	//                                  CHID-b
	//                               (0xF8000000)
	//                              /            \
	//                         TMR-r               PMU-r
	//                    (0xF6300000)             (0xF8180000)
	//                      /      \               /           \
	//                GIC#1-b      WDT-b         CMU-b         SRAM-b
	//            (0xF0002000)   (0xF6400000)  (0xF8100000)   (0xF8400000)
	//             /       \                                          \
	//        GIC#0-r     CLK-b                                        ROMC-r
	//    (0xF0000000)   (0xF0040000)                                 (0xF84C0000)
	//                   /      \
	//               COMB-r     SYSC-r
	//          (0xF0004000)   (0xF6100000)
	*/

	/* address-sort this list */
	// va->rb_node: (kmem_cache#30-oX (GIC#0))->rb_node
	// rb_prev((kmem_cache#30-oX (GIC#0))->rb_node): NULL
	// va->rb_node: (kmem_cache#30-oX (GIC#1))->rb_node
	// rb_prev((kmem_cache#30-oX (GIC#1))->rb_node): (GIC#0)->rb_node
	// va->rb_node: (kmem_cache#30-oX (COMB))->rb_node
	// rb_prev((kmem_cache#30-oX (COMB))->rb_node): (GIC#1)->rb_node
	tmp = rb_prev(&va->rb_node);
	// tmp: NULL
	// tmp: (GIC#0)->rb_node
	// tmp: (GIC#1)->rb_node

	// tmp: NULL
	// tmp: (GIC#0)->rb_node
	// tmp: (GIC#1)->rb_node
	if (tmp) {
		struct vmap_area *prev;

		// tmp: (GIC#0)->rb_node
		// rb_entry((GIC#0)->rb_node, struct vmap_area, rb_node): GIC#0의 vmap_area의 시작주소
		// tmp: (GIC#1)->rb_node
		// rb_entry((GIC#1)->rb_node, struct vmap_area, rb_node): GIC#0의 vmap_area의 시작주소
		prev = rb_entry(tmp, struct vmap_area, rb_node);
		// prev: GIC#0의 vmap_area의 시작주소
		// prev: GIC#1의 vmap_area의 시작주소

		// &va->list: &(kmem_cache#30-oX (GIC#1))->list, &prev->list: &(GIC#0)->list
		// &va->list: &(kmem_cache#30-oX (COMB))->list, &prev->list: &(GIC#1)->list
		list_add_rcu(&va->list, &prev->list);
		// list_add_rcu에서 한일:
		// ((GIC#1)->list)->next: (SYSC)->list
		// ((GIC#1)->list)->prev: (GIC#0)->list
		// core간 write memory barrier 수행
		// ((*((struct list_head __rcu **)(&(&(GIC#0)->list)->next)))) =
		// (typeof(*&((GIC#1))->list) __force space *)(&((GIC#1))->list)
		// ((SYSC)->list)->prev: &(GIC#1)->list
		//
		// list_add_rcu에서 한일:
		// ((COMB)->list)->next: (SYSC)->list
		// ((COMB)->list)->prev: (GIC#0)->list
		// core간 write memory barrier 수행
		// ((*((struct list_head __rcu **)(&(&(GIC#1)->list)->next)))) =
		// (typeof(*&((COMB))->list) __force space *)(&((COMB))->list)
		// ((SYSC)->list)->prev: &(COMB)->list
	} else
		// &va->list: &(kmem_cache#30-oX (GIC))->list
		list_add_rcu(&va->list, &vmap_area_list);
		// list_add_rcu에서 한일:
		// ((GIC)->list)->next: (SYSC)->list
		// ((GIC)->list)->prev: &vmap_area_list
		// core간 write memory barrier 수행
		// ((*((struct list_head __rcu **)(&(&vmap_area_list)->next)))) =
		// (typeof(*&((GIC))->list) __force space *)(&((GIC))->list)
		// ((SYSC)->list)->prev: &(GIC)->list
}
```

## clk-exynos5420.c::exynos5420_clk_init()
*

```clk-exynos5420.c
/* register exynos5420 clocks */
// ARM10C 20150103
// devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
static void __init exynos5420_clk_init(struct device_node *np)
{
	void __iomem *reg_base;

// 2015/01/03 종료
// 2015/01/10 시작

	// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
	if (np) {
		// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
		reg_base = of_iomap(np, 0);
		if (!reg_base)
			panic("%s: failed to map registers\n", __func__);
	} else {
		panic("%s: unable to determine soc\n", __func__);
	}

    // np: devtree에서 찾은 clock node 주소
	// nr_clks: 769
	// exynos5420_clk_regs:
    // ARRAY_SIZE(exynos5420_clk_regs): 59
	samsung_clk_init(np, reg_base, nr_clks,
			exynos5420_clk_regs, ARRAY_SIZE(exynos5420_clk_regs),
			NULL, 0);
```

## clk.c::samsung_clk_init()

```clk.c
/* setup the essentials required to support clock lookup using ccf */
void __init samsung_clk_init(struct device_node *np, void __iomem *base,
		unsigned long nr_clks, unsigned long *rdump,
		unsigned long nr_rdump, unsigned long *soc_rdump,
		unsigned long nr_soc_rdump)
{
        // base: 0xf0040000
	reg_base = base;
        // reg_base: 0xf0040000

#ifdef CONFIG_PM_SLEEP // CONFIG_PM_SLEEP=y
	if (rdump && nr_rdump) {
		unsigned int idx;
		reg_dump = kzalloc(sizeof(struct samsung_clk_reg_dump)
				* (nr_rdump + nr_soc_rdump), GFP_KERNEL);
		// reg_dump: 472 이므로 
		if (!reg_dump) {
			pr_err("%s: memory alloc for register dump failed\n",
					__func__);
			return;
		}
```

## clk.c:: samsung_clk_syscore_ops
```clk.c
static struct syscore_ops samsung_clk_syscore_ops = {
	.suspend	= samsung_clk_suspend,
	.resume		= samsung_clk_resume,
};
```

## syscore.c::register_syscore_ops()
```syscore.c
void register_syscore_ops(struct syscore_ops *ops)
{
	mutex_lock(&syscore_ops_lock);
        // syscore_ops_lock으로 mutex lock실행

	list_add_tail(&ops->node, &syscore_ops_list);
        // &ops->node: (&samsung_clk_syscore_ops)->node를 추가. 
	mutex_unlock(&syscore_ops_lock);
        // syscore_ops_lock으로 mutex unlock실행
}
EXPORT_SYMBOL_GPL(register_syscore_ops);
```

## clk.c::clk_table

```clk.c
static struct clk **clk_table;
```

## clk.c::samsung_clk_init()

```clk.c
/* setup the essentials required to support clock lookup using ccf */
void __init samsung_clk_init(struct device_node *np, void __iomem *base,
		unsigned long nr_clks, unsigned long *rdump,
		unsigned long nr_rdump, unsigned long *soc_rdump,
		unsigned long nr_soc_rdump)
{
        // base: 0xf0040000
	reg_base = base;
        // reg_base: 0xf0040000

#ifdef CONFIG_PM_SLEEP // CONFIG_PM_SLEEP=y
	if (rdump && nr_rdump) {
		unsigned int idx;
		reg_dump = kzalloc(sizeof(struct samsung_clk_reg_dump)
				* (nr_rdump + nr_soc_rdump), GFP_KERNEL);
		// reg_dump: 472 이므로 
		if (!reg_dump) {
			pr_err("%s: memory alloc for register dump failed\n",
					__func__);
			return;
		}
		// nr_rdump: 59
		for (idx = 0; idx < nr_rdump; idx++)
		        // idx:0 reg_dump[0].offset: (kmem_cach#26-oX)[0].offset, 
		        // rdump[0]: exynos5420_clk_regs[0] 
			reg_dump[idx].offset = rdump[idx];
		// idx: 1...58까지 반복 실행
		for (idx = 0; idx < nr_soc_rdump; idx++)
		        // nr_rdump:59, idx: nr_soc_rdump: 0 
			reg_dump[nr_rdump + idx].offset = soc_rdump[idx];
		nr_reg_dump = nr_rdump + nr_soc_rdump;
		register_syscore_ops(&samsung_clk_syscore_ops);
	}
#endif

    // sizeof(struct clk *): 4, nr_clks: 59,
	// sizeof(struct clk *) * nr_clks: 3076
	clk_table = kzalloc(sizeof(struct clk *) * nr_clks, GFP_KERNEL);
	// kmem_cache#23-oX(4096B)

	if (!clk_table)
		panic("could not allocate clock lookup table\n");

	if (!np)
		return;

#ifdef CONFIG_OF // CONFIG_OF=y
	clk_data.clks = clk_table;
	// clk_data.clks: kmem_cache#23-o0 (clk_table)

	clk_data.clk_num = nr_clks;
	// clk_data.clk_num: 769

	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
#endif
}
```

## clk.c::of_clk_add_provider()

```clk.c
struct of_clk_provider {
	struct list_head link;

	struct device_node *node;
	struct clk *(*get)(struct of_phandle_args *clkspec, void *data);
	void *data;
};
```

```clk.c
int of_clk_add_provider(struct device_node *np,
			struct clk *(*clk_src_get)(struct of_phandle_args *clkspec,
						   void *data),
			void *data)
{
	struct of_clk_provider *cp;

	cp = kzalloc(sizeof(struct of_clk_provider), GFP_KERNEL);
	if (!cp)
		return -ENOMEM;

	cp->node = of_node_get(np);
	cp->data = data;
	cp->get = clk_src_get;

	mutex_lock(&of_clk_lock);
	list_add(&cp->link, &of_clk_providers);
	mutex_unlock(&of_clk_lock);
	pr_debug("Added clock from %s\n", np->full_name);

	return 0;
}
EXPORT_SYMBOL_GPL(of_clk_add_provider);
```

## 


# log
* 1st log

```
   5ad5c32..e5f8cd1  master     -> origin/master
Updating 5ad5c32..e5f8cd1
Fast-forward
arch/arm/include/asm/bitops.h        |   2 ++
arch/arm/include/asm/io.h            |   2 ++
arch/arm/mm/ioremap.c                |  37 +++++++++++++++++++++++
drivers/clk/samsung/clk-exynos5420.c |   1 +
drivers/of/address.c                 |  15 ++++++++++
include/linux/kernel.h               |   1 +
include/linux/list.h                 |   5 ++++
include/linux/rbtree.h               |   2 ++
include/uapi/linux/kernel.h          |   2 ++
lib/rbtree.c                         |   2 ++
mm/vmalloc.c                         | 123 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
11 files changed, 192 insertions(+)
```
