##### ARM10C   : 106 주차 
##### 일시     : 2015.06.20 (106 주차 스터디 진행)
##### 모임명   : NAVER개발자커뮤니티지원_10차ARM-C
##### 장소     : 토즈 타워점
##### 장소지원 : NAVER 개발자 커뮤니티 지원 프로그램
##### 참여인원 :  2명
============

## 106 주차 진도

* start_kernel        1  ~/kernel/iamroot/linux-stable/init/main.c
 - sched_clock_postinit   750  ~/kernel/iamroot/linux-stable/init/main.c
     3  1 hrtimer_start     364  ~/kernel/iamroot/linux-stable/kernel/time/sched_clock.c
	   4  1 __hrtimer_start_range_ns  1279  ~/kernel/iamroot/linux-stable/kernel/hrtimer.c
	     5  1 lock_hrtimer_base  1137  ~/kernel/iamroot/linux-stable/kernel/hrtimer.c
		   6  1 hrtimer_enqueue_reprogram  1223  ~/kernel/iamroot/linux-stable/kernel/hrtimer.c
		     7  1 hrtimer_reprogram   789  ~/kernel/iamroot/linux-stable/kernel/hrtimer.c
			   8  2 tick_program_event   753  ~/kernel/iamroot/linux-stable/kernel/hrtimer.c
			   
* start_kernel        1  ~/kernel/iamroot/linux-stable/init/main.c
 - sched_clock_postinit   750  ~/kernel/iamroot/linux-stable/init/main.c
  - hrtimer_start     364  ~/kernel/iamroot/linux-stable/kernel/time/sched_clock.c
   - __hrtimer_start_range_ns  1219  ~/kernel/iamroot/linux-stable/kernel/hrtimer.c
     - enqueue_hrtimer  1154  ~/kernel/iamroot/linux-stable/kernel/hrtimer.c
       - timerqueue_add   1001  ~/kernel/iamroot/linux-stable/kernel/hrtimer.c
         - rb_link_node       73  rb_link_node(&node->node, parent, p);

## main.c::main.c()
* called: start_kernel()

```main.c
asmlinkage void __init start_kernel(void)
{
...
	time_init();
	// timer 를 사용하기 위한 clk source, clk_table 메모리 할당 및 초기화,
	// timer event를 위한 timer irq (MCT) 초기화 수행

    sched_clock_postinit();
```

* call: start_kernel()->sched_clock_postinit()

## sched_clock.c::sched_clockinit()
* called: start_kernel()->sched_clock_postinit()

```sched_clock.c
// ARM10C 20150530
void __init sched_clock_postinit(void)
{
	/*
	 * If no sched_clock function has been provided at that point,
	 * make it the final one one.
	 */
	// read_sched_clock: jiffy_sched_clock_read
	if (read_sched_clock == jiffy_sched_clock_read)
		// BITS_PER_LONG: 32, HZ: 100
		sched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);

		// sched_clock_register에서 한일:
		// read_sched_clock: jiffy_sched_clock_read
		// sched_clock_mask: 0xFFFFFFFF
		// cd.rate: 100
		// cd.epoch_ns: 0
		// cd.epoch_cyc: 0
		// cd.wrap_kt: 0x42C1D83B9ACA00
		// (&cd)->mult: 0x98968000
		// (&cd)->shift: 8
		// (&cd.seq)->sequence: 2

	update_sched_clock();

	// update_sched_clock에서 한일:
	// cd.epoch_ns: 0
	// cd.epoch_cyc: 0
	// (&cd.seq)->sequence: 4

	/*
	 * Start the timer to keep sched_clock() properly updated and
	 * sets the initial epoch.
	 */
	// CLOCK_MONOTONIC: 1, HRTIMER_MODE_REL: 1
	hrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);

	// hrtimer_init에서 한일:
	// sched_clock_timer의 값을 0으로 초기화
	// (&sched_clock_timer)->base: &hrtimer_bases->clock_base[0]
	// RB Tree의 &(&sched_clock_timer)->node 를 초기화

	sched_clock_timer.function = sched_clock_poll;
	// sched_clock_timer.function: sched_clock_poll

	// cd.wrap_kt: 0x42C1D83B9ACA00, HRTIMER_MODE_REL: 1
	hrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);
```

* call: start_kernel()->sched_clock_postinit()->hrtimer_start()
 - hrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);

## sched_clock.c::sched_clock_register()
* call: start_kernel()->sched_clock_postinit()->hrtimer_start()
 - hrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);
 
```
// ARM10C 20150530
// &sched_clock_timer, cd.wrap_kt: 0x42C1D83B9ACA00, HRTIMER_MODE_REL: 1
int
hrtimer_start(struct hrtimer *timer, ktime_t tim, const enum hrtimer_mode mode)
{
	// timer: &sched_clock_timer, tim: 0x42C1D83B9ACA00, mode: 1
	return __hrtimer_start_range_ns(timer, tim, 0, mode, 1);
}
EXPORT_SYMBOL_GPL(hrtimer_start);
```

* call: start_kernel()->sched_clock_postinit()->hrtimer_start()->__hrtimer_start_range_ns()
 - return __hrtimer_start_range_ns(timer, tim, 0, mode, 1);
 
## hrtimer.c::__hrtimer_start_range_ns()
* called: start_kernel()->sched_clock_postinit()->hrtimer_start()->__hrtimer_start_range_ns()

```hrtimer.c
// ARM10C 20150530
// timer: &sched_clock_timer, tim: 0x42C1D83B9ACA00, 0, mode: 1, 1
int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
		unsigned long delta_ns, const enum hrtimer_mode mode,
		int wakeup)
{
	struct hrtimer_clock_base *base, *new_base;
	unsigned long flags;
	int ret, leftmost;

	// timer: &sched_clock_timer
	// lock_hrtimer_base(&sched_clock_timer, &flags): &hrtimer_bases->clock_base[0]
	base = lock_hrtimer_base(timer, &flags);
	// base: &hrtimer_bases->clock_base[0]

	// lock_hrtimer_base에서 한일:
	// (&sched_clock_timer)->base: &hrtimer_bases->clock_base[0] 을 리턴
	// flags에 cpsr값을 가져옴

	/* Remove an active timer from the queue: */
	// timer: &sched_clock_timer, base: &hrtimer_bases->clock_base[0]
	// remove_hrtimer(&sched_clock_timer, &hrtimer_bases->clock_base[0]): 0
	ret = remove_hrtimer(timer, base);
	// ret: 0

	/* Switch the timer base, if necessary: */
	// timer: &sched_clock_timer, base: &hrtimer_bases->clock_base[0], mode: 1,
	// HRTIMER_MODE_PINNED: 0x02
	// switch_hrtimer_base(&sched_clock_timer, &hrtimer_bases->clock_base[0], 0):
	// [pcp0] &(&hrtimer_bases)->clock_base[0]
	new_base = switch_hrtimer_base(timer, base, mode & HRTIMER_MODE_PINNED);
	// new_base: [pcp0] &(&hrtimer_bases)->clock_base[0]

	// mode: 1, HRTIMER_MODE_REL: 1
	if (mode & HRTIMER_MODE_REL) {
		// tim.tv64: 0x42C1D83B9ACA00,
		// new_base->get_time: [pcp0] (&(&hrtimer_bases)->clock_base[0])->get_time: &ktime_get,
		// ktime_get(): (ktime_t) { .tv64 = 0}
		// ktime_add_safe(0x42C1D83B9ACA00, (ktime_t) { .tv64 = 0}): (ktime_t) { .tv64 = 0x42C1D83B9ACA00}
		tim = ktime_add_safe(tim, new_base->get_time());
		// tim.tv64: 0x42C1D83B9ACA00

		/*
		 * CONFIG_TIME_LOW_RES is a temporary way for architectures
		 * to signal that they simply return xtime in
		 * do_gettimeoffset(). In this case we want to round up by
		 * resolution when starting a relative timer, to avoid short
		 * timeouts. This will go away with the GTOD framework.
		 */
#ifdef CONFIG_TIME_LOW_RES // CONFIG_TIME_LOW_RES=n
		tim = ktime_add_safe(tim, base->resolution);
#endif
	}

	// timer: &sched_clock_timer, tim: 0x42C1D83B9ACA00, delta_ns: 0
	hrtimer_set_expires_range_ns(timer, tim, delta_ns);

	// hrtimer_set_expires_range_ns에서 한일:
	// timer->_softexpires: (&sched_clock_timer)->_softexpires: 0x42C1D83B9ACA00
	// timer->node.expires: (&sched_clock_timer)->node.expires: 0x42C1D83B9ACA00

	// timer: &sched_clock_timer
	timer_stats_hrtimer_set_start_info(timer); // null function

	// timer: &sched_clock_timer, new_base: [pcp0] &(&hrtimer_bases)->clock_base[0]
	// enqueue_hrtimer(&sched_clock_timer, [pcp0] &(&hrtimer_bases)->clock_base[0]): 1
	leftmost = enqueue_hrtimer(timer, new_base);
	// leftmost: 1

	// enqueue_hrtimer에서 한일:
	// (&(&(&sched_clock_timer)->node)->node)->__rb_parent_color: NULL
	// (&(&(&sched_clock_timer)->node)->node)->rb_left: NULL
	// (&(&(&sched_clock_timer)->node)->node)->rb_right: NULL
	// [pcp0] (&(&(&hrtimer_bases)->clock_base[0])->active)->head.rb_node: &(&(&sched_clock_timer)->node)->node
	//
	// [pcp0] &(&(&(&hrtimer_bases)->clock_base[0])->active)->head 에 RB Tree 형태로
	// &(&(&sched_clock_timer)->node)->node 를 추가함
	//
	// [pcp0] &(&(&(&hrtimer_bases)->clock_base[0])->active)->next: &(&sched_clock_timer)->node
	// [pcp0] (&(&hrtimer_bases)->clock_base[0])->cpu_base->active_bases: 1
	//
	// (&sched_clock_timer)->state: 0x01

	// leftmost: 1, new_base->cpu_base: [pcp0] (&(&hrtimer_bases)->clock_base[0])->cpu_base: [pcp0] &hrtimer_bases,
	// &__get_cpu_var(hrtimer_bases): [pcp0] &hrtimer_bases
	// timer: &sched_clock_timer, new_base: [pcp0] &(&hrtimer_bases)->clock_base[0]
	if (leftmost && new_base->cpu_base == &__get_cpu_var(hrtimer_bases)
		&& hrtimer_enqueue_reprogram(timer, new_base)) {
		if (wakeup) {
			/*
			 * We need to drop cpu_base->lock to avoid a
			 * lock ordering issue vs. rq->lock.
			 */
			raw_spin_unlock(&new_base->cpu_base->lock);
			raise_softirq_irqoff(HRTIMER_SOFTIRQ);
			local_irq_restore(flags);
			return ret;
		} else {
			__raise_softirq_irqoff(HRTIMER_SOFTIRQ);
		}
	}


	unlock_hrtimer_base(timer, &flags);

    // ret: 0
	return ret;
	// return 0
}
```

* return: start_kernel()->sched_clock_postinit()
 - hrtimer_start()
  - __hrtimer_start_range_ns()
   - return 0

## hrtimer.c::hrtimer_start()
* return: start_kernel()->sched_clock_postinit()
 - hrtimer_start()
  - __hrtimer_start_range_ns()
   - return 0

```hrtimer.c
// ARM10C 20150530
// &sched_clock_timer, cd.wrap_kt: 0x42C1D83B9ACA00, HRTIMER_MODE_REL: 1
int
hrtimer_start(struct hrtimer *timer, ktime_t tim, const enum hrtimer_mode mode)
{
	// timer: &sched_clock_timer, tim: 0x42C1D83B9ACA00, mode: 1
	return __hrtimer_start_range_ns(timer, tim, 0, mode, 1);
}
EXPORT_SYMBOL_GPL(hrtimer_start);
```

## sched_clock.c::sched_clock_postinit()

```sched_clock.c
// ARM10C 20150530
void __init sched_clock_postinit(void)
{
	/*
	 * If no sched_clock function has been provided at that point,
	 * make it the final one one.
	 */
	// read_sched_clock: jiffy_sched_clock_read
	if (read_sched_clock == jiffy_sched_clock_read)
		// BITS_PER_LONG: 32, HZ: 100
		sched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);

		// sched_clock_register에서 한일:
		// read_sched_clock: jiffy_sched_clock_read
		// sched_clock_mask: 0xFFFFFFFF
		// cd.rate: 100
		// cd.epoch_ns: 0
		// cd.epoch_cyc: 0
		// cd.wrap_kt: 0x42C1D83B9ACA00
		// (&cd)->mult: 0x98968000
		// (&cd)->shift: 8
		// (&cd.seq)->sequence: 2

	update_sched_clock();

	// update_sched_clock에서 한일:
	// cd.epoch_ns: 0
	// cd.epoch_cyc: 0
	// (&cd.seq)->sequence: 4

	/*
	 * Start the timer to keep sched_clock() properly updated and
	 * sets the initial epoch.
	 */
	// CLOCK_MONOTONIC: 1, HRTIMER_MODE_REL: 1
	hrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);

	// hrtimer_init에서 한일:
	// sched_clock_timer의 값을 0으로 초기화
	// (&sched_clock_timer)->base: &hrtimer_bases->clock_base[0]
	// RB Tree의 &(&sched_clock_timer)->node 를 초기화

	sched_clock_timer.function = sched_clock_poll;
	// sched_clock_timer.function: sched_clock_poll

	// cd.wrap_kt: 0x42C1D83B9ACA00, HRTIMER_MODE_REL: 1
	hrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);
}
```

* sched_clock_postinit(); 에서 한일
 - sched_clock_timer을 초기화 수행


# log
* 1st log

```
   07692bc..b67cef4  master     -> origin/master
Updating 07692bc..b67cef4
Fast-forward
README.md                      |   2 +
arch/arm/include/asm/barrier.h |   1 +
include/asm-generic/current.h  |   1 +
include/asm-generic/percpu.h   |   1 +
include/linux/compiler.h       |   2 +
include/linux/hrtimer.h        |  20 +++++++
include/linux/irqflags.h       |   1 +
include/linux/ktime.h          |   9 ++++
include/linux/llist.h          |   5 ++
include/linux/lockdep.h        |   2 +
include/linux/rbtree.h         |   6 +++
include/linux/rcupdate.h       |  32 +++++++++++
include/linux/sched.h          |   2 +
include/linux/sched/sysctl.h   |   5 +-
include/linux/smp.h            |   1 +
include/linux/spinlock.h       |   2 +
include/linux/timerqueue.h     |   1 +
include/trace/events/timer.h   |   2 +
kernel/hrtimer.c               | 118 ++++++++++++++++++++++++++++++++++++++---
kernel/locking/lockdep.c       |  34 +++++++++++-
kernel/rcu/update.c            |   4 ++
kernel/sched/core.c            |  38 +++++++++++--
kernel/sched/sched.h           |  14 ++++-
kernel/time/sched_clock.c      |   1 +
kernel/time/timekeeping.c      |   1 +
lib/timerqueue.c               |  16 ++++++
26 files changed, 308 insertions(+), 13 deletions(-)
```

```
b67cef4..1829c7c  master     -> origin/master
Merge made by the 'recursive' strategy.
include/asm-generic/percpu.h |  1 +
include/linux/hrtimer.h      |  7 ++++++
include/linux/ktime.h        |  2 ++
include/linux/rbtree.h       |  8 +++++++
include/linux/timerqueue.h   |  1 +
kernel/hrtimer.c             | 54 +++++++++++++++++++++++++++++++++++++++++++-
lib/rbtree.c                 |  3 +++
lib/timerqueue.c             | 20 ++++++++++++++++
8 files changed, 95 insertions(+), 1 deletion(-)
```
