# ARM10C 88주차 후기
##### 일시 : 2015.01.24 (88주차)
##### 모임명 : NAVER개발자커뮤니티지원_10차ARM-C
##### 장소 : 토즈 타워점
##### 장소지원 : NAVER 개발자 커뮤니티 지원 프로그램
##### 참여인원 :  3명
============

## 88주차 진도
*  1 time_init         741  init/main.c
 1 of_clk_init       154  ~/kernel/iamroot/linux-stable/arch/arm/kernel/time.c
 1 exynos5420_clk_init  2800  // exynos5420_clk_init(devtree에서 allnext로 순회 하면서 찾은 clock node의 주소)
 1 samsung_clk_register_pll   974  ~/kernel/iamroot/linux-stable/drivers/clk/samsung/clk-exynos5420.c
 1 _samsung_clk_register_pll  1001  ~/kernel/iamroot/linux-stable/drivers/clk/samsung/clk-pll.c
 1 clk_register      925  ~/kernel/iamroot/linux-stable/drivers/clk/samsung/clk-pll.c
 1 _clk_register    2336  ret = _clk_register(dev, hw, clk);
 1 __clk_init       2249  ret = __clk_init(dev, clk);
 1 samsung_pll36xx_recalc_rate  2008  // samsung_pll

## time.c::time_init()

```time.c
// ARM10C 20150103
void __init time_init(void)
{
	// machine_desc->init_time: __mach_desc_EXYNOS5_DT.init_time: NULL
	if (machine_desc->init_time) {
		machine_desc->init_time();
	} else {
#ifdef CONFIG_COMMON_CLK // CONFIG_COMMON_CLK=y
		of_clk_init(NULL);
#endif
		clocksource_of_init();
	}
}
```

## clk.c::of_clk_init()

```clk.c
// ARM10C 20150103
// NULL
void __init of_clk_init(const struct of_device_id *matches)
{
	const struct of_device_id *match;
	struct device_node *np;

	// matches: NULL
	if (!matches)
		// __clk_of_table:
		// __clk_of_table_fixed_factor_clk
		// __clk_of_table_fixed_clk
		// __clk_of_table_exynos4210_audss_clk
		// __clk_of_table_exynos5250_audss_clk
		// __clk_of_table_exynos5420_clk
		matches = __clk_of_table;
		// matches:
		// __clk_of_table_fixed_factor_clk
		// __clk_of_table_fixed_clk
		// __clk_of_table_exynos4210_audss_clk
		// __clk_of_table_exynos5250_audss_clk
		// __clk_of_table_exynos5420_clk

	for_each_matching_node_and_match(np, matches, &match) {
	// for (np = of_find_matching_node_and_match(NULL, matches, &match);
	//      np; np = of_find_matching_node_and_match(np, matches, &match))

		// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소, match: __clk_of_table_exynos5420_clk

		// match->data: __clk_of_table_exynos5420_clk.data: exynos5420_clk_init
		of_clk_init_cb_t clk_init_cb = match->data;
		// clk_init_cb: exynos5420_clk_init

		// clk_init_cb: exynos5420_clk_init,
		// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
		// exynos5420_clk_init(devtree에서 allnext로 순회 하면서 찾은 clock node의 주소)
		clk_init_cb(np);
	}
}
#endif
```

## clk_exynos5420.c::exynos5420_clk_init()

```clk_exynos5420.c
/* register exynos5420 clocks */
// ARM10C 20150103
// devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
static void __init exynos5420_clk_init(struct device_node *np)
{
	void __iomem *reg_base;

// 2015/01/03 종료
// 2015/01/10 시작

	// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
	if (np) {
		// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
		// of_iomap(devtree에서 allnext로 순회 하면서 찾은 clock node의 주소, 0): 0xf0040000
		reg_base = of_iomap(np, 0);
		// reg_base: 0xf0040000

		// of_iomap에서 한일:
		// device tree 있는 clock node에서 node의 resource 값을 가져옴
		// of_address_to_resource에서 한일(index: 0):
		// (&res)->start: 0x10010000
		// (&res)->end: 0x1003ffff
		// (&res)->flags: IORESOURCE_MEM: 0x00000200
		// (&res)->name: "/clock-controller@10010000"
		/*
		// alloc area (CLK) 를 만들고 rb tree에 alloc area 를 추가
		// 가상주소 va_start 기준으로 CLK 를 RB Tree 추가한 결과
		//
		//                                  CHID-b
		//                               (0xF8000000)
		//                              /            \
		//                         TMR-b               PMU-b
		//                    (0xF6300000)             (0xF8180000)
		//                      /      \               /           \
		//                GIC#1-r      WDT-b         CMU-b         SRAM-b
		//            (0xF0002000)   (0xF6400000)  (0xF8100000)   (0xF8400000)
		//             /       \                                          \
		//        GIC#0-b     CLK-b                                        ROMC-r
		//    (0xF0000000)   (0xF0040000)                                 (0xF84C0000)
		//                   /      \
		//               COMB-r     SYSC-r
		//          (0xF0004000)   (0xF6100000)
		//
		// vmap_area_list에 GIC#0 - GIC#1 - COMB - CLK - SYSC -TMR - WDT - CHID - CMU - PMU - SRAM - ROMC
		// 순서로 리스트에 연결이 됨
		//
		// (kmem_cache#30-oX (vm_struct))->flags: GFP_KERNEL: 0xD0
		// (kmem_cache#30-oX (vm_struct))->addr: 0xf0040000
		// (kmem_cache#30-oX (vm_struct))->size: 0x31000
		// (kmem_cache#30-oX (vm_struct))->caller: __builtin_return_address(0)
		//
		// (kmem_cache#30-oX (vmap_area CLK))->vm: kmem_cache#30-oX (vm_struct)
		// (kmem_cache#30-oX (vmap_area CLK))->flags: 0x04
		*/
		// device tree 있는  clock node에서 node의 resource 값을 pgtable에 매핑함
		// 0xc0004780이 가리키는 pte의 시작주소에 0x10010653 값을 갱신
		// (linux pgtable과 hardware pgtable의 값 같이 갱신)
		//
		//  pgd                   pte
		// |              |
		// +--------------+
		// |              |       +--------------+ +0
		// |              |       |  0xXXXXXXXX  | ---> 0x10010653 에 매칭되는 linux pgtable 값
		// +- - - - - - - +       |  Linux pt 0  |
		// |              |       +--------------+ +1024
		// |              |       |              |
		// +--------------+ +0    |  Linux pt 1  |
		// | *(c0004780)  |-----> +--------------+ +2048
		// |              |       |  0x10010653  | ---> 2308
		// +- - - - - - - + +4    |   h/w pt 0   |
		// | *(c0004784)  |-----> +--------------+ +3072
		// |              |       +              +
		// +--------------+ +8    |   h/w pt 1   |
		// |              |       +--------------+ +4096
		//
		// cache의 값을 전부 메모리에 반영

		// reg_base: 0xf0040000
		if (!reg_base)
			panic("%s: failed to map registers\n", __func__);
	} else {
		panic("%s: unable to determine soc\n", __func__);
	}

	// np: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소, reg_base: 0xf0040000, nr_clks: 769
	// ARRAY_SIZE(exynos5420_clk_regs): 59
	samsung_clk_init(np, reg_base, nr_clks,
			exynos5420_clk_regs, ARRAY_SIZE(exynos5420_clk_regs),
			NULL, 0);

	// samsung_clk_init 에서 한일:
	// struct samsung_clk_reg_dump를 59개 만큼 메모리를 할당 받아
	// exynos5420_clk_regs의 값으로 맴버값 세팅
	// (kmem_cache#26-oX)[0...58].offset: exynos5420_clk_regs[0...58]
	//
	// syscore_ops_list의 tail에 (&samsung_clk_syscore_ops)->node 를 추가
	//
	// struct clk * 를 769개 만큼 메모리를 clk_table에 할당 받음
	// clk_table: kmem_cache#23-o0
	//
	// clk_data.clks: kmem_cache#23-o0 (clk_table)
	// clk_data.clk_num: 769
	//
	// struct of_clk_provider 의 메모리(kmem_cache#30-oX)를 할당 받고 맴버값 초기화 수행
	//
	// (kmem_cache#30-oX)->node: devtree에서 allnext로 순회 하면서 찾은 clock node의 주소
	// (kmem_cache#30-oX)->data: &clk_data
	// (kmem_cache#30-oX)->get: of_clk_src_onecell_get
	//
	// list인 of_clk_providers의 head에 (kmem_cache#30-oX)->link를 추가

	// ARRAY_SIZE(exynos5420_fixed_rate_ext_clks): 1
	samsung_clk_of_register_fixed_ext(exynos5420_fixed_rate_ext_clks,
			ARRAY_SIZE(exynos5420_fixed_rate_ext_clks),
			ext_clk_match);

	// samsung_clk_of_register_fixed_ext 에서 한일:
	//
	// devtree에서 allnext로 순회 하면서 찾은 fixed-rate-clocks node 에서
	// fixed-rate-clocks node에서 "clock-frequency" property값을 freq에 읽어옴
	// freq: 24000000
	// exynos5420_fixed_rate_ext_clks[0].fixed_rate: 24000000
	//
	// struct clk_fixed_rate 만큼 메모리를 kmem_cache#30-oX 할당 받고 struct clk_fixed_rate 의 멤버 값을 아래와 같이 초기화 수행
	//
	// (kmem_cache#30-oX)->fixed_rate: 24000000
	// (kmem_cache#30-oX)->hw.init: &init
	// (&(kmem_cache#30-oX)->hw)->clk: kmem_cache#29-oX
	//
	// struct clk 만큼 메모리를 kmem_cache#29-oX 할당 받고 struct clk 의 멤버 값을 아래와 같이 초기화 수행
	//
	// (kmem_cache#29-oX)->name: kmem_cache#30-oX ("fin_pll")
	// (kmem_cache#29-oX)->ops: &clk_fixed_rate_ops
	// (kmem_cache#29-oX)->hw: &(kmem_cache#30-oX)->hw
	// (kmem_cache#29-oX)->flags: 0x30
	// (kmem_cache#29-oX)->num_parents: 0
	// (kmem_cache#29-oX)->parent_names: ((void *)16)
	// (kmem_cache#29-oX)->parent: NULL
	// (kmem_cache#29-oX)->rate: 24000000
	//
	// (&(kmem_cache#29-oX)->child_node)->next: NULL
	// (&(kmem_cache#29-oX)->child_node)->pprev: &(&(kmem_cache#29-oX)->child_node)
	//
	// (&clk_root_list)->first: &(kmem_cache#29-oX)->child_node
	//
	// clk_table[1]: (kmem_cache#23-o0)[1]: kmem_cache#29-oX
	//
	// struct clk_lookup_alloc 의 메모리를 kmem_cache#30-oX 할당 받고
	// struct clk_lookup_alloc 맴버값 초기화 수행
	//
	// (kmem_cache#30-oX)->cl.clk: kmem_cache#29-oX
	// (kmem_cache#30-oX)->con_id: "fin_pll"
	// (kmem_cache#30-oX)->cl.con_id: (kmem_cache#30-oX)->con_id: "fin_pll"
	//
	// list clocks에 &(&(kmem_cache#30-oX)->cl)->nade를 tail로 추가

	// ARRAY_SIZE(exynos5420_plls): 11, reg_base: 0xf0040000
	samsung_clk_register_pll(exynos5420_plls, ARRAY_SIZE(exynos5420_plls),
					reg_base);
	samsung_clk_register_fixed_rate(exynos5420_fixed_rate_clks,
			ARRAY_SIZE(exynos5420_fixed_rate_clks));
	samsung_clk_register_fixed_factor(exynos5420_fixed_factor_clks,
			ARRAY_SIZE(exynos5420_fixed_factor_clks));
	samsung_clk_register_mux(exynos5420_mux_clks,
			ARRAY_SIZE(exynos5420_mux_clks));
	samsung_clk_register_div(exynos5420_div_clks,
			ARRAY_SIZE(exynos5420_div_clks));
	samsung_clk_register_gate(exynos5420_gate_clks,
			ARRAY_SIZE(exynos5420_gate_clks));
}
```

## clk-pll.c::samsung_clk_registar_pll()

```clk-pll.c
// ARM10C 20150117
// exynos5420_plls, ARRAY_SIZE(exynos5420_plls): 11, reg_base: 0xf0040000
void __init samsung_clk_register_pll(struct samsung_pll_clock *pll_list,
				unsigned int nr_pll, void __iomem *base)
{
	int cnt;

	// nr_pll: 11
	for (cnt = 0; cnt < nr_pll; cnt++)
		// cnt: 0, &pll_list[0]: &exynos5420_plls[0], base: 0xf0040000
		_samsung_clk_register_pll(&pll_list[cnt], base);

		// _samsung_clk_register_pll (&exynos5420_plls[0]) 에서 한일:
		//
		// struct clk_fixed_rate 만큼 메모리를 kmem_cache#30-oX (apll) 할당 받고 struct clk_fixed_rate 의 멤버 값을 아래와 같이 초기화 수행
		// pll: kmem_cache#30-oX (apll)
		//
		// (kmem_cache#30-oX (apll))->hw.init: &init
		// (kmem_cache#30-oX (apll))->type: pll_2550: 2
		// (kmem_cache#30-oX (apll))->lock_reg: 0xf0040000
		// (kmem_cache#30-oX (apll))->con_reg: 0xf0040100
		//
		// struct clk 만큼 메모리를 kmem_cache#29-oX (apll) 할당 받고 struct clk 의 멤버 값을 아래와 같이 초기화 수행
		//
		// (kmem_cache#29-oX (apll))->name: kmem_cache#30-oX ("fout_apll")
		// (kmem_cache#29-oX (apll))->ops: &samsung_pll35xx_clk_min_ops
		// (kmem_cache#29-oX (apll))->hw: &(kmem_cache#30-oX (apll))->hw
		// (kmem_cache#29-oX (apll))->flags: 0x40
		// (kmem_cache#29-oX (apll))->num_parents: 1
		// (kmem_cache#29-oX (apll))->parent_names: kmem_cache#30-oX
		// (kmem_cache#29-oX (apll))->parent_names[0]: (kmem_cache#30-oX)[0]: kmem_cache#30-oX: "fin_pll"
		// (kmem_cache#29-oX (apll))->parent: kmem_cache#29-oX (fin_pll)
		// (kmem_cache#29-oX (apll))->rate: 1000000000 (1 Ghz)
		//
		// (&(kmem_cache#29-oX (apll))->child_node)->next: NULL
		// (&(kmem_cache#29-oX (apll))->child_node)->pprev: &(&(kmem_cache#29-oX (apll))->child_node)
		//
		// (&(kmem_cache#29-oX (fin_pll))->children)->first: &(kmem_cache#29-oX (apll))->child_node
		//
		// (&(kmem_cache#30-oX (apll))->hw)->clk: kmem_cache#29-oX (apll)
		//
		// clk_table[2]: (kmem_cache#23-o0)[2]: kmem_cache#29-oX (apll)
		//
		// struct clk_lookup_alloc 의 메모리를 kmem_cache#30-oX (apll) 할당 받고
		// struct clk_lookup_alloc 맴버값 초기화 수행
		//
		// (kmem_cache#30-oX)->cl.clk: kmem_cache#29-oX (apll)
		// (kmem_cache#30-oX)->con_id: "fout_apll"
		// (kmem_cache#30-oX)->cl.con_id: (kmem_cache#30-oX)->con_id: "fout_apll"
		//
		// list clocks에 &(&(kmem_cache#30-oX (apll))->cl)->nade를 tail로 추가
}
```

## clk-pll.c::_samsung_clk_register_pll()

```clk-pll.c
// ARM10C 20150117
// &pll_list[0]: &exynos5420_plls[0], base: 0xf0040000
static void __init _samsung_clk_register_pll(struct samsung_pll_clock *pll_clk,
						void __iomem *base)
{
	struct samsung_clk_pll *pll;
	struct clk *clk;
	struct clk_init_data init;
	int ret, len;

	// sizeof(struct samsung_clk_pll): 28 bytes, GFP_KERNEL: 0xD0
	// kzalloc(28, GFP_KERNEL: 0xD0): kmem_cache#30-oX
	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
	// pll: kmem_cache#30-oX

	// pll: kmem_cache#30-oX
	if (!pll) {
		pr_err("%s: could not allocate pll clk %s\n",
			__func__, pll_clk->name);
		return;
	}

	// pll_clk->name: (&exynos5420_plls[0])->name: "fout_apll"
	init.name = pll_clk->name;
	// init.name: "fout_apll"

	// pll_clk->flags: (&exynos5420_plls[0])->flags: CLK_GET_RATE_NOCACHE: 0x40
	init.flags = pll_clk->flags;
	// init.flags: CLK_GET_RATE_NOCACHE: 0x40

	// pll_clk->parent_name: (&exynos5420_plls[0])->parent_name: "fin_pll"
	init.parent_names = &pll_clk->parent_name;
	// init.parent_names: "fin_pll"

	init.num_parents = 1;
	// init.num_parents: 1

	// pll_clk->rate_table: (&exynos5420_plls[0])->rate_table: NULL
	if (pll_clk->rate_table) {
		/* find count of rates in rate_table */
		for (len = 0; pll_clk->rate_table[len].rate != 0; )
			len++;

		pll->rate_count = len;
		pll->rate_table = kmemdup(pll_clk->rate_table,
					pll->rate_count *
					sizeof(struct samsung_pll_rate_table),
					GFP_KERNEL);
		WARN(!pll->rate_table,
			"%s: could not allocate rate table for %s\n",
			__func__, pll_clk->name);
	}

	// pll_clk->type: (&exynos5420_plls[0])->type: pll_2550: 2
	switch (pll_clk->type) {
	/* clk_ops for 35xx and 2550 are similar */
	case pll_35xx:
	case pll_2550:
		// pll->rate_table: (kmem_cache#30-oX)->rate_table: NULL
		if (!pll->rate_table)
			init.ops = &samsung_pll35xx_clk_min_ops;
			// init.ops: &samsung_pll35xx_clk_min_ops
		else
			init.ops = &samsung_pll35xx_clk_ops;
		break;
		// break

	case pll_4500:
		init.ops = &samsung_pll45xx_clk_min_ops;
		break;
	case pll_4502:
	case pll_4508:
		if (!pll->rate_table)
			init.ops = &samsung_pll45xx_clk_min_ops;
		else
			init.ops = &samsung_pll45xx_clk_ops;
		break;
	/* clk_ops for 36xx and 2650 are similar */
	case pll_36xx:
	case pll_2650:
		if (!pll->rate_table)
			init.ops = &samsung_pll36xx_clk_min_ops;
		else
			init.ops = &samsung_pll36xx_clk_ops;
		break;
	case pll_6552:
		init.ops = &samsung_pll6552_clk_ops;
		break;
	case pll_6553:
		init.ops = &samsung_pll6553_clk_ops;
		break;
	case pll_4600:
	case pll_4650:
	case pll_4650c:
		if (!pll->rate_table)
			init.ops = &samsung_pll46xx_clk_min_ops;
		else
			init.ops = &samsung_pll46xx_clk_ops;
		break;
	default:
		pr_warn("%s: Unknown pll type for pll clk %s\n",
			__func__, pll_clk->name);
	}

	// pll->hw.init: (kmem_cache#30-oX)->hw.init
	pll->hw.init = &init;
	// pll->hw.init: (kmem_cache#30-oX)->hw.init: &init

	// pll->type: (kmem_cache#30-oX)->type, pll_clk->type: (&exynos5420_plls[0])->type: pll_2550: 2
	pll->type = pll_clk->type;
	// pll->type: (kmem_cache#30-oX)->type: pll_2550: 2

	// pll->lock_reg: (kmem_cache#30-oX)->lock_reg, base: 0xf0040000,
	// pll_clk->lock_offset: (&exynos5420_plls[0])->lock_offset: APLL_LOCK: 0
	pll->lock_reg = base + pll_clk->lock_offset;
	// pll->lock_reg: (kmem_cache#30-oX)->lock_reg: 0xf0040000

	// pll->con_reg: (kmem_cache#30-oX)->con_reg, base: 0xf0040000,
	// pll_clk->con_offset: (&exynos5420_plls[0])->con_offset: APLL_CON0: 0x100
	pll->con_reg = base + pll_clk->con_offset;
	// pll->con_reg: (kmem_cache#30-oX)->con_reg: 0xf0040100

	// &pll->hw: &(kmem_cache#30-oX (apll))->hw
	// clk_register(&(kmem_cache#30-oX (apll))->hw): kmem_cache#29-oX (apll)
	clk = clk_register(NULL, &pll->hw);
	// clk: kmem_cache#29-oX (apll)

	// clk_register에서 한일:
	// struct clk 만큼 메모리를 kmem_cache#29-oX (apll) 할당 받고 struct clk 의 멤버 값을 아래와 같이 초기화 수행
	//
	// (kmem_cache#29-oX (apll))->name: kmem_cache#30-oX ("fout_apll")
	// (kmem_cache#29-oX (apll))->ops: &samsung_pll35xx_clk_min_ops
	// (kmem_cache#29-oX (apll))->hw: &(kmem_cache#30-oX (apll))->hw
	// (kmem_cache#29-oX (apll))->flags: 0x40
	// (kmem_cache#29-oX (apll))->num_parents: 1
	// (kmem_cache#29-oX (apll))->parent_names: kmem_cache#30-oX
	// (kmem_cache#29-oX (apll))->parent_names[0]: (kmem_cache#30-oX)[0]: kmem_cache#30-oX: "fin_pll"
	// (kmem_cache#29-oX (apll))->parent: kmem_cache#29-oX (fin_pll)
	// (kmem_cache#29-oX (apll))->rate: 1000000000 (1 Ghz)
	//
	// (&(kmem_cache#29-oX (apll))->child_node)->next: NULL
	// (&(kmem_cache#29-oX (apll))->child_node)->pprev: &(&(kmem_cache#29-oX (apll))->child_node)
	//
	// (&(kmem_cache#29-oX (fin_pll))->children)->first: &(kmem_cache#29-oX (apll))->child_node
	//
	// (&(kmem_cache#30-oX (apll))->hw)->clk: kmem_cache#29-oX (apll)

	// clk: kmem_cache#29-oX (apll), IS_ERR(kmem_cache#29-oX (apll)): 0
	if (IS_ERR(clk)) {
		pr_err("%s: failed to register pll clock %s : %ld\n",
			__func__, pll_clk->name, PTR_ERR(clk));
		kfree(pll);
		return;
	}

	// clk: kmem_cache#29-oX (apll), pll_clk->id: (&exynos5420_plls[0])->id: fout_apll: 2
	samsung_clk_add_lookup(clk, pll_clk->id);

	// samsung_clk_add_lookup에서 한일:
	// clk_table[2]: (kmem_cache#23-o0)[2]: kmem_cache#29-oX (apll)

	// pll_clk->alias: (&exynos5420_plls[0])->alias: "fout_apll"
	if (!pll_clk->alias)
		return;

	// clk: kmem_cache#29-oX (apll),
	// pll_clk->alias: (&exynos5420_plls[0])->alias: "fout_apll",
	// pll_clk->dev_name: (&exynos5420_plls[0])->dev_name: NULL
	// clk_register_clkdev(kmem_cache#29-oX (apll), "fout_apll", NULL): 0
	ret = clk_register_clkdev(clk, pll_clk->alias, pll_clk->dev_name);
	// ret: 0

	// clk_register_clkdev에서 한일:
	// struct clk_lookup_alloc 의 메모리를 kmem_cache#30-oX (apll) 할당 받고
	// struct clk_lookup_alloc 맴버값 초기화 수행
	//
	// (kmem_cache#30-oX)->cl.clk: kmem_cache#29-oX (apll)
	// (kmem_cache#30-oX)->con_id: "fout_apll"
	// (kmem_cache#30-oX)->cl.con_id: (kmem_cache#30-oX)->con_id: "fout_apll"
	//
	// list clocks에 &(&(kmem_cache#30-oX (apll))->cl)->nade를 tail로 추가

	// ret: 0
	if (ret)
		pr_err("%s: failed to register lookup for %s : %d",
			__func__, pll_clk->name, ret);
}
```

* clk = clk_register(NULL, &pll->hw);

## clk.c::__clk_init()

```clk.c
// ARM10C 20150117
// dev: NULL, clk: kmem_cache#29-oX
// ARM10C 20150117
// dev: NULL, clk: kmem_cache#29-oX (apll)
int __clk_init(struct device *dev, struct clk *clk)
{
	int i, ret = 0;
	// ret: 0
	// ret: 0

	struct clk *orphan;
	struct hlist_node *tmp2;

	// clk: kmem_cache#29-oX
	// clk: kmem_cache#29-oX (apll)
	if (!clk)
		return -EINVAL;

	clk_prepare_lock();

	// clk_prepare_lock 에서 한일:
	// &prepare_lock을 이용한 mutex lock 수행
	// prepare_owner: &init_task
	// prepare_refcnt: 1

	// clk_prepare_lock 에서 한일:
	// &prepare_lock을 이용한 mutex lock 수행
	// prepare_owner: &init_task
	// prepare_refcnt: 1

	/* check to see if a clock with this name is already registered */
	// clk->name: (kmem_cache#29-oX)->name: kmem_cache#30-oX ("fin_pll")
	// __clk_lookup(kmem_cache#30-oX): NULL
	// clk->name: (kmem_cache#29-oX (apll))->name: kmem_cache#30-oX ("fout_apll")
	// __clk_lookup(kmem_cache#30-oX (apll)): NULL
	if (__clk_lookup(clk->name)) {
		pr_debug("%s: clk %s already initialized\n",
				__func__, clk->name);
		ret = -EEXIST;
		goto out;
	}

	/* check that clk_ops are sane.  See Documentation/clk.txt */
	// clk->ops->set_rate: (kmem_cache#29-oX)->ops->set_rate: NULL,
	// clk->ops->round_rate: (kmem_cache#29-oX)->ops->round_rate: NULL,
	// clk->ops->determine_rate: (kmem_cache#29-oX)->ops->determine_rate: NULL,
	// clk->ops->recalc_rate: (kmem_cache#29-oX)->ops->recalc_rate: clk_fixed_rate_recalc_rate
	// clk->ops->set_rate: (kmem_cache#29-oX (apll))->ops->set_rate: NULL,
	// clk->ops->round_rate: (kmem_cache#29-oX (apll))->ops->round_rate: NULL,
	// clk->ops->determine_rate: (kmem_cache#29-oX (apll))->ops->determine_rate: NULL,
	// clk->ops->recalc_rate: (kmem_cache#29-oX (apll))->ops->recalc_rate: samsung_pll35xx_recalc_rate
	if (clk->ops->set_rate &&
	    !((clk->ops->round_rate || clk->ops->determine_rate) &&
	      clk->ops->recalc_rate)) {
		pr_warning("%s: %s must implement .round_rate or .determine_rate in addition to .recalc_rate\n",
				__func__, clk->name);
		ret = -EINVAL;
		goto out;
	}

	// clk->ops->set_parent: (kmem_cache#29-oX)->ops->set_parent: NULL,
	// clk->ops->get_parent: (kmem_cache#29-oX)->ops->get_parent: NULL
	// clk->ops->set_parent: (kmem_cache#29-oX (apll))->ops->set_parent: NULL,
	// clk->ops->get_parent: (kmem_cache#29-oX (apll))->ops->get_parent: NULL
	if (clk->ops->set_parent && !clk->ops->get_parent) {
		pr_warning("%s: %s must implement .get_parent & .set_parent\n",
				__func__, clk->name);
		ret = -EINVAL;
		goto out;
	}

	/* throw a WARN if any entries in parent_names are NULL */
	// clk->num_parents: (kmem_cache#29-oX)->num_parents: 0
	// clk->num_parents: (kmem_cache#29-oX (apll))->num_parents: 1
	for (i = 0; i < clk->num_parents; i++)
		// i: 0, clk->parent_names[0]: (kmem_cache#29-oX (apll))->parent_names[0]: (kmem_cache#30-oX)[0]: kmem_cache#30-oX: "fin_pll"
		WARN(!clk->parent_names[i],
				"%s: invalid NULL in %s's .parent_names\n",
				__func__, clk->name);

	/*
	 * Allocate an array of struct clk *'s to avoid unnecessary string
	 * look-ups of clk's possible parents.  This can fail for clocks passed
	 * in to clk_init during early boot; thus any access to clk->parents[]
	 * must always check for a NULL pointer and try to populate it if
	 * necessary.
	 *
	 * If clk->parents is not NULL we skip this entire block.  This allows
	 * for clock drivers to statically initialize clk->parents.
	 */
	// clk->num_parents: (kmem_cache#29-oX)->num_parents: 0,
	// clk->parents: (kmem_cache#29-oX)->parents: NULL
	// clk->num_parents: (kmem_cache#29-oX (apll))->num_parents: 1,
	// clk->parents: (kmem_cache#29-oX (apll))->parents: NULL
	if (clk->num_parents > 1 && !clk->parents) {
		clk->parents = kcalloc(clk->num_parents, sizeof(struct clk *),
					GFP_KERNEL);
		/*
		 * __clk_lookup returns NULL for parents that have not been
		 * clk_init'd; thus any access to clk->parents[] must check
		 * for a NULL pointer.  We can always perform lazy lookups for
		 * missing parents later on.
		 */
		if (clk->parents)
			for (i = 0; i < clk->num_parents; i++)
				clk->parents[i] =
					__clk_lookup(clk->parent_names[i]);
	}

	// clk->parent: (kmem_cache#29-oX)->parent, clk: kmem_cache#29-oX
	// __clk_init_parent(kmem_cache#29-oX): NULL
	// clk->parent: (kmem_cache#29-oX (apll))->parent, clk: kmem_cache#29-oX (apll)
	// __clk_init_parent(kmem_cache#29-oX (apll)): kmem_cache#29-oX (fin_pll)
	clk->parent = __clk_init_parent(clk);
	// clk->parent: (kmem_cache#29-oX)->parent: NULL
	// clk->parent: (kmem_cache#29-oX (apll))->parent: kmem_cache#29-oX (fin_pll)

	/*
	 * Populate clk->parent if parent has already been __clk_init'd.  If
	 * parent has not yet been __clk_init'd then place clk in the orphan
	 * list.  If clk has set the CLK_IS_ROOT flag then place it in the root
	 * clk list.
	 *
	 * Every time a new clk is clk_init'd then we walk the list of orphan
	 * clocks and re-parent any that are children of the clock currently
	 * being clk_init'd.
	 */
	// clk->parent: (kmem_cache#29-oX)->parent: NULL,
	// clk->flags: (kmem_cache#29-oX)->flags: 0x30
	// clk->parent: (kmem_cache#29-oX (apll))->parent: kmem_cache#29-oX (fin_pll)
	// clk->flags: (kmem_cache#29-oX (apll))->flags: 0x40
	if (clk->parent)
		// &clk->child_node: &(kmem_cache#29-oX (apll))->child_node,
		// &clk->parent->children: (&kmem_cache#29-oX (fin_pll))->children
		hlist_add_head(&clk->child_node,
				&clk->parent->children);

		// hlist_add_head에서 한일:
		// (&(kmem_cache#29-oX (apll))->child_node)->next: NULL
		// (&(kmem_cache#29-oX (apll))->child_node)->pprev: &(&(kmem_cache#29-oX (apll))->child_node)
		//
		// (&(kmem_cache#29-oX (fin_pll))->children)->first: &(kmem_cache#29-oX (apll))->child_node
	else if (clk->flags & CLK_IS_ROOT)
		// &clk->child_node: &(kmem_cache#29-oX)->child_node
		hlist_add_head(&clk->child_node, &clk_root_list);

		// hlist_add_head에서 한일:
		// (&(kmem_cache#29-oX)->child_node)->next: NULL
		// (&(kmem_cache#29-oX)->child_node)->pprev: &(&(kmem_cache#29-oX)->child_node)
		//
		// (&clk_root_list)->first: &(kmem_cache#29-oX)->child_node
	else
		hlist_add_head(&clk->child_node, &clk_orphan_list);

	/*
	 * Set clk's rate.  The preferred method is to use .recalc_rate.  For
	 * simple clocks and lazy developers the default fallback is to use the
	 * parent's rate.  If a clock doesn't have a parent (or is orphaned)
	 * then rate is set to zero.
	 */
// 2015/01/17 종료
```

```clk.c::__clk_init()
// 2015/01/24 시작

	// clk->ops->recalc_rate: (kmem_cache#29-oX)->ops->recalc_rate: clk_fixed_rate_recalc_rate
	// clk->ops->recalc_rate: (kmem_cache#29-oX (apll))->ops->recalc_rate: samsung_pll35xx_recalc_rate
	if (clk->ops->recalc_rate)
		// clk->rate: (kmem_cache#29-oX)->rate,
		// clk->ops->recalc_rate: (kmem_cache#29-oX)->ops->recalc_rate: clk_fixed_rate_recalc_rate
		// clk->hw: (kmem_cache#29-oX)->hw: &(kmem_cache#30-oX)->hw,
		// clk->parent: (kmem_cache#29-oX)->parent: NULL, __clk_get_rate(NULL): 0
		// clk_fixed_rate_recalc_rate(&(kmem_cache#30-oX)->hw, 0): 24000000
		// clk->rate: (kmem_cache#29-oX (apll))->rate,
		// clk->ops->recalc_rate: (kmem_cache#29-oX (apll))->ops->recalc_rate: samsung_pll35xx_recalc_rate
		// clk->hw: (kmem_cache#29-oX (apll))->hw: &(kmem_cache#30-oX (apll))->hw,
		// clk->parent: (kmem_cache#29-oX (apll))->parent: kmem_cache#29-oX (fin_pll),
		// __clk_get_rate(kmem_cache#29-oX (fin_pll)): 24000000
		// samsung_pll35xx_recalc_rate(&(kmem_cache#30-oX (apll))->hw, 24000000): 1000000000
		clk->rate = clk->ops->recalc_rate(clk->hw,
				__clk_get_rate(clk->parent));
		// clk->rate: (kmem_cache#29-oX)->rate: 24000000
		// clk->rate: (kmem_cache#29-oX (apll))->rate: 1000000000

	else if (clk->parent)
		clk->rate = clk->parent->rate;
	else
		clk->rate = 0;

	/*
	 * walk the list of orphan clocks and reparent any that are children of
	 * this clock
	 */
	hlist_for_each_entry_safe(orphan, tmp2, &clk_orphan_list, child_node) {
	// for (orphan = hlist_entry_safe((&clk_orphan_list)->first, typeof(*orphan), child_node);
	//      orphan && ({ tmp2 = orphan->child_node.next; 1; }); orphan = hlist_entry_safe(tmp2, typeof(*orphan), child_node))

		// hlist_entry_safe((&clk_orphan_list)->first, typeof(*orphan), child_node): NULL
		// orphan: NULL

		if (orphan->num_parents && orphan->ops->get_parent) {
			i = orphan->ops->get_parent(orphan->hw);
			if (!strcmp(clk->name, orphan->parent_names[i]))
				__clk_reparent(orphan, clk);
			continue;
		}

		for (i = 0; i < orphan->num_parents; i++)
			if (!strcmp(clk->name, orphan->parent_names[i])) {
				__clk_reparent(orphan, clk);
				break;
			}
	 }

	/*
	 * optional platform-specific magic
	 *
	 * The .init callback is not used by any of the basic clock types, but
	 * exists for weird hardware that must perform initialization magic.
	 * Please consider other ways of solving initialization problems before
	 * using this callback, as its use is discouraged.
	 */
	// clk->ops->init: (kmem_cache#29-oX)->ops->init: NULL
	// clk->ops->init: (kmem_cache#29-oX (apll))->ops->init: NULL
	if (clk->ops->init)
		clk->ops->init(clk->hw);

	// clk: kmem_cache#29-oX
	// clk: kmem_cache#29-oX (apll)
	clk_debug_register(clk); // null function

out:
	clk_prepare_unlock();

	// clk_prepare_unlock에서 한일:
	// prepare_refcnt: 0
	// prepare_owner: NULL
	// &prepare_lock을 이용한 mutex unlock 수행

	// clk_prepare_unlock에서 한일:
	// prepare_refcnt: 0
	// prepare_owner: NULL
	// &prepare_lock을 이용한 mutex unlock 수행

	// ret: 0
	// ret: 0
	return ret;
	// return 0
	// return 0
}
```

## clk-exynos5420.c

* exynos5420_fixed_rate_clks

```clk-exynos5420.c
static struct samsung_fixed_rate_clock exynos5420_fixed_rate_clks[] __initdata = {
	FRATE(sclk_hdmiphy, "sclk_hdmiphy", NULL, CLK_IS_ROOT, 24000000),
	FRATE(none, "sclk_pwi", NULL, CLK_IS_ROOT, 24000000),
	FRATE(none, "sclk_usbh20", NULL, CLK_IS_ROOT, 48000000),
	FRATE(none, "mphy_refclk_ixtal24", NULL, CLK_IS_ROOT, 48000000),
	FRATE(none, "sclk_usbh20_scan_clk", NULL, CLK_IS_ROOT, 480000000),
};
```

* exynos5420_fixed_factor_clks

```clk-exynos5420.c
static struct samsung_fixed_factor_clock exynos5420_fixed_factor_clks[] __initdata = {
	FFACTOR(none, "sclk_hsic_12m", "fin_pll", 1, 2, 0),
};
```

* exynos5420_fixed_factor_clks

```clk-exynos5420.c
static struct samsung_fixed_factor_clock exynos5420_fixed_factor_clks[] __initdata = {
	FFACTOR(none, "sclk_hsic_12m", "fin_pll", 1, 2, 0),
};
```

* exynos5420_mux_clks

```clk-exynos5420.c
static struct samsung_mux_clock exynos5420_mux_clks[] __initdata = {
	MUX(none, "mout_mspll_kfc", mspll_cpu_p, SRC_TOP7, 8, 2),
	MUX(none, "mout_mspll_cpu", mspll_cpu_p, SRC_TOP7, 12, 2),
	MUX(none, "mout_apll", apll_p, SRC_CPU, 0, 1),
	MUX(none, "mout_cpu", cpu_p, SRC_CPU, 16, 1),
	MUX(none, "mout_kpll", kpll_p, SRC_KFC, 0, 1),
	MUX(none, "mout_cpu_kfc", kfc_p, SRC_KFC, 16, 1),

	MUX(none, "sclk_bpll", bpll_p, SRC_CDREX, 0, 1),

	MUX_A(none, "mout_aclk400_mscl", group1_p,
			SRC_TOP0, 4, 2, "aclk400_mscl"),
	MUX(none, "mout_aclk200", group1_p, SRC_TOP0, 8, 2),
	MUX(none, "mout_aclk200_fsys2", group1_p, SRC_TOP0, 12, 2),
	MUX(none, "mout_aclk200_fsys", group1_p, SRC_TOP0, 28, 2),

	MUX(none, "mout_aclk333_432_gscl", group4_p, SRC_TOP1, 0, 2),
	MUX(none, "mout_aclk66", group1_p, SRC_TOP1, 8, 2),
	MUX(none, "mout_aclk266", group1_p, SRC_TOP1, 20, 2),
	MUX(none, "mout_aclk166", group1_p, SRC_TOP1, 24, 2),
	MUX(none, "mout_aclk333", group1_p, SRC_TOP1, 28, 2),

	MUX(none, "mout_aclk333_g2d", group1_p, SRC_TOP2, 8, 2),
	MUX(none, "mout_aclk266_g2d", group1_p, SRC_TOP2, 12, 2),
	MUX(none, "mout_aclk_g3d", group5_p, SRC_TOP2, 16, 1),
	MUX(none, "mout_aclk300_jpeg", group1_p, SRC_TOP2, 20, 2),
	MUX(none, "mout_aclk300_disp1", group1_p, SRC_TOP2, 24, 2),
	MUX(none, "mout_aclk300_gscl", group1_p, SRC_TOP2, 28, 2),

	MUX(none, "mout_user_aclk400_mscl", user_aclk400_mscl_p,
			SRC_TOP3, 4, 1),
	MUX_A(none, "mout_aclk200_disp1", aclk200_disp1_p,
			SRC_TOP3, 8, 1, "aclk200_disp1"),
	MUX(none, "mout_user_aclk200_fsys2", user_aclk200_fsys2_p,
			SRC_TOP3, 12, 1),
	MUX(none, "mout_user_aclk200_fsys", user_aclk200_fsys_p,
			SRC_TOP3, 28, 1),

	MUX(none, "mout_user_aclk333_432_gscl", user_aclk333_432_gscl_p,
			SRC_TOP4, 0, 1),
	MUX(none, "mout_aclk66_peric", aclk66_peric_p, SRC_TOP4, 8, 1),
	MUX(none, "mout_user_aclk266", user_aclk266_p, SRC_TOP4, 20, 1),
	MUX(none, "mout_user_aclk166", user_aclk166_p, SRC_TOP4, 24, 1),
	MUX(none, "mout_user_aclk333", user_aclk333_p, SRC_TOP4, 28, 1),

	MUX(none, "mout_aclk66_psgen", aclk66_peric_p, SRC_TOP5, 4, 1),
	MUX(none, "mout_user_aclk333_g2d", user_aclk333_g2d_p, SRC_TOP5, 8, 1),
	MUX(none, "mout_user_aclk266_g2d", user_aclk266_g2d_p, SRC_TOP5, 12, 1),
	MUX_A(none, "mout_user_aclk_g3d", user_aclk_g3d_p,
			SRC_TOP5, 16, 1, "aclkg3d"),
	MUX(none, "mout_user_aclk300_jpeg", user_aclk300_jpeg_p,
			SRC_TOP5, 20, 1),
	MUX(none, "mout_user_aclk300_disp1", user_aclk300_disp1_p,
			SRC_TOP5, 24, 1),
	MUX(none, "mout_user_aclk300_gscl", user_aclk300_gscl_p,
			SRC_TOP5, 28, 1),

	MUX(none, "sclk_mpll", mpll_p, SRC_TOP6, 0, 1),
	MUX(none, "sclk_vpll", vpll_p, SRC_TOP6, 4, 1),
	MUX(none, "sclk_spll", spll_p, SRC_TOP6, 8, 1),
	MUX(none, "sclk_ipll", ipll_p, SRC_TOP6, 12, 1),
	MUX(none, "sclk_rpll", rpll_p, SRC_TOP6, 16, 1),
	MUX(none, "sclk_epll", epll_p, SRC_TOP6, 20, 1),
	MUX(none, "sclk_dpll", dpll_p, SRC_TOP6, 24, 1),
	MUX(none, "sclk_cpll", cpll_p, SRC_TOP6, 28, 1),

	MUX(none, "mout_sw_aclk400_mscl", sw_aclk400_mscl_p, SRC_TOP10, 4, 1),
	MUX(none, "mout_sw_aclk200", sw_aclk200_p, SRC_TOP10, 8, 1),
	MUX(none, "mout_sw_aclk200_fsys2", sw_aclk200_fsys2_p,
			SRC_TOP10, 12, 1),
	MUX(none, "mout_sw_aclk200_fsys", sw_aclk200_fsys_p, SRC_TOP10, 28, 1),

	MUX(none, "mout_sw_aclk333_432_gscl", sw_aclk333_432_gscl_p,
			SRC_TOP11, 0, 1),
	MUX(none, "mout_sw_aclk66", sw_aclk66_p, SRC_TOP11, 8, 1),
	MUX(none, "mout_sw_aclk266", sw_aclk266_p, SRC_TOP11, 20, 1),
	MUX(none, "mout_sw_aclk166", sw_aclk166_p, SRC_TOP11, 24, 1),
	MUX(none, "mout_sw_aclk333", sw_aclk333_p, SRC_TOP11, 28, 1),

	MUX(none, "mout_sw_aclk333_g2d", sw_aclk333_g2d_p, SRC_TOP12, 8, 1),
	MUX(none, "mout_sw_aclk266_g2d", sw_aclk266_g2d_p, SRC_TOP12, 12, 1),
	MUX(none, "mout_sw_aclk_g3d", sw_aclk_g3d_p, SRC_TOP12, 16, 1),
	MUX(none, "mout_sw_aclk300_jpeg", sw_aclk300_jpeg_p, SRC_TOP12, 20, 1),
	MUX(none, "mout_sw_aclk300_disp1", sw_aclk300_disp1_p,
			SRC_TOP12, 24, 1),
	MUX(none, "mout_sw_aclk300_gscl", sw_aclk300_gscl_p, SRC_TOP12, 28, 1),

	/* DISP1 Block */
	MUX(none, "mout_fimd1", group3_p, SRC_DISP10, 4, 1),
	MUX(none, "mout_mipi1", group2_p, SRC_DISP10, 16, 3),
	MUX(none, "mout_dp1", group2_p, SRC_DISP10, 20, 3),
	MUX(none, "mout_pixel", group2_p, SRC_DISP10, 24, 3),
	MUX(mout_hdmi, "mout_hdmi", hdmi_p, SRC_DISP10, 28, 1),

	/* MAU Block */
	MUX(none, "mout_maudio0", maudio0_p, SRC_MAU, 28, 3),

	/* FSYS Block */
	MUX(none, "mout_usbd301", group2_p, SRC_FSYS, 4, 3),
	MUX(none, "mout_mmc0", group2_p, SRC_FSYS, 8, 3),
	MUX(none, "mout_mmc1", group2_p, SRC_FSYS, 12, 3),
	MUX(none, "mout_mmc2", group2_p, SRC_FSYS, 16, 3),
	MUX(none, "mout_usbd300", group2_p, SRC_FSYS, 20, 3),
	MUX(none, "mout_unipro", group2_p, SRC_FSYS, 24, 3),

	/* PERIC Block */
	MUX(none, "mout_uart0", group2_p, SRC_PERIC0, 4, 3),
	MUX(none, "mout_uart1", group2_p, SRC_PERIC0, 8, 3),
	MUX(none, "mout_uart2", group2_p, SRC_PERIC0, 12, 3),
	MUX(none, "mout_uart3", group2_p, SRC_PERIC0, 16, 3),
	MUX(none, "mout_pwm", group2_p, SRC_PERIC0, 24, 3),
	MUX(none, "mout_spdif", spdif_p, SRC_PERIC0, 28, 3),
	MUX(none, "mout_audio0", audio0_p, SRC_PERIC1, 8, 3),
	MUX(none, "mout_audio1", audio1_p, SRC_PERIC1, 12, 3),
	MUX(none, "mout_audio2", audio2_p, SRC_PERIC1, 16, 3),
	MUX(none, "mout_spi0", group2_p, SRC_PERIC1, 20, 3),
	MUX(none, "mout_spi1", group2_p, SRC_PERIC1, 24, 3),
	MUX(none, "mout_spi2", group2_p, SRC_PERIC1, 28, 3),
};
```

* exynos5420_div_clks

```clk-exynos5420.c
static struct samsung_div_clock exynos5420_div_clks[] __initdata = {
	DIV(none, "div_arm", "mout_cpu", DIV_CPU0, 0, 3),
	DIV(none, "sclk_apll", "mout_apll", DIV_CPU0, 24, 3),
	DIV(none, "armclk2", "div_arm", DIV_CPU0, 28, 3),
	DIV(none, "div_kfc", "mout_cpu_kfc", DIV_KFC0, 0, 3),
	DIV(none, "sclk_kpll", "mout_kpll", DIV_KFC0, 24, 3),

	DIV(none, "dout_aclk400_mscl", "mout_aclk400_mscl", DIV_TOP0, 4, 3),
	DIV(none, "dout_aclk200", "mout_aclk200", DIV_TOP0, 8, 3),
	DIV(none, "dout_aclk200_fsys2", "mout_aclk200_fsys2", DIV_TOP0, 12, 3),
	DIV(none, "dout_pclk200_fsys", "mout_pclk200_fsys", DIV_TOP0, 24, 3),
	DIV(none, "dout_aclk200_fsys", "mout_aclk200_fsys", DIV_TOP0, 28, 3),

	DIV(none, "dout_aclk333_432_gscl", "mout_aclk333_432_gscl",
			DIV_TOP1, 0, 3),
	DIV(none, "dout_aclk66", "mout_aclk66", DIV_TOP1, 8, 6),
	DIV(none, "dout_aclk266", "mout_aclk266", DIV_TOP1, 20, 3),
	DIV(none, "dout_aclk166", "mout_aclk166", DIV_TOP1, 24, 3),
	DIV(none, "dout_aclk333", "mout_aclk333", DIV_TOP1, 28, 3),

	DIV(none, "dout_aclk333_g2d", "mout_aclk333_g2d", DIV_TOP2, 8, 3),
	DIV(none, "dout_aclk266_g2d", "mout_aclk266_g2d", DIV_TOP2, 12, 3),
	DIV(none, "dout_aclk_g3d", "mout_aclk_g3d", DIV_TOP2, 16, 3),
	DIV(none, "dout_aclk300_jpeg", "mout_aclk300_jpeg", DIV_TOP2, 20, 3),
	DIV_A(none, "dout_aclk300_disp1", "mout_aclk300_disp1",
			DIV_TOP2, 24, 3, "aclk300_disp1"),
	DIV(none, "dout_aclk300_gscl", "mout_aclk300_gscl", DIV_TOP2, 28, 3),

	/* DISP1 Block */
	DIV(none, "dout_fimd1", "mout_fimd1", DIV_DISP10, 0, 4),
	DIV(none, "dout_mipi1", "mout_mipi1", DIV_DISP10, 16, 8),
	DIV(none, "dout_dp1", "mout_dp1", DIV_DISP10, 24, 4),
	DIV(dout_pixel, "dout_hdmi_pixel", "mout_pixel", DIV_DISP10, 28, 4),

	/* Audio Block */
	DIV(none, "dout_maudio0", "mout_maudio0", DIV_MAU, 20, 4),
	DIV(none, "dout_maupcm0", "dout_maudio0", DIV_MAU, 24, 8),

	/* USB3.0 */
	DIV(none, "dout_usbphy301", "mout_usbd301", DIV_FSYS0, 12, 4),
	DIV(none, "dout_usbphy300", "mout_usbd300", DIV_FSYS0, 16, 4),
	DIV(none, "dout_usbd301", "mout_usbd301", DIV_FSYS0, 20, 4),
	DIV(none, "dout_usbd300", "mout_usbd300", DIV_FSYS0, 24, 4),

	/* MMC */
	DIV(none, "dout_mmc0", "mout_mmc0", DIV_FSYS1, 0, 10),
	DIV(none, "dout_mmc1", "mout_mmc1", DIV_FSYS1, 10, 10),
	DIV(none, "dout_mmc2", "mout_mmc2", DIV_FSYS1, 20, 10),

	DIV(none, "dout_unipro", "mout_unipro", DIV_FSYS2, 24, 8),

	/* UART and PWM */
	DIV(none, "dout_uart0", "mout_uart0", DIV_PERIC0, 8, 4),
	DIV(none, "dout_uart1", "mout_uart1", DIV_PERIC0, 12, 4),
	DIV(none, "dout_uart2", "mout_uart2", DIV_PERIC0, 16, 4),
	DIV(none, "dout_uart3", "mout_uart3", DIV_PERIC0, 20, 4),
	DIV(none, "dout_pwm", "mout_pwm", DIV_PERIC0, 28, 4),

	/* SPI */
	DIV(none, "dout_spi0", "mout_spi0", DIV_PERIC1, 20, 4),
	DIV(none, "dout_spi1", "mout_spi1", DIV_PERIC1, 24, 4),
	DIV(none, "dout_spi2", "mout_spi2", DIV_PERIC1, 28, 4),

	/* PCM */
	DIV(none, "dout_pcm1", "dout_audio1", DIV_PERIC2, 16, 8),
	DIV(none, "dout_pcm2", "dout_audio2", DIV_PERIC2, 24, 8),

	/* Audio - I2S */
	DIV(none, "dout_i2s1", "dout_audio1", DIV_PERIC3, 6, 6),
	DIV(none, "dout_i2s2", "dout_audio2", DIV_PERIC3, 12, 6),
	DIV(none, "dout_audio0", "mout_audio0", DIV_PERIC3, 20, 4),
	DIV(none, "dout_audio1", "mout_audio1", DIV_PERIC3, 24, 4),
	DIV(none, "dout_audio2", "mout_audio2", DIV_PERIC3, 28, 4),

	/* SPI Pre-Ratio */
	DIV(none, "dout_pre_spi0", "dout_spi0", DIV_PERIC4, 8, 8),
	DIV(none, "dout_pre_spi1", "dout_spi1", DIV_PERIC4, 16, 8),
	DIV(none, "dout_pre_spi2", "dout_spi2", DIV_PERIC4, 24, 8),
};
```

```clk-exynos5420.c
static struct samsung_gate_clock exynos5420_gate_clks[] __initdata = {
	/* TODO: Re-verify the CG bits for all the gate clocks */
	GATE_A(mct, "pclk_st", "aclk66_psgen", GATE_BUS_PERIS1, 2, 0, 0, "mct"),

	GATE(0, "aclk200_fsys", "mout_user_aclk200_fsys",
			GATE_BUS_FSYS0, 9, CLK_IGNORE_UNUSED, 0),
	GATE(0, "aclk200_fsys2", "mout_user_aclk200_fsys2",
			GATE_BUS_FSYS0, 10, CLK_IGNORE_UNUSED, 0),

	GATE(0, "aclk333_g2d", "mout_user_aclk333_g2d",
			GATE_BUS_TOP, 0, CLK_IGNORE_UNUSED, 0),
	GATE(0, "aclk266_g2d", "mout_user_aclk266_g2d",
			GATE_BUS_TOP, 1, CLK_IGNORE_UNUSED, 0),
	GATE(0, "aclk300_jpeg", "mout_user_aclk300_jpeg",
			GATE_BUS_TOP, 4, CLK_IGNORE_UNUSED, 0),
	GATE(0, "aclk300_gscl", "mout_user_aclk300_gscl",
			GATE_BUS_TOP, 6, CLK_IGNORE_UNUSED, 0),
	GATE(0, "aclk333_432_gscl", "mout_user_aclk333_432_gscl",
			GATE_BUS_TOP, 7, CLK_IGNORE_UNUSED, 0),
	GATE(0, "pclk66_gpio", "mout_sw_aclk66",
			GATE_BUS_TOP, 9, CLK_IGNORE_UNUSED, 0),
	GATE(0, "aclk66_psgen", "mout_aclk66_psgen",
			GATE_BUS_TOP, 10, CLK_IGNORE_UNUSED, 0),
	GATE(0, "aclk66_peric", "mout_aclk66_peric",
			GATE_BUS_TOP, 11, 0, 0),
	GATE(0, "aclk166", "mout_user_aclk166",
			GATE_BUS_TOP, 14, CLK_IGNORE_UNUSED, 0),
	GATE(0, "aclk333", "mout_aclk333",
			GATE_BUS_TOP, 15, CLK_IGNORE_UNUSED, 0),

	/* sclk */
	GATE(sclk_uart0, "sclk_uart0", "dout_uart0",
		GATE_TOP_SCLK_PERIC, 0, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_uart1, "sclk_uart1", "dout_uart1",
		GATE_TOP_SCLK_PERIC, 1, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_uart2, "sclk_uart2", "dout_uart2",
		GATE_TOP_SCLK_PERIC, 2, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_uart3, "sclk_uart3", "dout_uart3",
		GATE_TOP_SCLK_PERIC, 3, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_spi0, "sclk_spi0", "dout_pre_spi0",
		GATE_TOP_SCLK_PERIC, 6, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_spi1, "sclk_spi1", "dout_pre_spi1",
		GATE_TOP_SCLK_PERIC, 7, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_spi2, "sclk_spi2", "dout_pre_spi2",
		GATE_TOP_SCLK_PERIC, 8, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_spdif, "sclk_spdif", "mout_spdif",
		GATE_TOP_SCLK_PERIC, 9, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_pwm, "sclk_pwm", "dout_pwm",
		GATE_TOP_SCLK_PERIC, 11, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_pcm1, "sclk_pcm1", "dout_pcm1",
		GATE_TOP_SCLK_PERIC, 15, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_pcm2, "sclk_pcm2", "dout_pcm2",
		GATE_TOP_SCLK_PERIC, 16, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_i2s1, "sclk_i2s1", "dout_i2s1",
		GATE_TOP_SCLK_PERIC, 17, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_i2s2, "sclk_i2s2", "dout_i2s2",
		GATE_TOP_SCLK_PERIC, 18, CLK_SET_RATE_PARENT, 0),

	GATE(sclk_mmc0, "sclk_mmc0", "dout_mmc0",
		GATE_TOP_SCLK_FSYS, 0, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_mmc1, "sclk_mmc1", "dout_mmc1",
		GATE_TOP_SCLK_FSYS, 1, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_mmc2, "sclk_mmc2", "dout_mmc2",
		GATE_TOP_SCLK_FSYS, 2, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_usbphy301, "sclk_usbphy301", "dout_usbphy301",
		GATE_TOP_SCLK_FSYS, 7, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_usbphy300, "sclk_usbphy300", "dout_usbphy300",
		GATE_TOP_SCLK_FSYS, 8, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_usbd300, "sclk_usbd300", "dout_usbd300",
		GATE_TOP_SCLK_FSYS, 9, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_usbd301, "sclk_usbd301", "dout_usbd301",
		GATE_TOP_SCLK_FSYS, 10, CLK_SET_RATE_PARENT, 0),

	GATE(sclk_usbd301, "sclk_unipro", "dout_unipro",
		SRC_MASK_FSYS, 24, CLK_SET_RATE_PARENT, 0),

	GATE(sclk_gscl_wa, "sclk_gscl_wa", "aclK333_432_gscl",
		GATE_TOP_SCLK_GSCL, 6, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_gscl_wb, "sclk_gscl_wb", "aclk333_432_gscl",
		GATE_TOP_SCLK_GSCL, 7, CLK_SET_RATE_PARENT, 0),

	/* Display */
	GATE(sclk_fimd1, "sclk_fimd1", "dout_fimd1",
		GATE_TOP_SCLK_DISP1, 0, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_mipi1, "sclk_mipi1", "dout_mipi1",
		GATE_TOP_SCLK_DISP1, 3, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_hdmi, "sclk_hdmi", "mout_hdmi",
		GATE_TOP_SCLK_DISP1, 9, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_pixel, "sclk_pixel", "dout_hdmi_pixel",
		GATE_TOP_SCLK_DISP1, 10, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_dp1, "sclk_dp1", "dout_dp1",
		GATE_TOP_SCLK_DISP1, 20, CLK_SET_RATE_PARENT, 0),

	/* Maudio Block */
	GATE(sclk_maudio0, "sclk_maudio0", "dout_maudio0",
		GATE_TOP_SCLK_MAU, 0, CLK_SET_RATE_PARENT, 0),
	GATE(sclk_maupcm0, "sclk_maupcm0", "dout_maupcm0",
		GATE_TOP_SCLK_MAU, 1, CLK_SET_RATE_PARENT, 0),
	/* FSYS */
	GATE(tsi, "tsi", "aclk200_fsys", GATE_BUS_FSYS0, 0, 0, 0),
	GATE(pdma0, "pdma0", "aclk200_fsys", GATE_BUS_FSYS0, 1, 0, 0),
	GATE(pdma1, "pdma1", "aclk200_fsys", GATE_BUS_FSYS0, 2, 0, 0),
	GATE(ufs, "ufs", "aclk200_fsys2", GATE_BUS_FSYS0, 3, 0, 0),
	GATE(rtic, "rtic", "aclk200_fsys", GATE_BUS_FSYS0, 5, 0, 0),
	GATE(mmc0, "mmc0", "aclk200_fsys2", GATE_BUS_FSYS0, 12, 0, 0),
	GATE(mmc1, "mmc1", "aclk200_fsys2", GATE_BUS_FSYS0, 13, 0, 0),
	GATE(mmc2, "mmc2", "aclk200_fsys2", GATE_BUS_FSYS0, 14, 0, 0),
	GATE(sromc, "sromc", "aclk200_fsys2",
			GATE_BUS_FSYS0, 19, CLK_IGNORE_UNUSED, 0),
	GATE(usbh20, "usbh20", "aclk200_fsys", GATE_BUS_FSYS0, 20, 0, 0),
	GATE(usbd300, "usbd300", "aclk200_fsys", GATE_BUS_FSYS0, 21, 0, 0),
	GATE(usbd301, "usbd301", "aclk200_fsys", GATE_BUS_FSYS0, 28, 0, 0),

	/* UART */
	GATE(uart0, "uart0", "aclk66_peric", GATE_BUS_PERIC, 4, 0, 0),
	GATE(uart1, "uart1", "aclk66_peric", GATE_BUS_PERIC, 5, 0, 0),
	GATE_A(uart2, "uart2", "aclk66_peric",
		GATE_BUS_PERIC, 6, CLK_IGNORE_UNUSED, 0, "uart2"),
	GATE(uart3, "uart3", "aclk66_peric", GATE_BUS_PERIC, 7, 0, 0),
	/* I2C */
	GATE(i2c0, "i2c0", "aclk66_peric", GATE_BUS_PERIC, 9, 0, 0),
	GATE(i2c1, "i2c1", "aclk66_peric", GATE_BUS_PERIC, 10, 0, 0),
	GATE(i2c2, "i2c2", "aclk66_peric", GATE_BUS_PERIC, 11, 0, 0),
	GATE(i2c3, "i2c3", "aclk66_peric", GATE_BUS_PERIC, 12, 0, 0),
	GATE(i2c4, "i2c4", "aclk66_peric", GATE_BUS_PERIC, 13, 0, 0),
	GATE(i2c5, "i2c5", "aclk66_peric", GATE_BUS_PERIC, 14, 0, 0),
	GATE(i2c6, "i2c6", "aclk66_peric", GATE_BUS_PERIC, 15, 0, 0),
	GATE(i2c7, "i2c7", "aclk66_peric", GATE_BUS_PERIC, 16, 0, 0),
	GATE(i2c_hdmi, "i2c_hdmi", "aclk66_peric", GATE_BUS_PERIC, 17, 0, 0),
	GATE(tsadc, "tsadc", "aclk66_peric", GATE_BUS_PERIC, 18, 0, 0),
	/* SPI */
	GATE(spi0, "spi0", "aclk66_peric", GATE_BUS_PERIC, 19, 0, 0),
	GATE(spi1, "spi1", "aclk66_peric", GATE_BUS_PERIC, 20, 0, 0),
	GATE(spi2, "spi2", "aclk66_peric", GATE_BUS_PERIC, 21, 0, 0),
	GATE(keyif, "keyif", "aclk66_peric", GATE_BUS_PERIC, 22, 0, 0),
	/* I2S */
	GATE(i2s1, "i2s1", "aclk66_peric", GATE_BUS_PERIC, 23, 0, 0),
	GATE(i2s2, "i2s2", "aclk66_peric", GATE_BUS_PERIC, 24, 0, 0),
	/* PCM */
	GATE(pcm1, "pcm1", "aclk66_peric", GATE_BUS_PERIC, 25, 0, 0),
	GATE(pcm2, "pcm2", "aclk66_peric", GATE_BUS_PERIC, 26, 0, 0),
	/* PWM */
	GATE(pwm, "pwm", "aclk66_peric", GATE_BUS_PERIC, 27, 0, 0),
	/* SPDIF */
	GATE(spdif, "spdif", "aclk66_peric", GATE_BUS_PERIC, 29, 0, 0),

	GATE(i2c8, "i2c8", "aclk66_peric", GATE_BUS_PERIC1, 0, 0, 0),
	GATE(i2c9, "i2c9", "aclk66_peric", GATE_BUS_PERIC1, 1, 0, 0),
	GATE(i2c10, "i2c10", "aclk66_peric", GATE_BUS_PERIC1, 2, 0, 0),

	GATE(chipid, "chipid", "aclk66_psgen",
			GATE_BUS_PERIS0, 12, CLK_IGNORE_UNUSED, 0),
	GATE(sysreg, "sysreg", "aclk66_psgen",
			GATE_BUS_PERIS0, 13, CLK_IGNORE_UNUSED, 0),
	GATE(tzpc0, "tzpc0", "aclk66_psgen", GATE_BUS_PERIS0, 18, 0, 0),
	GATE(tzpc1, "tzpc1", "aclk66_psgen", GATE_BUS_PERIS0, 19, 0, 0),
	GATE(tzpc2, "tzpc2", "aclk66_psgen", GATE_BUS_PERIS0, 20, 0, 0),
	GATE(tzpc3, "tzpc3", "aclk66_psgen", GATE_BUS_PERIS0, 21, 0, 0),
	GATE(tzpc4, "tzpc4", "aclk66_psgen", GATE_BUS_PERIS0, 22, 0, 0),
	GATE(tzpc5, "tzpc5", "aclk66_psgen", GATE_BUS_PERIS0, 23, 0, 0),
	GATE(tzpc6, "tzpc6", "aclk66_psgen", GATE_BUS_PERIS0, 24, 0, 0),
	GATE(tzpc7, "tzpc7", "aclk66_psgen", GATE_BUS_PERIS0, 25, 0, 0),
	GATE(tzpc8, "tzpc8", "aclk66_psgen", GATE_BUS_PERIS0, 26, 0, 0),
	GATE(tzpc9, "tzpc9", "aclk66_psgen", GATE_BUS_PERIS0, 27, 0, 0),

	GATE(hdmi_cec, "hdmi_cec", "aclk66_psgen", GATE_BUS_PERIS1, 0, 0, 0),
	GATE(seckey, "seckey", "aclk66_psgen", GATE_BUS_PERIS1, 1, 0, 0),
	GATE(wdt, "wdt", "aclk66_psgen", GATE_BUS_PERIS1, 3, 0, 0),
	GATE(rtc, "rtc", "aclk66_psgen", GATE_BUS_PERIS1, 4, 0, 0),
	GATE(tmu, "tmu", "aclk66_psgen", GATE_BUS_PERIS1, 5, 0, 0),
	GATE(tmu_gpu, "tmu_gpu", "aclk66_psgen", GATE_BUS_PERIS1, 6, 0, 0),

	GATE(gscl0, "gscl0", "aclk300_gscl", GATE_IP_GSCL0, 0, 0, 0),
	GATE(gscl1, "gscl1", "aclk300_gscl", GATE_IP_GSCL0, 1, 0, 0),
	GATE(clk_3aa, "clk_3aa", "aclk300_gscl", GATE_IP_GSCL0, 4, 0, 0),

	GATE(smmu_3aa, "smmu_3aa", "aclk333_432_gscl", GATE_IP_GSCL1, 2, 0, 0),
	GATE(smmu_fimcl0, "smmu_fimcl0", "aclk333_432_gscl",
			GATE_IP_GSCL1, 3, 0, 0),
	GATE(smmu_fimcl1, "smmu_fimcl1", "aclk333_432_gscl",
			GATE_IP_GSCL1, 4, 0, 0),
	GATE(smmu_gscl0, "smmu_gscl0", "aclk300_gscl", GATE_IP_GSCL1, 6, 0, 0),
	GATE(smmu_gscl1, "smmu_gscl1", "aclk300_gscl", GATE_IP_GSCL1, 7, 0, 0),
	GATE(gscl_wa, "gscl_wa", "aclk300_gscl", GATE_IP_GSCL1, 12, 0, 0),
	GATE(gscl_wb, "gscl_wb", "aclk300_gscl", GATE_IP_GSCL1, 13, 0, 0),
	GATE(smmu_fimcl3, "smmu_fimcl3,", "aclk333_432_gscl",
			GATE_IP_GSCL1, 16, 0, 0),
	GATE(fimc_lite3, "fimc_lite3", "aclk333_432_gscl",
			GATE_IP_GSCL1, 17, 0, 0),

	GATE(fimd1, "fimd1", "aclk300_disp1", GATE_IP_DISP1, 0, 0, 0),
	GATE(dsim1, "dsim1", "aclk200_disp1", GATE_IP_DISP1, 3, 0, 0),
	GATE(dp1, "dp1", "aclk200_disp1", GATE_IP_DISP1, 4, 0, 0),
	GATE(mixer, "mixer", "aclk166", GATE_IP_DISP1, 5, 0, 0),
	GATE(hdmi, "hdmi", "aclk200_disp1", GATE_IP_DISP1, 6, 0, 0),
	GATE(smmu_fimd1, "smmu_fimd1", "aclk300_disp1", GATE_IP_DISP1, 8, 0, 0),

	GATE(mfc, "mfc", "aclk333", GATE_IP_MFC, 0, 0, 0),
	GATE(smmu_mfcl, "smmu_mfcl", "aclk333", GATE_IP_MFC, 1, 0, 0),
	GATE(smmu_mfcr, "smmu_mfcr", "aclk333", GATE_IP_MFC, 2, 0, 0),

	GATE(g3d, "g3d", "aclkg3d", GATE_IP_G3D, 9, 0, 0),

	GATE(rotator, "rotator", "aclk266", GATE_IP_GEN, 1, 0, 0),
	GATE(jpeg, "jpeg", "aclk300_jpeg", GATE_IP_GEN, 2, 0, 0),
	GATE(jpeg2, "jpeg2", "aclk300_jpeg", GATE_IP_GEN, 3, 0, 0),
	GATE(mdma1, "mdma1", "aclk266", GATE_IP_GEN, 4, 0, 0),
	GATE(smmu_rotator, "smmu_rotator", "aclk266", GATE_IP_GEN, 6, 0, 0),
	GATE(smmu_jpeg, "smmu_jpeg", "aclk300_jpeg", GATE_IP_GEN, 7, 0, 0),
	GATE(smmu_mdma1, "smmu_mdma1", "aclk266", GATE_IP_GEN, 9, 0, 0),

	GATE(mscl0, "mscl0", "aclk400_mscl", GATE_IP_MSCL, 0, 0, 0),
	GATE(mscl1, "mscl1", "aclk400_mscl", GATE_IP_MSCL, 1, 0, 0),
	GATE(mscl2, "mscl2", "aclk400_mscl", GATE_IP_MSCL, 2, 0, 0),
	GATE(smmu_mscl0, "smmu_mscl0", "aclk400_mscl", GATE_IP_MSCL, 8, 0, 0),
	GATE(smmu_mscl1, "smmu_mscl1", "aclk400_mscl", GATE_IP_MSCL, 9, 0, 0),
	GATE(smmu_mscl2, "smmu_mscl2", "aclk400_mscl", GATE_IP_MSCL, 10, 0, 0),
	GATE(smmu_mixer, "smmu_mixer", "aclk200_disp1", GATE_IP_DISP1, 9, 0, 0),
};
```

## clk.c::samsung_clk_register_fixed_factor()

```clk.c
void __init samsung_clk_register_fixed_factor(
		struct samsung_fixed_factor_clock *list, unsigned int nr_clk)
{
	struct clk *clk;
	unsigned int idx;

	for (idx = 0; idx < nr_clk; idx++, list++) {
		clk = clk_register_fixed_factor(NULL, list->name,
			list->parent_name, list->flags, list->mult, list->div);
		if (IS_ERR(clk)) {
			pr_err("%s: failed to register clock %s\n", __func__,
				list->name);
			continue;
		}

		samsung_clk_add_lookup(clk, list->id);
	}
}
```


## log
* 1st log
```
   30e74a4..a511c99  master     -> origin/master
Updating 30e74a4..a511c99
Fast-forward
drivers/clk/clk-fixed-factor.c       |  73 +++++++++++
drivers/clk/clk.c                    | 239 +++++++++++++++++++++++++++--------
drivers/clk/clkdev.c                 |   4 +
drivers/clk/samsung/clk-exynos5420.c | 157 ++++++++++++++++++++++-
drivers/clk/samsung/clk-pll.c        | 160 +++++++++++++++++++++--
drivers/clk/samsung/clk-pll.h        |   2 +
drivers/clk/samsung/clk.c            |  52 +++++++-
drivers/clk/samsung/clk.h            |   2 +
include/linux/clk-private.h          |   1 +
include/linux/clk-provider.h         |   5 +
include/linux/gfp.h                  |   1 +
mm/util.c                            |   2 +
12 files changed, 628 insertions(+), 70 deletions(-)
```				
