# ARM10C 94주차 후기
##### 일시 : 2015.03.14 (94주차)
##### 모임명 : NAVER개발자커뮤니티지원_IAMROOT.ORG_10차ARM-C
##### 장소 : 토즈 타워점
##### 장소지원 : NAVER 개발자 커뮤니티 지원 프로그램
##### 참여인원 :  3명
============

## 94주차 진도
* start_kernel() init/main.c
  - ->time_init() 741 /init/main.c
    - ->clocksource_of_init() 557 ~/kernel/iamroot/linux-stable/arch/arm/kernel/time.c
	  - ->mct_init_spi  56  ~/kernel/iamroot/linux-stable/drivers/clocksource/clksrc-of.c
	     - mct_init_dt 583  ~/kernel/iamroot/linux-stable/drivers/clocksource/exynos_mct.c
		   - irq_of_parse_and_map   557  ~/kernel/iamroot/linux-stable/drivers/clocksource/exynos_mct.c
		     - of_irq_parse_one    49  if (of_irq_parse_one(dev, index, &oirq))
			   - of_irq_parse_raw   674  res = of_irq_parse_raw(addr, out_irq);

* NOTE
 - 5420 arndale board 로그에 따라서
 - fout_spll :  600 Mhz 로 분석
 - sclk_fimd1 : 266 Mhz 로 분석

## start_kernel()->time_init()
* time_init()

```main.c
asmlinkage void __init start_kernel(void)
{
...
	early_irq_init();
	// irq_desc 0 ~ 15 까지의 object을 할당 받고 초기화를 수행
	// allocated_irqs에 bit를 1로 세팅하고 radix tree에 각 irq_desc를 노트로 추가

	init_IRQ();
	// gic, combiner이 사용할 메모리 할당과 자료 구조 설정,
	// gic irq (0~15), combiner irq (32~63) interrupt 를 enable 시킴

	tick_init();
	// tick 관련 mask 변수를 0으로 초기화 수행

	init_timers();
	// boot_tvec_bases의 맴버 값을 초기화하고 timers_nb를 cpu_notifier 에 등록,
	// softirq_vec[1] 에 run_timer_softirq 등록하여 초기화 수행

	hrtimers_init();
	// hrtimer_bases의 맴버 값을 초기화하고 hrtimers_nb를 cpu_notifier 에 등록,
	// softirq_vec[8] 에 run_hrtimer_softirq 등록하여 초기화 수행

	softirq_init();
	// tasklet_vec, tasklet_hi_vec 맴버 값을 초기화하고,
	// softirq_vec[6]에 tasklet_action, softirq_vec[0]에 tasklet_hi_action 등록하여 초기화 수행

	timekeeping_init();
	// ntp 관련 전역변수 초기화, timekeeper, shadow_timekeeper의 맴버값 초기화 수행

	time_init();
```

## time_init()->of_clk_init(NULL)
* time_init()

```time.c
// ARM10C 20150103
void __init time_init(void)
{
	// machine_desc->init_time: __mach_desc_EXYNOS5_DT.init_time: NULL
	if (machine_desc->init_time) {
		machine_desc->init_time();
	} else {
#ifdef CONFIG_COMMON_CLK // CONFIG_COMMON_CLK=y
		of_clk_init(NULL);
#endif
		clocksource_of_init();
```

## clksrc-of.c::time_init()->clocksource_of_init()
* start_kernel()->time_init()->clocksource_of_init()

```clksrc-of.c
// ARM10C 20150307
void __init clocksource_of_init(void)
{
	struct device_node *np;
	const struct of_device_id *match;
	clocksource_of_init_fn init_func;

	for_each_matching_node_and_match(np, __clksrc_of_table, &match) {
	// for (np = of_find_matching_node_and_match(NULL, __clksrc_of_table, &match);
	//      np; np = of_find_matching_node_and_match(np, __clksrc_of_table, &match))

		// np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, match: __clksrc_of_table_exynos4210

		// np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소
		// of_device_is_available(devtree에서 allnext로 순회 하면서 찾은 mct node의 주소): 1
		if (!of_device_is_available(np))
			continue;

		// match->data: __clksrc_of_table_exynos4210.data: mct_init_spi
		init_func = match->data;
		// init_func: mct_init_spi

		// init_func: mct_init_spi
		// np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소
		// mct_init_spi(devtree에서 allnext로 순회 하면서 찾은 mct node의 주소)
		init_func(np);
```

* init_func(np)
 - mct_init_spi(devtree에서 allnext로 순회 하면서 찾은 mct node의 주소)

## exynos_mct.c::
* start_kernel()->time_init()->clocksource_of_init()->init_func(np)
 - init_func(np):mct_init_spi()

```exynos_mct.c::mct_init_spi()
// ARM10C 20150307
// np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소
static void __init mct_init_spi(struct device_node *np)
{
	// np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_INT_SPI: 0
	return mct_init_dt(np, MCT_INT_SPI);
}
```

* call: start_kernel()->time_init()->clocksource_of_init()->init_func(np)
 - // np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_INT_SPI: 0
 - init_func(np):mct_init_spi()->mct_init_dt()

## exynos_mct.c::mct_init_dt()
* called: start_kernel()->time_init()->clocksource_of_init()->init_func(np)
 - // np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_INT_SPI: 0
 - init_func(np):mct_init_spi()->mct_init_dt()

```exynos_mct.c::
// ARM10C 20150307
// np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_INT_SPI: 0
static void __init mct_init_dt(struct device_node *np, unsigned int int_type)
{
	u32 nr_irqs, i;

	// int_type: 0
	mct_int_type = int_type;
	// mct_int_type: 0

	/* This driver uses only one global timer interrupt */
	// np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_G0_IRQ: 0
	mct_irqs[MCT_G0_IRQ] = irq_of_parse_and_map(np, MCT_G0_IRQ);
```

* call: start_kernel()->time_init()->clocksource_of_init()->init_func(np)
 - // np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_INT_SPI: 0
 - init_func(np)->mct_init_spi()->mct_init_dt()
   - exynos_mct.c::mct_init_dt()->irq_of_parse_and_map()

## irq.c::irq_of_parse_and_map()
* called: start_kernel()->time_init()->clocksource_of_init()->init_func(np)
 - // np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_INT_SPI: 0
 - init_func(np)->mct_init_spi()->mct_init_dt()
   - exynos_mct.c::mct_init_dt()->irq_of_parse_and_map()

```irq.c::irq_create_of_mapping()
// ARM10C 20150307
// np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_G0_IRQ: 0
unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
{
	struct of_phandle_args oirq;

	// dev: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, index: 0
	// of_irq_parse_one(devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, 0, &oirq): 0
	if (of_irq_parse_one(dev, index, &oirq))
		return 0;
```

* call: start_kernel()->time_init()->clocksource_of_init()->init_func(np)
 - // np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_INT_SPI: 0
 - init_func(np)->mct_init_spi()->mct_init_dt()
   - exynos_mct.c::mct_init_dt()->irq_of_parse_and_map()
     - irq.c::irq_of_parse_and_map()->of_irq_parse_one()

## irq.c::of_irq_parse_one()
* called: start_kernel()->time_init()->clocksource_of_init()->init_func(np)
 - // np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_INT_SPI: 0
 - init_func(np)->mct_init_spi()->mct_init_dt()
   - exynos_mct.c::mct_init_dt()->irq_of_parse_and_map()
     - irq.c::irq_of_parse_and_map()->of_irq_parse_one()

```irq.c::of_irq_parse_one()
// ARM10C 20150307
// dev: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, index: 0, &oirq
int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_args *out_irq)
{
	struct device_node *p;
	const __be32 *intspec, *tmp, *addr;
	u32 intsize, intlen;

	// EINVAL: 23
	int i, res = -EINVAL;
	// res: -23

	// device: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소
	// of_node_full_name(devtree에서 allnext로 순회 하면서 찾은 mct node의 주소):
	// "mct@101C0000", index: 0
	pr_debug("of_irq_parse_one: dev=%s, index=%d\n", of_node_full_name(device), index);
	// "of_irq_parse_one: dev=mct@101C0000, index=0\n"

	/* OldWorld mac stuff is "special", handle out of line */
	// of_irq_workarounds: 0, OF_IMAP_OLDWORLD_MAC: 0x00000001
	if (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
		return of_irq_parse_oldworld(device, index, out_irq);

	/* Get the reg property (if any) */
	// device: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소
	// of_get_property(devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, "reg", NULL):
	// mct node의reg의 property의 값의 주소
	addr = of_get_property(device, "reg", NULL);
	// addr: mct node의reg의 property의 값의 주소

	/* Get the interrupts property */
	// device: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소
	// of_get_property(devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, "interrups", &intlen):
	// mct node의 rinterrupts의 property의 값의 주소
	intspec = of_get_property(device, "interrupts", &intlen);
	// intspec: mct node의 interrupts의 property의 값의 주소, intlen: 32

	// intspec: mct node의 interrupts의 property의 값의 주소
	if (intspec == NULL) {
		/* Try the new-style interrupts-extended */
		res = of_parse_phandle_with_args(device, "interrupts-extended",
						"#interrupt-cells", index, out_irq);
		if (res)
			return -EINVAL;
		return of_irq_parse_raw(addr, out_irq);
	}

	// intspec: mct node의 interrupts의 property의 값의 주소, intlen: 32
	// intlen: 32, sizeof(*mct node의 interrupts의 property의 값의 주소): 4
	intlen /= sizeof(*intspec);
	// intlen: 8

	// intspec: mct node의 interrupts의 property의 값의 주소, intlen: 32
	// be32_to_cpup(combiner node의 interrupts의 property의 값의 주소): 0, intlen: 8
	pr_debug(" intspec=%d intlen=%d\n", be32_to_cpup(intspec), intlen);
	// " intspec=0 intlen=8\n"

	/* Look for the interrupt parent. */
	// device: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소
	// of_irq_find_parent(devtree에서 allnext로 순회 하면서 찾은 mct node의 주소)
	// mct_map node의 주소
	p = of_irq_find_parent(device);
	// p: mct_map node의 주소

	// p: mct_map node의 주소
	if (p == NULL)
		return -EINVAL;

	/* Get size of interrupt specifier */
	// p: mct_map node의 주소
	// of_get_property(mct_map node의 주소 "#interrupt-cells", NULL):
	// mct_map node의 주소 #interrupt-cells의 property의 값의 주소
	tmp = of_get_property(p, "#interrupt-cells", NULL);
	// tmp: mct_map node의 주소 #interrupt-cells의 property의 값의 주소

	// tmp: mct_map node의 주소 #interrupt-cells의 property의 값의 주소
	if (tmp == NULL)
		goto out;

	// tmp: mct_map node의 주소 #interrupt-cells의 property의 값의 주소
	// be32_to_cpu(*(mct_map node의 주소 #interrupt-cells의 property의 값의 주소)): 1
	intsize = be32_to_cpu(*tmp);
	// intsize: 1

	// intsize: 1, intlen: 8
	pr_debug(" intsize=%d intlen=%d\n", intsize, intlen);
	// " intsize=1 intlen=8\n"

	/* Check index */
	// index: 0, intsize: 1, intlen: 8
	if ((index + 1) * intsize > intlen)
		goto out;

	/* Copy intspec into irq structure */
	// intspec: mct node의 interrupts의 property의 값의 주소, index: 0, intsize: 1
	intspec += index * intsize;
	// intspec: mct node의 interrupts의 property의 값의 주소

	// out_irq->np: (&oirq)->np, p: mct_map node의 주소
	out_irq->np = p;
	// out_irq->np: (&oirq)->np: mct_map node의 주소

	// out_irq->args_count: (&oirq)->args_count, intsize: 1
	out_irq->args_count = intsize;
	// out_irq->args_count: (&oirq)->args_count: 1

	// intsize: 1
	for (i = 0; i < intsize; i++)
		// i: 0, out_irq->args[0]: (&oirq)->args[0], intspec: combiner node의 interrupts의 property의 값의 주소
		// be32_to_cpup(combiner node의 interrupts의 property의 값의 주소): 0
		// i: 1, out_irq->args[1]: (&oirq)->args[1], intspec: combiner node의 interrupts의 property의 값의 주소 + 1
		// be32_to_cpup(combiner node의 interrupts의 property의 값의 주소 + 1): 0
		// i: 2, out_irq->args[2]: (&oirq)->args[2], intspec: combiner node의 interrupts의 property의 값의 주소 + 2
		// be32_to_cpup(combiner node의 interrupts의 property의 값의 주소 + 2): 0
		// i: 0, out_irq->args[0]: (&oirq)->args[0], intspec: mct node의 interrupts의 property의 값의 주소
		// be32_to_cpup(mct node의 interrupts의 property의 값의 주소): 0
		out_irq->args[i] = be32_to_cpup(intspec++);
		// out_irq->args[0]: (&oirq)->args[0]: 0, intspec: combiner node의 interrupts의 property의 값의 주소 + 1
		// out_irq->args[1]: (&oirq)->args[1]: 0, intspec: combiner node의 interrupts의 property의 값의 주소 + 2
		// out_irq->args[2]: (&oirq)->args[2]: 0, intspec: combiner node의 interrupts의 property의 값의 주소 + 3
		// out_irq->args[0]: (&oirq)->args[0]: 0, intspec: mct node의 interrupts의 property의 값의 주소 + 1

	/* Check if there are any interrupt-map translations to process */
	// addr: mct node의reg의 property의 값의 주소
	res = of_irq_parse_raw(addr, out_irq);
```

* call: start_kernel()->time_init()->clocksource_of_init()->init_func(np)
 - // np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_INT_SPI: 0
 - init_func(np)->mct_init_spi()->mct_init_dt()
   - exynos_mct.c::mct_init_dt()->irq_of_parse_and_map()
     - irq.c::irq_of_parse_and_map()->of_irq_parse_one()
	   - irq.c::of_irq_parse_raw()

## irq.c::of_irq_parse_raw()
* called: start_kernel()->time_init()->clocksource_of_init()->init_func(np)
 - // np: devtree에서 allnext로 순회 하면서 찾은 mct node의 주소, MCT_INT_SPI: 0
 - init_func(np)->mct_init_spi()->mct_init_dt()
   - exynos_mct.c::mct_init_dt()->irq_of_parse_and_map()
     - irq.c::irq_of_parse_and_map()->of_irq_parse_one()
	   - irq.c::of_irq_parse_raw()

```irq.c
// ARM10C 20150307
// addr: mct node의 reg의 property의 값의 주소, out_irq: &oirq
int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
{
	struct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;
	// old: NULL, newpar: NULL
	// old: NULL, newpar: NULL

	// MAX_PHANDLE_ARGS: 8
	// MAX_PHANDLE_ARGS: 8
	__be32 initial_match_array[MAX_PHANDLE_ARGS];
	const __be32 *match_array = initial_match_array;
	// match_array: initial_match_array
	// match_array: initial_match_array

	// MAX_PHANDLE_ARGS: 8
	// MAX_PHANDLE_ARGS: 8
	const __be32 *tmp, *imap, *imask, dummy_imask[] = { [0 ... MAX_PHANDLE_ARGS] = ~0 };
	// dummy_imask[0...7]: 0xffffffff
	// dummy_imask[0...7]: 0xffffffff

	u32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;
	// intsize: 1, newintsize: 0, newaddrsize: 0
	// intsize: 1, newintsize: 0, newaddrsize: 0

	int imaplen, match, i;

#ifdef DEBUG // undefined
	of_print_phandle_args("of_irq_parse_raw: ", out_irq);
#endif

	// out_irq->np: (&oirq)->np: gic node의 주소
	// of_node_get((&oirq)->np): gic node의 주소
	// out_irq->np: (&oirq)->np: mct_map node의 주소
	// of_node_get((&oirq)->np): mct_map node의 주소
	ipar = of_node_get(out_irq->np);
	// ipar: gic node의 주소
	// ipar: mct_map node의 주소

	/* First get the #interrupt-cells property of the current cursor
	 * that tells us how to interpret the passed-in intspec. If there
	 * is none, we are nice and just walk up the tree
	 */
	do {
		// ipar: gic node의 주소
		// of_get_property(gic node의 주소, "#interrupt-cells", NULL):
		// gic node의 #interrupt-cells의 property 값의 주소
		// ipar: mct_map node의 주소
		// of_get_property(mct_map node의 주소, "#interrupt-cells", NULL):
		// mct_map node의 #interrupt-cells의 property 값의 주소
		tmp = of_get_property(ipar, "#interrupt-cells", NULL);
		// tmp: gic node의 #interrupt-cells의 property 값의 주소
		// tmp: mct_map node의 #interrupt-cells의 property 값의 주소

		// tmp: gic node의 #interrupt-cells의 property 값의 주소
		// tmp: mct_map node의 #interrupt-cells의 property 값의 주소
		if (tmp != NULL) {
			// tmp: gic node의 #interrupt-cells의 property 값의 주소
			// be32_to_cpu(*(gic node의 #interrupt-cells의 property 값의 주소)): 3
			// tmp: mct_map node의 #interrupt-cells의 property 값의 주소
			// be32_to_cpu(*(mct_map node의 #interrupt-cells의 property 값의 주소)): 1
			intsize = be32_to_cpu(*tmp);
			// intsize: 3
			// intsize: 1
			break;
			// break 수행
			// break 수행
		}
		tnode = ipar;
		ipar = of_irq_find_parent(ipar);
		of_node_put(tnode);
	} while (ipar);

	// ipar: gic node의 주소
	// ipar: mct_map node의 주소
	if (ipar == NULL) {
		pr_debug(" -> no parent found !\n");
		goto fail;
	}

	// ipar: gic node의 주소,
	// of_node_full_name(gic node의 주소): "interrupt-controller@10481000", intsize: 3
	// ipar: mct_map node의 주소
	// of_node_full_name(mct_map node의 주소): "mct-map", intsize: 1
	pr_debug("of_irq_parse_raw: ipar=%s, size=%d\n", of_node_full_name(ipar), intsize);
	// "of_irq_parse_raw: ipar=interrupt-controller@10481000, size=3\n"
	// "of_irq_parse_raw: ipar=mct-map, size=1\n"

	// out_irq->args_count: (&oirq)->args_count: 3, intsize: 3
	// out_irq->args_count: (&oirq)->args_count: 1, intsize: 1
	if (out_irq->args_count != intsize)
		return -EINVAL;

	/* Look for this #address-cells. We have to implement the old linux
	 * trick of looking for the parent here as some device-trees rely on it
	 */
	// ipar: gic node의 주소, of_node_get(gic node의 주소): gic node의 주소
	// ipar: mct_map node의 주소, of_node_get(mct_map node의 주소): mct_map node의 주소
	old = of_node_get(ipar);
	// old: gic node의 주소
	// old: mct_map node의 주소

	do {
		// old: gic node의 주소,
		// of_get_property(gic node의 주소, "#address-cells", NULL): NULL
		// old: root node의 주소,
		// of_get_property(root node의 주소, "#address-cells", NULL): gic node의 #address-cells의 property 값의 주소
		// old: mct_map node의 주소,
		// of_get_property(mct_map node의 주소, "#address-cells", NULL): mct_map node의 #address-cells의 property 값의 주소
		tmp = of_get_property(old, "#address-cells", NULL);
		// tmp: NULL
		// tmp: gic node의 #address-cells의 property 값의 주소
		// tmp: mct_map node의 #address-cells의 property 값의 주소

		// FIXME:
		// of_get_parent(mct_map node의 주소): XXX
		// of_get_parent(mct_map node의 주소)의 값은 확인 필요,
		// 코드 분석상 확인 할수 없는 상태라 XXX 로 써놓고 분석

		// old: gic node의 주소, of_get_parent(gic node의 주소): root node의 주소
		// old: root node의 주소, of_get_parent(root node의 주소): NULL
		// old: mct_map node의 주소, of_get_parent(mct_map node의 주소): XXX
		tnode = of_get_parent(old);
		// tnode: root node의 주소
		// tnode: NULL
		// tnode: XXX

		// old: gic node의 주소
		// old: root node의 주소
		// old: mct_map node의 주소
		of_node_put(old); // null function

		// tnode: root node의 주소
		// tnode: NULL
		// tnode: XXX
		old = tnode;
		// old: root node의 주소
		// old: NULL
		// old: XXX

		// old: root node의 주소, tmp: NULL
		// old: NULL, tmp: #address-cells의 property 값의 주소
		// old: XXX, tmp: mct_map node의 #address-cells의 property 값의 주소
	} while (old && tmp == NULL);

// 2015/03/07 종료

	// old: NULL
	of_node_put(old); // null function

	// old: NULL
	old = NULL;
	// old: NULL

	// tmp: #address-cells의 property 값의 주소
	// be32_to_cpu(*(#address-cells의 property 값의 주소)): 1
	addrsize = (tmp == NULL) ? 2 : be32_to_cpu(*tmp);
	// addrsize: 1

	// addrsize: 1
	pr_debug(" -> addrsize=%d\n", addrsize);
	// " -> addrsize=1\n"

	/* Range check so that the temporary buffer doesn't overflow */
	// addrsize: 1, intsize: 3, MAX_PHANDLE_ARGS: 8
	if (WARN_ON(addrsize + intsize > MAX_PHANDLE_ARGS))
		goto fail;

	/* Precalculate the match array - this simplifies match loop */
	// addrsize: 1
	for (i = 0; i < addrsize; i++)
		// i: 0, initial_match_array[0], addr: reg의 property의 값의 주소
		// addr[0]: (reg의 property의 값의 주소)[0]: 0x10440000
		initial_match_array[i] = addr ? addr[i] : 0;
		// initial_match_array[0]: 0x10440000

	// intsize: 3
	for (i = 0; i < intsize; i++)
		// i: 0, addrsize: 1, initial_match_array[1],
		// out_irq->args[0], (&oirq)->args[0], cpu_to_be32((&oirq)->args[0]): 0
		// i: 1, addrsize: 1, initial_match_array[2],
		// out_irq->args[1], (&oirq)->args[1], cpu_to_be32((&oirq)->args[1]): 0
		// i: 2, addrsize: 1, initial_match_array[3],
		// out_irq->args[2], (&oirq)->args[2], cpu_to_be32((&oirq)->args[2]): 0
		initial_match_array[addrsize + i] = cpu_to_be32(out_irq->args[i]);
		// initial_match_array[1]: 0
		// initial_match_array[2]: 0
		// initial_match_array[3]: 0

	/* Now start the actual "proper" walk of the interrupt tree */
	// ipar: gic node의 주소
	while (ipar != NULL) {
		/* Now check if cursor is an interrupt-controller and if it is
		 * then we are done
		 */
		// ipar: gic node의 주소,
		// of_get_property(gic node의 주소, "interrupt-controller", NULL): NULL 아닌값
		if (of_get_property(ipar, "interrupt-controller", NULL) !=
				NULL) {
			pr_debug(" -> got it !\n");
			// " -> got it !\n"

			return 0;
			// return 0
		}

		/*
		 * interrupt-map parsing does not work without a reg
		 * property when #address-cells != 0
		 */
		if (addrsize && !addr) {
			pr_debug(" -> no reg passed in when needed !\n");
			goto fail;
		}

		/* Now look for an interrupt-map */
		imap = of_get_property(ipar, "interrupt-map", &imaplen);
		/* No interrupt map, check for an interrupt parent */
		if (imap == NULL) {
			pr_debug(" -> no map, getting parent\n");
			newpar = of_irq_find_parent(ipar);
			goto skiplevel;
		}
		imaplen /= sizeof(u32);

		/* Look for a mask */
		imask = of_get_property(ipar, "interrupt-map-mask", NULL);
		if (!imask)
			imask = dummy_imask;

		/* Parse interrupt-map */
		match = 0;
		while (imaplen > (addrsize + intsize + 1) && !match) {
			/* Compare specifiers */
			match = 1;
			for (i = 0; i < (addrsize + intsize); i++, imaplen--)
				match &= !((match_array[i] ^ *imap++) & imask[i]);

			pr_debug(" -> match=%d (imaplen=%d)\n", match, imaplen);

			/* Get the interrupt parent */
			if (of_irq_workarounds & OF_IMAP_NO_PHANDLE)
				newpar = of_node_get(of_irq_dflt_pic);
			else
				newpar = of_find_node_by_phandle(be32_to_cpup(imap));
			imap++;
			--imaplen;

			/* Check if not found */
			if (newpar == NULL) {
				pr_debug(" -> imap parent not found !\n");
				goto fail;
			}

			/* Get #interrupt-cells and #address-cells of new
			 * parent
			 */
			tmp = of_get_property(newpar, "#interrupt-cells", NULL);
			if (tmp == NULL) {
				pr_debug(" -> parent lacks #interrupt-cells!\n");
				goto fail;
			}
			newintsize = be32_to_cpu(*tmp);
			tmp = of_get_property(newpar, "#address-cells", NULL);
			newaddrsize = (tmp == NULL) ? 0 : be32_to_cpu(*tmp);

			pr_debug(" -> newintsize=%d, newaddrsize=%d\n",
			    newintsize, newaddrsize);

			/* Check for malformed properties */
			if (WARN_ON(newaddrsize + newintsize > MAX_PHANDLE_ARGS))
				goto fail;
			if (imaplen < (newaddrsize + newintsize))
				goto fail;

			imap += newaddrsize + newintsize;
			imaplen -= newaddrsize + newintsize;

			pr_debug(" -> imaplen=%d\n", imaplen);
		}
		if (!match)
			goto fail;

		/*
		 * Successfully parsed an interrrupt-map translation; copy new
		 * interrupt specifier into the out_irq structure
		 */
		out_irq->np = newpar;

		match_array = imap - newaddrsize - newintsize;
		for (i = 0; i < newintsize; i++)
			out_irq->args[i] = be32_to_cpup(imap - newintsize + i);
		out_irq->args_count = intsize = newintsize;
		addrsize = newaddrsize;

	skiplevel:
		/* Iterate again with new parent */
		pr_debug(" -> new parent: %s\n", of_node_full_name(newpar));
		of_node_put(ipar);
		ipar = newpar;
		newpar = NULL;
	}
 fail:
	of_node_put(ipar);
	of_node_put(newpar);

	return -EINVAL;
}
EXPORT_SYMBOL_GPL(of_irq_parse_raw);
```

## log
* 1st log

```
   48d2c6a..8dc44c0  master     -> origin/master
Updating 48d2c6a..8dc44c0
Fast-forward
arch/arm/kernel/time.c               | 401 ++++++++++++++++++++++++
arch/arm/kernel/vmlinux.lds.S        |   1 +
drivers/clk/clk-divider.c            |  55 +++-
drivers/clk/clk-gate.c               |  68 ++++-
drivers/clk/clk.c                    | 573 ++++++++++++++++++++++++++++++++++-
drivers/clk/samsung/clk-exynos5420.c | 102 +++++++
drivers/clk/samsung/clk.c            | 102 +++++++
drivers/clk/samsung/clk.h            |  39 +++
drivers/clocksource/arm_arch_timer.c |  16 +
drivers/clocksource/clksrc-of.c      |  20 ++
drivers/clocksource/exynos_mct.c     |  27 ++
drivers/of/base.c                    |  41 +++
drivers/of/irq.c                     | 188 +++++++++---
include/asm-generic/vmlinux.lds.h    |   6 +-
include/linux/clk-private.h          |   1 +
include/linux/clk-provider.h         |   8 +
include/linux/clocksource.h          |   3 +-
include/linux/gfp.h                  |   1 +
include/linux/mod_devicetable.h      |   1 +
include/linux/of.h                   |  10 +-
include/linux/of_irq.h               |   1 +
include/linux/slab.h                 |   2 +
22 files changed, 1622 insertions(+), 44 deletions(-)
```
