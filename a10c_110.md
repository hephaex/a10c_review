##### ARM10C   : 110 주차 
##### 일시     : 2015.07.18 (110 주차 스터디 진행)
##### 모임명   : NAVER개발자커뮤니티지원_10차ARM-C
##### 장소     : 토즈 타워점
##### 장소지원 : NAVER 개발자 커뮤니티 지원 프로그램
##### 참여인원 : 2명
============

## 110 주차 진도

* start_kernel      321  kernel/params.c
 - console_init      833  init/main.c
  - con_init         3512  drivers/tty/tty_io.c

## main.c::main.c()
* called: start_kernel()

```main.c
asmlinkage void __init start_kernel(void)
{
...
	// irqs_disabled(): 1
	WARN(!irqs_disabled(), "Interrupts were enabled early\n");

	// early_boot_irqs_disabled: true
	early_boot_irqs_disabled = false;
	// early_boot_irqs_disabled: false

	local_irq_enable();
	// IRQ를 enable 함

	kmem_cache_init_late(); // null function

	/*
	 * HACK ALERT! This is early. We're enabling the console before
	 * we've done PCI setups etc, and console_init() must be aware of
	 * this. But we do want output early, in case something goes wrong.
	 */
	console_init();
```

* call: start_kernel()->console_init()

## tty_io.c::console_init()
* called: start_kernel()->console_init()

```tty_io.c
// ARM10C 20150627
void __init console_init(void)
{
	initcall_t *call;

	/* Setup the default TTY line discipline. */
	tty_ldisc_begin();

	// tty_ldisc_begin에서 한일:
	// tty_ldiscs[0]: &tty_ldisc_N_TTY
	// (&tty_ldisc_N_TTY)->num: 0
	// (&tty_ldisc_N_TTY)->refcount: 0

	/*
	 * set up the console device so that later boot sequences can
	 * inform about problems etc..
	 */
	call = __con_initcall_start;
	// call: &__con_initcall_start

// 2015/06/27 종료
// 2015/07/04 시작

	// call: &__con_initcall_start
	while (call < __con_initcall_end) {
		// call: __initcall_con_init: con_init
		// call: __initcall_s3c24xx_serial_console_init:
		// s3c24xx_serial_console_init
		(*call)();
		call++;
	}
}
```

* call: start_kernel()->console_init()->con_init()
 - call: con_init()
 - call: s3c24xx_serial_console_init()

## vt.c::con_init()
* called: start_kernel()->console_init()->con_init()
 - call: con_init()

```console.h
// ARM10C 20150704
struct consw {
	struct module *owner;
	const char *(*con_startup)(void);
	void	(*con_init)(struct vc_data *, int);
	void	(*con_deinit)(struct vc_data *);
	void	(*con_clear)(struct vc_data *, int, int, int, int);
	void	(*con_putc)(struct vc_data *, int, int, int);
	void	(*con_putcs)(struct vc_data *, const unsigned short *, int, int, int);
	void	(*con_cursor)(struct vc_data *, int);
	int	(*con_scroll)(struct vc_data *, int, int, int, int);
	void	(*con_bmove)(struct vc_data *, int, int, int, int, int, int);
	int	(*con_switch)(struct vc_data *);
	int	(*con_blank)(struct vc_data *, int, int);
	int	(*con_font_set)(struct vc_data *, struct console_font *, unsigned);
	int	(*con_font_get)(struct vc_data *, struct console_font *);
	int	(*con_font_default)(struct vc_data *, struct console_font *, char *);
	int	(*con_font_copy)(struct vc_data *, int);
	int     (*con_resize)(struct vc_data *, unsigned int, unsigned int,
			       unsigned int);
	int	(*con_set_palette)(struct vc_data *, unsigned char *);
	int	(*con_scrolldelta)(struct vc_data *, int);
	int	(*con_set_origin)(struct vc_data *);
	void	(*con_save_screen)(struct vc_data *);
	u8	(*con_build_attr)(struct vc_data *, u8, u8, u8, u8, u8, u8);
	void	(*con_invert_region)(struct vc_data *, u16 *, int);
	u16    *(*con_screen_pos)(struct vc_data *, int);
	unsigned long (*con_getxy)(struct vc_data *, unsigned long, int *, int *);
	/*
	 * Prepare the console for the debugger.  This includes, but is not
	 * limited to, unblanking the console, loading an appropriate
	 * palette, and allowing debugger generated output.
	 */
	int	(*con_debug_enter)(struct vc_data *);
	/*
	 * Restore the console to its pre-debug state as closely as possible.
	 */
	int	(*con_debug_leave)(struct vc_data *);
};
```

```vt.c::con_init()
// ARM10C 20150704
static int __init con_init(void)
{
	const char *display_desc = NULL;
	// display_desc: NULL

	struct vc_data *vc;
	unsigned int currcons = 0, i;
	// currcons: 0

	console_lock();

	// console_lock에서 한일:
	// (&console_sem)->count: 0
	// console_locked: 1
	// console_may_schedule: 1

	// conswitchp: &dummy_con
	if (conswitchp)
		// conswitchp->con_startup: (&dummy_con)->con_startup: dummycon_startup
		// dummycon_startup(): &"dummy device"
		display_desc = conswitchp->con_startup();
		// display_desc: &"dummy device"

	// display_desc: &"dummy device"
	if (!display_desc) {
		fg_console = 0;
		console_unlock();
		return 0;
	}

	// MAX_NR_CON_DRIVER: 16
	for (i = 0; i < MAX_NR_CON_DRIVER; i++) {
		// i: 0
		struct con_driver *con_driver = &registered_con_driver[i];
		// con_driver: &registered_con_driver[0]

		// con_driver->con: (&registered_con_driver[0])->con: NULL
		if (con_driver->con == NULL) {
			// con_driver->con: (&registered_con_driver[0])->con, conswitchp: &dummy_con
			con_driver->con = conswitchp;
			// con_driver->con: (&registered_con_driver[0])->con: &dummy_con

			// con_driver->desc: (&registered_con_driver[0])->desc, display_desc: &"dummy device"
			con_driver->desc = display_desc;
			// con_driver->desc: (&registered_con_driver[0])->desc: &"dummy device"

			// con_driver->flag: (&registered_con_driver[0])->flag, CON_DRIVER_FLAG_INIT: 2
			con_driver->flag = CON_DRIVER_FLAG_INIT;
			// con_driver->flag: (&registered_con_driver[0])->flag: 2

			// con_driver->first: (&registered_con_driver[0])->first
			con_driver->first = 0;
			// con_driver->first: (&registered_con_driver[0])->first: 0

			// con_driver->last: (&registered_con_driver[0])->last, MAX_NR_CONSOLES: 63
			con_driver->last = MAX_NR_CONSOLES - 1;
			// con_driver->last: (&registered_con_driver[0])->last: 62

			break;
			// break 수행
		}
	}

	// MAX_NR_CONSOLES: 63
	for (i = 0; i < MAX_NR_CONSOLES; i++)
		// i: 0, conswitchp: &dummy_con
		con_driver_map[i] = conswitchp;
		// con_driver_map[0]: &dummy_con

		// i: 1...62 loop 수행

	// blankinterval: 600
	if (blankinterval) {
		// blank_normal_wait: 1
		blank_state = blank_normal_wait;
		// blank_state: 1

		// NOTE:
		// jiffies은 interrupt enable이 되었기 때문에
		// 실시간으로 변하는 값이므로 현재 시간값을 알수 없음
		// jiffiex: xx_64 로 주석을 작성하도록 함

// 2015/07/04 종료
// 2015/07/11 시작

		// jiffies: xx_64, blankinterval: 600, HZ: 100
		// mod_timera(&console_timer, xx_64 + 60000): 0
		mod_timer(&console_timer, jiffies + (blankinterval * HZ));

		// mod_timer에서 한일:
		// (&console_timer)->expires: xx_64 + 60000
		//
		// NOTE:
		// idx의 값을 가정하고 분석, xx_64은 0이라 보고
		// idx값이 90000의 값을 가진것으로 분석 진행
		// 계산값 xx_64 + 90000 0 보다 크다고 가정하고 분석 진행
		// FIXME:
		// TVR_SIZE: 256 값이 왜 256 인지??
		//
		// &(&boot_tvec_bases)->tv3.vec[3]에 &(&console_timer)->entry을 tail에 연결
		// (&boot_tvec_bases)->active_timers: 1
	}

// 2015/07/11 종료
	for (currcons = 0; currcons < MIN_NR_CONSOLES; currcons++) {
	    // currncons: 0, sizeof(struct vc_data): 653, GFP_NOWAIT:0
		// kzalloc(653, 0): kmem_cache#25-ox (1024 Byte)
		vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);
		INIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);
```

* sizeof(strunct vc_data): 653Byte
```console_struct.h
// ARM10C 20150704
struct vc_data {
	struct tty_port port;			/* Upper level data */

	unsigned short	vc_num;			/* Console number */
	unsigned int	vc_cols;		/* [#] Console size */
	unsigned int	vc_rows;
	unsigned int	vc_size_row;		/* Bytes per row */
	unsigned int	vc_scan_lines;		/* # of scan lines */
	unsigned long	vc_origin;		/* [!] Start of real screen */
	unsigned long	vc_scr_end;		/* [!] End of real screen */
	unsigned long	vc_visible_origin;	/* [!] Top of visible window */
	unsigned int	vc_top, vc_bottom;	/* Scrolling region */
	const struct consw *vc_sw;
	unsigned short	*vc_screenbuf;		/* In-memory character/attribute buffer */
	unsigned int	vc_screenbuf_size;
	unsigned char	vc_mode;		/* KD_TEXT, ... */
	/* attributes for all characters on screen */
	unsigned char	vc_attr;		/* Current attributes */
	unsigned char	vc_def_color;		/* Default colors */
	unsigned char	vc_color;		/* Foreground & background */
	unsigned char	vc_s_color;		/* Saved foreground & background */
	unsigned char	vc_ulcolor;		/* Color for underline mode */
	unsigned char   vc_itcolor;
	unsigned char	vc_halfcolor;		/* Color for half intensity mode */
	/* cursor */
	unsigned int	vc_cursor_type;
	unsigned short	vc_complement_mask;	/* [#] Xor mask for mouse pointer */
	unsigned short	vc_s_complement_mask;	/* Saved mouse pointer mask */
	unsigned int	vc_x, vc_y;		/* Cursor position */
	unsigned int	vc_saved_x, vc_saved_y;
	unsigned long	vc_pos;			/* Cursor address */
	/* fonts */	
	unsigned short	vc_hi_font_mask;	/* [#] Attribute set for upper 256 chars of font or 0 if not supported */
	struct console_font vc_font;		/* Current VC font set */
	unsigned short	vc_video_erase_char;	/* Background erase character */
	/* VT terminal data */
	unsigned int	vc_state;		/* Escape sequence parser state */
	unsigned int	vc_npar,vc_par[NPAR];	/* Parameters of current escape sequence */
	/* data for manual vt switching */
	struct vt_mode	vt_mode;
	struct pid 	*vt_pid;
	int		vt_newvt;
	wait_queue_head_t paste_wait;
	/* mode flags */
	unsigned int	vc_charset	: 1;	/* Character set G0 / G1 */
	unsigned int	vc_s_charset	: 1;	/* Saved character set */
	unsigned int	vc_disp_ctrl	: 1;	/* Display chars < 32? */
	unsigned int	vc_toggle_meta	: 1;	/* Toggle high bit? */
	unsigned int	vc_decscnm	: 1;	/* Screen Mode */
	unsigned int	vc_decom	: 1;	/* Origin Mode */
	unsigned int	vc_decawm	: 1;	/* Autowrap Mode */
	unsigned int	vc_deccm	: 1;	/* Cursor Visible */
	unsigned int	vc_decim	: 1;	/* Insert Mode */
	unsigned int	vc_deccolm	: 1;	/* 80/132 Column Mode */
	/* attribute flags */
	unsigned int	vc_intensity	: 2;	/* 0=half-bright, 1=normal, 2=bold */
	unsigned int    vc_italic:1;
	unsigned int	vc_underline	: 1;
	unsigned int	vc_blink	: 1;
	unsigned int	vc_reverse	: 1;
	unsigned int	vc_s_intensity	: 2;	/* saved rendition */
	unsigned int    vc_s_italic:1;
	unsigned int	vc_s_underline	: 1;
	unsigned int	vc_s_blink	: 1;
	unsigned int	vc_s_reverse	: 1;
	/* misc */
	unsigned int	vc_ques		: 1;
	unsigned int	vc_need_wrap	: 1;
	unsigned int	vc_can_do_color	: 1;
	unsigned int	vc_report_mouse : 2;
	unsigned char	vc_utf		: 1;	/* Unicode UTF-8 encoding */
	unsigned char	vc_utf_count;
		 int	vc_utf_char;
	unsigned int	vc_tab_stop[8];		/* Tab stops. 256 columns. */
	unsigned char   vc_palette[16*3];       /* Colour palette for VGA+ */
	unsigned short * vc_translate;
	unsigned char 	vc_G0_charset;
	unsigned char 	vc_G1_charset;
	unsigned char 	vc_saved_G0;
	unsigned char 	vc_saved_G1;
	unsigned int    vc_resize_user;         /* resize request from user */
	unsigned int	vc_bell_pitch;		/* Console bell pitch */
	unsigned int	vc_bell_duration;	/* Console bell duration */
	struct vc_data **vc_display_fg;		/* [!] Ptr to var holding fg console for this display */
	unsigned long	vc_uni_pagedir;
	unsigned long	*vc_uni_pagedir_loc;  /* [!] Location of uni_pagedir variable for this console */
	bool vc_panic_force_write; /* when oops/panic this VC can accept forced output/blanking */
	/* additional information is in vt_kern.h */
};
```

* sizeof(struct tty_port) : 313 byte
```tty.h
struct tty_port {
	struct tty_bufhead	buf;		/* Locked internally */
	struct tty_struct	*tty;		/* Back pointer */
	struct tty_struct	*itty;		/* internal back ptr */
	const struct tty_port_operations *ops;	/* Port operations */
	spinlock_t		lock;		/* Lock protecting tty field */
	int			blocked_open;	/* Waiting to open */
	int			count;		/* Usage count */
	wait_queue_head_t	open_wait;	/* Open waiters */
	wait_queue_head_t	close_wait;	/* Close waiters */
	wait_queue_head_t	delta_msr_wait;	/* Modem status change */
	unsigned long		flags;		/* TTY flags ASY_*/
	unsigned char		console:1,	/* port is a console */
				low_latency:1;	/* optional: tune for latency */
	struct mutex		mutex;		/* Locking */
	struct mutex		buf_mutex;	/* Buffer alloc lock */
	unsigned char		*xmit_buf;	/* Optional buffer */
	unsigned int		close_delay;	/* Close port delay */
	unsigned int		closing_wait;	/* Delay for output */
	int			drain_delay;	/* Set to zero if no pure time
						   based drain is needed else
						   set to size of fifo */
	struct kref		kref;		/* Ref counter */
};
```

* sizeof(struct consw *vc_sw): 4Byte
* sizeof(struct console_font vc_font):
```kd.h
struct console_font {
	unsigned int width, height;	/* font size */
	unsigned int charcount;
	unsigned char *data;	/* font data with height fixed to 32 */
};
```

* NPAR
```console_struct.h
#define NPAR 16
```

* sizeof(struct vt_mode): 16Byte
```vt.h
struct vt_mode {
	char mode;		/* vt mode */
	char waitv;		/* if set, hang on writes if not active */
	short relsig;		/* signal to raise on release req */
	short acqsig;		/* signal to raise on acquisition */
	short frsig;		/* unused (set to 0) */
};
```


* sizeof(struct *vc)
```keyboard.h
struct keyboard_notifier_param {
	struct vc_data *vc;	/* VC on which the keyboard press was done */
	int down;		/* Pressure of the key? */
	int shift;		/* Current shift mask */
	int ledstate;		/* Current led state */
	unsigned int value;	/* keycode, unicode value or keysym */
};
```

* INIT_WORK(_work, _func)
```workqueue.h
// ARM10C 20140809
// p->wq: (&vfree_deferred + __per_cpu_offset[0])->wq, free_work
#define INIT_WORK(_work, _func)						\
	do {								\
		__INIT_WORK((_work), (_func), 0);			\
	} while (0)
```

```workqueue.h
static inline void __init_work(struct work_struct *work, int onstack) { }
```

```workqueue.h
// ARM10C 20140809
// p->wq: (&vfree_deferred + __per_cpu_offset[0])->wq, free_work, 0
#define __INIT_WORK(_work, _func, _onstack)				\
	do {								\
		__init_work((_work), _onstack);				\
		(_work)->data = (atomic_long_t) WORK_DATA_INIT();	\
		INIT_LIST_HEAD(&(_work)->entry);			\
		PREPARE_WORK((_work), (_func));				\
	} while (0)
#endif
```


* call: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
 
## tty_port.c::tty_port_init()
* called: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);

```tty_port.c
void tty_port_init(struct tty_port *port)
{
	memset(port, 0, sizeof(*port));
	tty_buffer_init(port);
	init_waitqueue_head(&port->open_wait);
	init_waitqueue_head(&port->close_wait);
	init_waitqueue_head(&port->delta_msr_wait);
	mutex_init(&port->mutex);
	mutex_init(&port->buf_mutex);
	spin_lock_init(&port->lock);
	port->close_delay = (50 * HZ) / 100;
	port->closing_wait = (3000 * HZ) / 100;
	kref_init(&port->kref);
}
EXPORT_SYMBOL(tty_port_init);
```

* call: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
  
## tty_buffer.c::tty_buffer_init()
* called: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()

```tty_buffer.c
void tty_buffer_init(struct tty_port *port)
{
	struct tty_bufhead *buf = &port->buf;

	mutex_init(&buf->lock);
```

* called: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()

## mutex-debug.h::mutex_init()
* called: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()
	
```mutex-debug.h
#define mutex_init(mutex)						\
do {									\
	static struct lock_class_key __key;				\
									\
	__mutex_init((mutex), #mutex, &__key);				\
} while (0)
```

* return: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()
	
## tty_buffer.c::tty_buffer_init()
* called: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()

```tty_buffer.c
void tty_buffer_init(struct tty_port *port)
{
	struct tty_bufhead *buf = &port->buf;

	mutex_init(&buf->lock);
	tty_buffer_reset(&buf->sentinel, 0);
```

* call: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()
	- tty_buffer_reset()

## tty_buffer.c::tty_buffer_reset()
* called: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()
	- tty_buffer_reset()

```tty_buffer.c
static void tty_buffer_reset(struct tty_buffer *p, size_t size)
{
	p->used = 0;
	p->size = size;
	p->next = NULL;
	p->commit = 0;
	p->read = 0;
}
```

* return: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()
	- tty_buffer_reset()

## tty_buffer.c::tty_buffer_init()
* called: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()

```tty_buffer.c
void tty_buffer_init(struct tty_port *port)
{
	struct tty_bufhead *buf = &port->buf;

	mutex_init(&buf->lock);
	tty_buffer_reset(&buf->sentinel, 0);
	buf->head = &buf->sentinel;
	buf->tail = &buf->sentinel;
	init_llist_head(&buf->free);
	atomic_set(&buf->memory_used, 0);
	atomic_set(&buf->priority, 0);
	INIT_WORK(&buf->work, flush_to_ldisc);
}
```

* call: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()
	- tty_buffer_reset()
	- init_llist_head()
	- atomic_set()
	- atomic_set()
	- INIT_WORK()

### tty_buffer_init()에서 한 일
...

## tty_port.c::tty_port_init()
* call: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()
	- tty_buffer_reset()
	- init_llist_head()
	- atomic_set()
	- atomic_set()
	- INIT_WORK()

```tty_port.c
void tty_port_init(struct tty_port *port)
{
	memset(port, 0, sizeof(*port));
	tty_buffer_init(port);
	init_waitqueue_head(&port->open_wait);
	init_waitqueue_head(&port->close_wait);
	init_waitqueue_head(&port->delta_msr_wait);
	mutex_init(&port->mutex);
	mutex_init(&port->buf_mutex);
	spin_lock_init(&port->lock);
	port->close_delay = (50 * HZ) / 100;
	port->closing_wait = (3000 * HZ) / 100;
	kref_init(&port->kref);
}
EXPORT_SYMBOL(tty_port_init);
```

* call: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()
	- tty_buffer_reset()
	- init_llist_head()
	- atomic_set()
	- atomic_set()
	- INIT_WORK()
  - init_waitqueue_head()
  - init_waitqueue_head()
  - init_waitqueue_head()
  - mutex_init()
  - mutex_init()
  - spin_lock_init()
  - kref_init()

## kref.h::kref_init()
* called: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()
	- tty_buffer_reset()
	- init_llist_head()
	- atomic_set()
	- atomic_set()
	- INIT_WORK()
  - init_waitqueue_head()
  - init_waitqueue_head()
  - init_waitqueue_head()
  - mutex_init()
  - mutex_init()
  - spin_lock_init()
  - kref_init()

```kref.h
static inline void kref_init(struct kref *kref)
{
	atomic_set(&kref->refcount, 1);
}
```

* return: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()
	- tty_buffer_reset()
	- init_llist_head()
	- atomic_set()
	- atomic_set()
	- INIT_WORK()
  - init_waitqueue_head()
  - init_waitqueue_head()
  - init_waitqueue_head()
  - mutex_init()
  - mutex_init()
  - spin_lock_init()
  - kref_init()

## vt.c::con_init()
* return: start_kernel()->console_init()->con_init()
 - mod_timer()
 - tty_port_init(&vc->port);
  - tty_buffer_init()
    - mutex_init()
	- tty_buffer_reset()
	- init_llist_head()
	- atomic_set()
	- atomic_set()
	- INIT_WORK()
  - init_waitqueue_head()
  - init_waitqueue_head()
  - init_waitqueue_head()
  - mutex_init()
  - mutex_init()
  - spin_lock_init()
  - kref_init()

```vt.c::con_init()
// ARM10C 20150704
static int __init con_init(void)
{
...
	for (currcons = 0; currcons < MIN_NR_CONSOLES; currcons++) {
		vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);
		INIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);
		tty_port_init(&vc->port);
```
