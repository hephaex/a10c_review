##### ARM10C   : 110 주차 
##### 일시     : 2015.07.18 (110 주차 스터디 진행)
##### 모임명   : NAVER개발자커뮤니티지원_10차ARM-C
##### 장소     : 토즈 타워점
##### 장소지원 : NAVER 개발자 커뮤니티 지원 프로그램
##### 참여인원 : 2명
============

## 110 주차 진도

* start_kernel      321  kernel/params.c
 - console_init      833  init/main.c
  - con_init         3512  drivers/tty/tty_io.c

## main.c::main.c()
* called: start_kernel()

```main.c
asmlinkage void __init start_kernel(void)
{
...
	// irqs_disabled(): 1
	WARN(!irqs_disabled(), "Interrupts were enabled early\n");

	// early_boot_irqs_disabled: true
	early_boot_irqs_disabled = false;
	// early_boot_irqs_disabled: false

	local_irq_enable();
	// IRQ를 enable 함

	kmem_cache_init_late(); // null function

	/*
	 * HACK ALERT! This is early. We're enabling the console before
	 * we've done PCI setups etc, and console_init() must be aware of
	 * this. But we do want output early, in case something goes wrong.
	 */
	console_init();
```

* call: start_kernel()->console_init()

## tty_io.c::console_init()
* called: start_kernel()->console_init()

```tty_io.c
// ARM10C 20150627
void __init console_init(void)
{
	initcall_t *call;

	/* Setup the default TTY line discipline. */
	tty_ldisc_begin();

	// tty_ldisc_begin에서 한일:
	// tty_ldiscs[0]: &tty_ldisc_N_TTY
	// (&tty_ldisc_N_TTY)->num: 0
	// (&tty_ldisc_N_TTY)->refcount: 0

	/*
	 * set up the console device so that later boot sequences can
	 * inform about problems etc..
	 */
	call = __con_initcall_start;
	// call: &__con_initcall_start

// 2015/06/27 종료
// 2015/07/04 시작

	// call: &__con_initcall_start
	while (call < __con_initcall_end) {
		// call: __initcall_con_init: con_init
		// call: __initcall_s3c24xx_serial_console_init:
		// s3c24xx_serial_console_init
		(*call)();
		call++;
	}
}
```

* call: start_kernel()->console_init()->con_init()
 - call: con_init()
 - call: s3c24xx_serial_console_init()

## vt.c::con_init()
* called: start_kernel()->console_init()->con_init()
 - call: con_init()

```console.h
// ARM10C 20150704
struct consw {
	struct module *owner;
	const char *(*con_startup)(void);
	void	(*con_init)(struct vc_data *, int);
	void	(*con_deinit)(struct vc_data *);
	void	(*con_clear)(struct vc_data *, int, int, int, int);
	void	(*con_putc)(struct vc_data *, int, int, int);
	void	(*con_putcs)(struct vc_data *, const unsigned short *, int, int, int);
	void	(*con_cursor)(struct vc_data *, int);
	int	(*con_scroll)(struct vc_data *, int, int, int, int);
	void	(*con_bmove)(struct vc_data *, int, int, int, int, int, int);
	int	(*con_switch)(struct vc_data *);
	int	(*con_blank)(struct vc_data *, int, int);
	int	(*con_font_set)(struct vc_data *, struct console_font *, unsigned);
	int	(*con_font_get)(struct vc_data *, struct console_font *);
	int	(*con_font_default)(struct vc_data *, struct console_font *, char *);
	int	(*con_font_copy)(struct vc_data *, int);
	int     (*con_resize)(struct vc_data *, unsigned int, unsigned int,
			       unsigned int);
	int	(*con_set_palette)(struct vc_data *, unsigned char *);
	int	(*con_scrolldelta)(struct vc_data *, int);
	int	(*con_set_origin)(struct vc_data *);
	void	(*con_save_screen)(struct vc_data *);
	u8	(*con_build_attr)(struct vc_data *, u8, u8, u8, u8, u8, u8);
	void	(*con_invert_region)(struct vc_data *, u16 *, int);
	u16    *(*con_screen_pos)(struct vc_data *, int);
	unsigned long (*con_getxy)(struct vc_data *, unsigned long, int *, int *);
	/*
	 * Prepare the console for the debugger.  This includes, but is not
	 * limited to, unblanking the console, loading an appropriate
	 * palette, and allowing debugger generated output.
	 */
	int	(*con_debug_enter)(struct vc_data *);
	/*
	 * Restore the console to its pre-debug state as closely as possible.
	 */
	int	(*con_debug_leave)(struct vc_data *);
};
```

```vt.c::con_init()
// ARM10C 20150704
static int __init con_init(void)
{
	const char *display_desc = NULL;
	// display_desc: NULL

	struct vc_data *vc;
	unsigned int currcons = 0, i;
	// currcons: 0

	console_lock();

	// console_lock에서 한일:
	// (&console_sem)->count: 0
	// console_locked: 1
	// console_may_schedule: 1

	// conswitchp: &dummy_con
	if (conswitchp)
		// conswitchp->con_startup: (&dummy_con)->con_startup: dummycon_startup
		// dummycon_startup(): &"dummy device"
		display_desc = conswitchp->con_startup();
		// display_desc: &"dummy device"

	// display_desc: &"dummy device"
	if (!display_desc) {
		fg_console = 0;
		console_unlock();
		return 0;
	}

	// MAX_NR_CON_DRIVER: 16
	for (i = 0; i < MAX_NR_CON_DRIVER; i++) {
		// i: 0
		struct con_driver *con_driver = &registered_con_driver[i];
		// con_driver: &registered_con_driver[0]

		// con_driver->con: (&registered_con_driver[0])->con: NULL
		if (con_driver->con == NULL) {
			// con_driver->con: (&registered_con_driver[0])->con, conswitchp: &dummy_con
			con_driver->con = conswitchp;
			// con_driver->con: (&registered_con_driver[0])->con: &dummy_con

			// con_driver->desc: (&registered_con_driver[0])->desc, display_desc: &"dummy device"
			con_driver->desc = display_desc;
			// con_driver->desc: (&registered_con_driver[0])->desc: &"dummy device"

			// con_driver->flag: (&registered_con_driver[0])->flag, CON_DRIVER_FLAG_INIT: 2
			con_driver->flag = CON_DRIVER_FLAG_INIT;
			// con_driver->flag: (&registered_con_driver[0])->flag: 2

			// con_driver->first: (&registered_con_driver[0])->first
			con_driver->first = 0;
			// con_driver->first: (&registered_con_driver[0])->first: 0

			// con_driver->last: (&registered_con_driver[0])->last, MAX_NR_CONSOLES: 63
			con_driver->last = MAX_NR_CONSOLES - 1;
			// con_driver->last: (&registered_con_driver[0])->last: 62

			break;
			// break 수행
		}
	}

	// MAX_NR_CONSOLES: 63
	for (i = 0; i < MAX_NR_CONSOLES; i++)
		// i: 0, conswitchp: &dummy_con
		con_driver_map[i] = conswitchp;
		// con_driver_map[0]: &dummy_con

		// i: 1...62 loop 수행

	// blankinterval: 600
	if (blankinterval) {
		// blank_normal_wait: 1
		blank_state = blank_normal_wait;
		// blank_state: 1

		// NOTE:
		// jiffies은 interrupt enable이 되었기 때문에
		// 실시간으로 변하는 값이므로 현재 시간값을 알수 없음
		// jiffiex: xx_64 로 주석을 작성하도록 함

// 2015/07/04 종료
// 2015/07/11 시작

		// jiffies: xx_64, blankinterval: 600, HZ: 100
		// mod_timera(&console_timer, xx_64 + 60000): 0
		mod_timer(&console_timer, jiffies + (blankinterval * HZ));

		// mod_timer에서 한일:
		// (&console_timer)->expires: xx_64 + 60000
		//
		// NOTE:
		// idx의 값을 가정하고 분석, xx_64은 0이라 보고
		// idx값이 90000의 값을 가진것으로 분석 진행
		// 계산값 xx_64 + 90000 0 보다 크다고 가정하고 분석 진행
		// FIXME:
		// TVR_SIZE: 256 값이 왜 256 인지??
		//
		// &(&boot_tvec_bases)->tv3.vec[3]에 &(&console_timer)->entry을 tail에 연결
		// (&boot_tvec_bases)->active_timers: 1
	}

// 2015/07/11 종료
	for (currcons = 0; currcons < MIN_NR_CONSOLES; currcons++) {
		vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);
		INIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);
```

* call: start_kernel()->console_init()->con_init()
 - mod_timer()

## timer.c::mod_timer()
* called: start_kernel()->console_init()->con_init()
 - mod_timer()
